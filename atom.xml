<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>薯片忍者的小站</title>
  
  <subtitle>今天的故事 是明天的回忆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pcninja.cn/"/>
  <updated>2020-07-10T13:51:59.261Z</updated>
  <id>https://blog.pcninja.cn/</id>
  
  <author>
    <name>薯片忍者</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《图解密码技术》读书笔记</title>
    <link href="https://blog.pcninja.cn/2020/07/notes-on-graphic-cryptography/"/>
    <id>https://blog.pcninja.cn/2020/07/notes-on-graphic-cryptography/</id>
    <published>2020-07-10T11:54:33.000Z</published>
    <updated>2020-07-10T13:51:59.261Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前对现代密码学的相关技术一直处于一知半解的状态，直到这两天读了结城浩的《图解密码技术》才对密码技术有了较为全面和深入的了解。首先要指出的是，“密码”一词在中文里的意义十分含糊，因为它在一般人眼里具有多个意思：</p><ol><li>登录网站时所输入的“密码”，严格意义上应该叫做<strong>口令</strong>(password)；</li><li>我们暂时看不懂的内容，比如“DNA 密码”，实际上这只是一种神秘的<strong>编码</strong>(encode)；</li><li>保证信息安全的技术，这才是真正意义上的密码(cryptography)。</li></ol><p>&emsp;&emsp;密码学和密码技术中的“密码”指的都是上面的第 3 个意思，口令和编码不属于密码学的范畴。</p><p>&emsp;&emsp;被称作“密码学家的工具箱”的 6 种基本密码技术是：<strong>对称密码</strong>、<strong>公钥密码</strong>、<strong>单向散列函数</strong>、<strong>消息认证码</strong>、<strong>数字签名</strong>和<strong>伪随机数生成器</strong>。<br><a id="more"></a></p><h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><p>&emsp;&emsp;使用相同的密钥进行加密和解密。用于确保消息的机密性，但需要解决密钥配送问题。对称密码算法：</p><ul><li>DES：不应再用于任何新的用途</li><li>三重 DES：不应再用于任何新的用途，仅在一些重视兼容性的环境中仍使用，会逐渐被 AES 取代</li><li>AES（Rijndael）：安全、快速，应该使用</li><li>AES 最终候选算法：可以作为 AES 的备份</li><li>自制算法：不应该使用</li></ul><h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>&emsp;&emsp;使用公钥进行加密，使用私钥进行解密。用于确保消息的机密性，能够解决密钥配送问题。但速度慢，且存在被中间人攻击的风险。公钥密码算法：</p><ul><li>RSA</li><li>ElGamal</li><li>Rabin</li><li>椭圆曲线密码（ECC）</li></ul><h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><p>&emsp;&emsp;将长消息转换为短散列值。用于确保消息的完整性。单向散列函数算法：</p><ul><li>MD5：不安全，不应该使用</li><li>SHA-1：不应该被用于新的用途</li><li>SHA-2（SHA-224、SHA-256、SHA-384、SHA-512）：安全，可以使用</li><li>SHA-3：安全，可以使用</li></ul><h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>&emsp;&emsp;识别通信对象发送的消息是否被篡改。用于验证消息的完整性，以及对消息进行认证，但无法对第三方进行认证，也无法防止否认。消息认证码算法：</p><ul><li>HMAC</li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>&emsp;&emsp;对第三方进行消息认证，防止通信对象做出否认。相当于公钥密码的逆过程：通过私钥进行签名，通过公钥对签名进行验证。<strong>证书=公钥+认证机构的数字签名</strong>。数字签名算法：</p><ul><li>RSA</li><li>ElGamal</li><li>DSA</li><li>椭圆曲线 DSA（ECDSA）</li><li>爱德华曲线 DSA（EDDSA）</li></ul><h2 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h2><p>&emsp;&emsp;生成具备不可预测性的比特序列，由密码和单向散列函数等技术构成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前对现代密码学的相关技术一直处于一知半解的状态，直到这两天读了结城浩的《图解密码技术》才对密码技术有了较为全面和深入的了解。首先要指出的是，“密码”一词在中文里的意义十分含糊，因为它在一般人眼里具有多个意思：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;登录网站时所输入的“密码”，严格意义上应该叫做&lt;strong&gt;口令&lt;/strong&gt;(password)；&lt;/li&gt;
&lt;li&gt;我们暂时看不懂的内容，比如“DNA 密码”，实际上这只是一种神秘的&lt;strong&gt;编码&lt;/strong&gt;(encode)；&lt;/li&gt;
&lt;li&gt;保证信息安全的技术，这才是真正意义上的密码(cryptography)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;密码学和密码技术中的“密码”指的都是上面的第 3 个意思，口令和编码不属于密码学的范畴。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;被称作“密码学家的工具箱”的 6 种基本密码技术是：&lt;strong&gt;对称密码&lt;/strong&gt;、&lt;strong&gt;公钥密码&lt;/strong&gt;、&lt;strong&gt;单向散列函数&lt;/strong&gt;、&lt;strong&gt;消息认证码&lt;/strong&gt;、&lt;strong&gt;数字签名&lt;/strong&gt;和&lt;strong&gt;伪随机数生成器&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="https://blog.pcninja.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="密码" scheme="https://blog.pcninja.cn/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="数字签名" scheme="https://blog.pcninja.cn/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
      <category term="证书" scheme="https://blog.pcninja.cn/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>后浪</title>
    <link href="https://blog.pcninja.cn/2020/05/the-waves-behind/"/>
    <id>https://blog.pcninja.cn/2020/05/the-waves-behind/</id>
    <published>2020-05-04T04:00:49.000Z</published>
    <updated>2020-05-04T14:13:56.864Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;5月4日，B站献给新一代的青年宣言片。国家一级演员何冰走上舞台，以青年宣言《后浪》为词，认可、赞美与寄语年轻一代。（<a href="https://www.bilibili.com/video/BV1FV411d7u7" target="_blank" rel="noopener">原视频</a>）</p><div class="image-size-50"><img src="/2020/05/the-waves-behind/image.jpg" title="奔涌吧，后浪！"></div><a id="more"></a><blockquote><p>那些口口声声 “一代不如一代”的人<br>应该看看你们<br>就像我一样</p><p>我看着你们  满怀羡慕<br>人类积攒了几千年的财富<br>所有的知识、见识、智慧和艺术<br>像是专门为你们准备的礼物</p><p>科技繁荣 文化繁茂 城市繁华<br>现代文明的成果 被层层打开<br>可以尽情享用</p><p>自由学习一门语言  一门手艺<br>欣赏一部电影 去遥远的地方旅行<br>从小你们就在自由探索自己的兴趣<br>很多人在童年 就进入了不惑之年<br>不惑于自己喜欢什么 不喜欢什么</p><p>人与人之间的壁垒被打破<br>你们只凭相同的爱好 就能结交千万个值得干杯的朋友</p><p>你们拥有了 我们曾经梦寐以求的权利<br>选择的权利<br>你所热爱的  就是你的生活</p><p>你们有幸 遇见这样的时代<br>但时代更有幸 遇见这样的你们</p><p>我看着你们 满怀敬意<br>向你们的专业态度致敬<br>你们正在把传统的 变成现代的<br>把经典的 变成流行的<br>把学术的 变成大众的<br>把民族的 变成世界的<br>你们把自己的热爱<br>变成了一个和成千上万的人  分享快乐的事业</p><p>向你们的自信致敬<br>弱小的人才习惯嘲讽和否定<br>而内心强大的人 从不吝啬赞美和鼓励</p><p>向你们的大气致敬<br>小人同而不和<br>君子美美与共 和而不同<br>年轻的身体 容得下更多元的文化 审美 和价值观</p><p>有一天我终于发现<br>不只是我们在教你们如何生活<br>你们也在启发我们 怎样去更好的生活</p><p>那些抱怨“一代不如一代的人”<br>应该看看你们<br>就像我一样</p><p>我看着你们  满怀感激<br>因为你们 这个世界会更喜欢中国<br>因为一个国家最好看的风景<br>就是这个国家的年轻人<br>因为你们 这世上的小说 电影 音乐中表现的青春<br>不再是忧伤 迷茫<br>而是善良  勇敢  无私  无所畏惧<br>是心里有火  眼里有光</p><p>不用活成我们想象中的样子<br>我们这一代的想象力<br>不足以想象你们的未来</p><p>如果你们依然需要我们的祝福<br>那么<br>奔涌吧 后浪<br>我们在同一条奔涌的河流</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;5月4日，B站献给新一代的青年宣言片。国家一级演员何冰走上舞台，以青年宣言《后浪》为词，认可、赞美与寄语年轻一代。（&lt;a href=&quot;https://www.bilibili.com/video/BV1FV411d7u7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原视频&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;image-size-50&quot;&gt;&lt;img src=&quot;/2020/05/the-waves-behind/image.jpg&quot; title=&quot;奔涌吧，后浪！&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="转载" scheme="https://blog.pcninja.cn/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://blog.pcninja.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="青春" scheme="https://blog.pcninja.cn/tags/%E9%9D%92%E6%98%A5/"/>
    
      <category term="五四" scheme="https://blog.pcninja.cn/tags/%E4%BA%94%E5%9B%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 887. 鸡蛋掉落</title>
    <link href="https://blog.pcninja.cn/2020/04/super-egg-drop/"/>
    <id>https://blog.pcninja.cn/2020/04/super-egg-drop/</id>
    <published>2020-04-23T09:43:50.000Z</published>
    <updated>2020-04-23T13:06:43.884Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code> 共有 <code>N</code> 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>&emsp;&emsp;你知道存在楼层 <code>F</code>，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。<br>&emsp;&emsp;你的目标是<strong>确切</strong>地知道 <code>F</code> 的值是多少。无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的<strong>最小移动次数</strong>是多少？</p><p><strong>数据范围：</strong><code>1 &lt;= K &lt;= 100</code> <code>1 &lt;= N &lt;= 10000</code><br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：K = 1, N = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。</span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。</span><br><span class="line">如果它没碎，那么我们肯定知道 F = 2 。</span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：K = 2, N = 6</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure></p><p><strong>示例 3:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：K = 3, N = 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></p><p><strong>题解：</strong><br>&emsp;&emsp;考虑动态规划，我们用 <code>dp[K][N]</code> 表示有 <code>K</code> 个鸡蛋、<code>N</code> 层楼的状态下所需要的最少步数。当我们把一个鸡蛋从第 <code>X</code> 层楼扔下后，会有两种可能的结果：</p><ul><li>鸡蛋没碎，那么我们还是有 <code>K</code> 个鸡蛋，但答案只可能在第 <code>X</code> 层以上了，也就是说楼层数变为了 <code>N-X</code>，接下来需要的最少步数为 <code>dp[K][N-X]</code></li><li>鸡蛋碎了，那么我们只剩下 <code>K-1</code> 个鸡蛋了，答案被锁定在下面的 <code>X-1</code> 层楼种，故接下来需要的最少步数为 <code>dp[K-1][X-1]</code></li></ul><p>&emsp;&emsp;因为我们需要考虑的是在最坏情况下所需的步数，所以取二者的最大值作为从第 <code>X</code> 层楼扔下后需要的最少步数。然后，为了让最坏情况下需要的步数最少，我们需要确定究竟哪一个 <code>X</code> 的取值能够使得这个最大值最小。综上，我们可以列出状态转移方程如下：</p><script type="math/tex; mode=display">dp[K][N]=1+\min_{1\leq X\leq N}{\max\{dp[K][N-X],dp[K-1][X-1]\}}</script><p>&emsp;&emsp;有了转移方程，我们就可以求解每个状态的 <code>dp</code> 值了，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[K+<span class="number">1</span>][N+<span class="number">1</span>];   <span class="comment">//存放 superEggDrop(i, j)</span></span><br><span class="line">    <span class="keyword">int</span> i, j, p, times;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= K; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= K; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算 superEggDrop(i, j)，存入 dp[i][j]</span></span><br><span class="line">            dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= j; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从第 p 层扔</span></span><br><span class="line">                times = <span class="number">1</span> + max(dp[i<span class="number">-1</span>][p<span class="number">-1</span>], dp[i][j-p]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="number">-1</span> || times &lt; dp[i][j])</span><br><span class="line">                    dp[i][j] = times;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;考虑一下时间复杂度，一共 $O(KN)$ 种状态，每种状态需要枚举 <code>X</code>，耗时为 $O(N)$，因此时间复杂度为 $O(KN^2)$，显然会超时，因此我们需要优化时间复杂度。<br>&emsp;&emsp;状态数不好优化，那么我们就优化求解每种状态即确定 <code>X</code> 取值的时间复杂度。我们发现，<code>dp[K][N]</code> 是关于 <code>N</code> 的增函数，于是有：</p><ol><li><code>dp[K][N-X]</code> 随 <code>X</code> 增加单调递减</li><li><code>dp[K-1][X-1]</code> 随 <code>X</code> 增加单调递增</li></ol><p>&emsp;&emsp;而我们要找的是使得 <code>dp[K][N-X]</code> 和 <code>dp[K-1][X-1]</code> 的最大值最小的 <code>X</code> 的取值，显然，上述两个函数相交即 <code>dp[K][N-X] = dp[K-1][X-1]</code> 时，它们的最大值最小，交点对应的 <code>X</code> 的取值就是我们要找的 <code>X</code>。<br>&emsp;&emsp;通过以上对单调性的分析，我们就可以通过二分查找找到那个使得 <code>dp[K][N-X] &lt;= dp[K-1][X-1]</code> 的 <code>X</code> 的最小取值。这样，我们就把时间复杂度优化到了 $O(KN\log N)$，可成功通过此题。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[K+<span class="number">1</span>][N+<span class="number">1</span>];   <span class="comment">//存放 superEggDrop(i, j)</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= K; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= K; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            二分查找使得 dp[i-1][p-1] &gt;= dp[i][j-p] 的 p 的最小取值，</span></span><br><span class="line"><span class="comment">            则 dp[i][j] = min(</span></span><br><span class="line"><span class="comment">                            max(dp[i-1][p-1], dp[i][j-p]),</span></span><br><span class="line"><span class="comment">                            max(dp[i-1][p-2], dp[i][j-p+1])</span></span><br><span class="line"><span class="comment">                          ) + 1</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = j, mid;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][mid<span class="number">-1</span>] &gt;= dp[i][j-mid])</span><br><span class="line">                    r = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + min(max(dp[i<span class="number">-1</span>][l<span class="number">-1</span>], dp[i][j-l]), max(dp[i<span class="number">-1</span>][l<span class="number">-2</span>], dp[i][j-l+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;你将获得 &lt;code&gt;K&lt;/code&gt; 个鸡蛋，并可以使用一栋从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;N&lt;/code&gt; 共有 &lt;code&gt;N&lt;/code&gt; 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。&lt;br&gt;&amp;emsp;&amp;emsp;你知道存在楼层 &lt;code&gt;F&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt;= F &amp;lt;= N&lt;/code&gt; 任何从高于 &lt;code&gt;F&lt;/code&gt; 的楼层落下的鸡蛋都会碎，从 &lt;code&gt;F&lt;/code&gt; 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 &lt;code&gt;X&lt;/code&gt; 扔下（满足 &lt;code&gt;1 &amp;lt;= X &amp;lt;= N&lt;/code&gt;）。&lt;br&gt;&amp;emsp;&amp;emsp;你的目标是&lt;strong&gt;确切&lt;/strong&gt;地知道 &lt;code&gt;F&lt;/code&gt; 的值是多少。无论 &lt;code&gt;F&lt;/code&gt; 的初始值如何，你确定 &lt;code&gt;F&lt;/code&gt; 的值的&lt;strong&gt;最小移动次数&lt;/strong&gt;是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围：&lt;/strong&gt;&lt;code&gt;1 &amp;lt;= K &amp;lt;= 100&lt;/code&gt; &lt;code&gt;1 &amp;lt;= N &amp;lt;= 10000&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="二分查找" scheme="https://blog.pcninja.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="动态规划" scheme="https://blog.pcninja.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 HTTPS 强制跳转以及 HSTS</title>
    <link href="https://blog.pcninja.cn/2020/04/on-HTTPS-forced-jump-and-HSTS/"/>
    <id>https://blog.pcninja.cn/2020/04/on-HTTPS-forced-jump-and-HSTS/</id>
    <published>2020-04-16T07:31:43.000Z</published>
    <updated>2020-04-16T08:39:51.029Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在上一篇博文 <a href="https://blog.pcninja.cn/2020/04/apply-for-certificate-and-HTTPS-related-configuration/">『用 acme.sh 申请通配符证书及 HTTPS 相关配置』</a> 中已经介绍了如何申请通配符证书并安装到 Nginx 服务中，在此不再赘述。<br>&emsp;&emsp;为了让所有访客都通过 HTTPS 进行安全访问，我们需要将使用 HTTP 的连接强制跳转到 HTTPS 连接上。主要的方法有三种：</p><ul><li>前端跳转（不推荐）</li><li>301/302 重定向（推荐）</li><li>HSTS（推荐）</li></ul><p>&emsp;&emsp;接下来我们详细说说这三种方法的实现方法以及利弊。<br><a id="more"></a></p><h3 id="方法一：前端跳转"><a href="#方法一：前端跳转" class="headerlink" title="方法一：前端跳转"></a>方法一：前端跳转</h3><p>&emsp;&emsp;前端使用 JavaScript 进行跳转，虽然有点蠢，但的确不失为一种办法。只需在所有页面的 HTML 里加入一段 JS 就能实现：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="built_in">window</span>.location.protocol != <span class="string">"https"</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.location.href = <span class="string">"https"</span> + <span class="built_in">window</span>.location.href.substring(<span class="built_in">window</span>.location.protocol.length);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>&emsp;&emsp;我实在想不出来这种方法有什么优点。。。大概只有在我们控制不了服务端只能修改前端的时候才会选择这种下下策吧。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>因为是在浏览器端进行跳转，所以我们没法保证用户一定跳转了，很不安全</li><li>跳转后又要请求下载一遍所有资源，浪费带宽</li><li>在跳转之前所有的内容已经通过 HTTP 明文传输到客户端了，完全起不到保护的作用</li><li>太多了，不一一列举了…</li></ul><p>&emsp;&emsp;当然，你可以让服务端对所有 HTTP 请求只返回这段 JS，对 HTTPS 请求返回正确页面，来增加一点点安全性。但是，既然你都已经分开处理 HTTP 和 HTTPS 请求了，那为什么不用接下来这两种方法呢？</p><h3 id="方法二：301-302-重定向"><a href="#方法二：301-302-重定向" class="headerlink" title="方法二：301/302 重定向"></a>方法二：301/302 重定向</h3><p>&emsp;&emsp;由服务端控制，如果请求的协议是 HTTP，则返回状态码 301（永久重定向） 或 302（暂时重定向），让浏览器重定向到 HTTPS 上。对于 Nginx，我们可以通过分别监听 80 和 443 端口来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 加一个监听 80 端口的 server，直接返回 301</span><br><span class="line">server &#123;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 原本的 server 只接受 443 端口的请求</span><br><span class="line">server &#123;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>所有的内容都只能通过 HTTPS 安全传输，安全性高</li><li>状态码清晰明确，对搜索引擎友好，有利于收录</li><li>想要关闭强制 HTTPS 访问时可以即刻生效</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>浏览器会向服务端请求两次：第一次发起 HTTP 请求，收到 301 重定向，第二次再发起 HTTPS 请求</li><li>可能遭受中间人的降级攻击</li><li>当浏览器发现当前的 HTTPS 连接不安全，例如证书过期，域名无效等问题时，浏览器会警告用户，但仍会允许用户继续这种不安全的访问，不会强行阻止</li></ul><div class="image-size-80"><img src="/2020/04/on-HTTPS-forced-jump-and-HSTS/img1.png" title="浏览器允许用户强行访问"></div><h3 id="方法三：HSTS"><a href="#方法三：HSTS" class="headerlink" title="方法三：HSTS"></a>方法三：HSTS</h3><p>&emsp;&emsp;为了省去浏览器第一次向服务端发起的 HTTP 请求，HSTS（HTTP Strict Transport Security，HTTP严格传输安全协议）应运而生。HSTS 的功能就是：即使用户输入的 URL 是 HTTP 协议，浏览器也会直接 307 重定向到 HTTPS 协议。<br>&emsp;&emsp;实现方法就是在服务器返回给浏览器的响应头中加入 <code>Strict-Transport-Security</code> 这个头。HSTS Header 的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中，<code>max-age</code> 是必选参数，是一个以秒为单位的数值，代表 HSTS Header 的过期时间，通常设置为 31536000，即一年的时间。<code>includeSubDomains</code> 是可选参数，如果包含它，则意味着当前域名及其子域名均开启 HSTS 保护。<code>preload</code> 是可选参数，如果你想申请将自己的域名加入到浏览器的内置列表那么需要包含这个参数，关于这个参数我们接下来细说。<br>&emsp;&emsp;以 Nginx 为例，要想启用 HSTS，只需要在配置文件中加入这样一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 过期时间一年，保护所有子域名</span><br><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;重启 Nginx 服务后，我们在 <a href="https://myssl.com" target="_blank" rel="noopener">MySSL</a> 上重新生成评估报告，发现可以评到最高级 <code>A+</code>，意味着你的网站现在是全世界最安全的网站之一（其实并没有什么卵用）。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>你的 HSTS 信息在访客浏览器中生效期间可以有效防止中间人攻击</li><li>浏览器端直接 307 重定向，省去了服务端进行重定向</li><li>证书无效时浏览器完全阻断访问</li></ul><div class="image-size-80"><img src="/2020/04/on-HTTPS-forced-jump-and-HSTS/img2.png" title="浏览器阻止用户继续访问"></div><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>一旦你加上了 <code>Strict-Transport-Security</code> 这个头，就不能轻易取消 HTTPS 服务了，否则你的访客在他浏览器的 HSTS 信息过期之前都无法正常访问</li><li><strong>可能</strong>会在某些浏览器中造成一些奇奇怪怪的谜之错误导致你的网站不能被正常访问</li></ul><h3 id="关于-HSTS-Preload-List"><a href="#关于-HSTS-Preload-List" class="headerlink" title="关于 HSTS Preload List"></a>关于 HSTS Preload List</h3><p>&emsp;&emsp;我们仔细想想就不难发现，HSTS 虽然牛逼，可以很好的解决 HTTPS 降级攻击，但是有一个致命缺陷，就是对于 HSTS 生效前的首次 HTTP 请求，依然无法避免被劫持。换句话说，当用户第一次访问网站的时候，浏览器没有当前网站的 HSTS 信息，所以就会产生一次明文的 HTTP 请求，尽管服务端可以返回 301 重定向，但在这个过程中，仍然避免不了中间人攻击。<br>&emsp;&emsp;为了解决这个问题，Chrome 提出了 HSTS Preload List 方案，就是在浏览器里内置一份定期更新的列表，对于列表中的域名，即使用户之前没有访问过，浏览器也会强行使用 HTTPS 协议。目前，主流的浏览器（Chrome、Firefox、Opera、Safari、IE11、Edge）都支持这份由 Chrome 维护的 HSTS Preload List。你可以在它的官网 <a href="https://hstspreload.org" target="_blank" rel="noopener">hstspreload.org</a> 上查询到一个网站是否在这份列表之中。<br>&emsp;&emsp;如果你想要把你的域名加入到 HSTS Preload List 中，那么你需要满足官网中列出的所有条件，然后在 <code>Strict-Transport-Security</code> 头里加入 <code>preload</code> 参数。由于这份列表是硬编码到浏览器中的，所以需要过一段时间你的网站才会被加入到稳定版本的列表中。要注意，<strong>一旦你的网站被列入了 HSTS Preload List，想要再从里面出来可就不那么容易了</strong>，提交申请后同样需要等很长一段时间才会被彻底除名，官网对此过程的描述是“slow and painful”。所以，<strong>除非你能保证你的网站能够持续稳定地提供 HTTPS 服务，否则不要轻易使用 <code>preload</code> 参数</strong>。</p><div class="image-size-80"><img src="/2020/04/on-HTTPS-forced-jump-and-HSTS/img3.png" title="HSTS Preload List 官网中列出的加入条件"></div><p>&emsp;&emsp;总的来说，我感觉 HSTS 虽然提供了一个很好的方向，能够很大程度上增强通信的安全性，但仍旧有许多不靠谱的地方，亟需升级改善。所以我认为对于普通网站（非金融、支付相关），完全没有必要使用 HSTS 方式加以保护，301/302 重定向就足够了。当然，强迫症患者除外😂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在上一篇博文 &lt;a href=&quot;https://blog.pcninja.cn/2020/04/apply-for-certificate-and-HTTPS-related-configuration/&quot;&gt;『用 acme.sh 申请通配符证书及 HTTPS 相关配置』&lt;/a&gt; 中已经介绍了如何申请通配符证书并安装到 Nginx 服务中，在此不再赘述。&lt;br&gt;&amp;emsp;&amp;emsp;为了让所有访客都通过 HTTPS 进行安全访问，我们需要将使用 HTTP 的连接强制跳转到 HTTPS 连接上。主要的方法有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端跳转（不推荐）&lt;/li&gt;
&lt;li&gt;301/302 重定向（推荐）&lt;/li&gt;
&lt;li&gt;HSTS（推荐）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;接下来我们详细说说这三种方法的实现方法以及利弊。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://blog.pcninja.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="https://blog.pcninja.cn/tags/HTTPS/"/>
    
      <category term="Nginx" scheme="https://blog.pcninja.cn/tags/Nginx/"/>
    
      <category term="网络" scheme="https://blog.pcninja.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HSTS" scheme="https://blog.pcninja.cn/tags/HSTS/"/>
    
  </entry>
  
  <entry>
    <title>用 acme.sh 申请通配符证书及 HTTPS 相关配置</title>
    <link href="https://blog.pcninja.cn/2020/04/apply-for-certificate-and-HTTPS-related-configuration/"/>
    <id>https://blog.pcninja.cn/2020/04/apply-for-certificate-and-HTTPS-related-configuration/</id>
    <published>2020-04-16T02:54:22.000Z</published>
    <updated>2020-04-16T08:33:11.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;最近小站新增了几个二级域名，如果给每个二级域名都单独申请一个 SSL/TLS 证书未免太过麻烦，因此这次希望申请一个通配符证书，使其支持所有二级域名。<br>&emsp;&emsp;此前我一直用 Certbot 申请 Let’s Encrypt 证书，这也是 Let’s Encrypt 官方推荐的证书管理工具，具体使用方法请见我的另一篇博文 <a href="https://blog.pcninja.cn/2018/11/letsencrypt-certificates-and-https-in-nodejs/">『申请Let’s Encrypt免费SSL证书并在Node.js建立HTTPS服务』</a>。但是后来我发现 Certbot 有些不方便，因为如果用 <code>pip</code> 进行安装很容易遇到 Python2 和 Python3 的兼容性问题，不过后来改用 <code>certbot-auto</code> 脚本解决了大部分问题。<br>&emsp;&emsp;尝试过 acme.sh 后我彻底抛弃了 Certbot，因为它使用纯 Shell 语言编写，对各大发行版都很友好，也自然不存在 Python 的兼容问题。最重要的是 acme.sh 和 Certbot 都支持申请通配符证书，而且 acme.sh 在安装的时候就自动通过 <code>crontab</code> 配置好了自动更新证书的定时任务，不需要我们自己手动配置。因此 acme.sh 总体给我的感觉就是比 Certbot 省事不少。<br><a id="more"></a></p><h2 id="使用-acme-sh-申请证书"><a href="#使用-acme-sh-申请证书" class="headerlink" title="使用 acme.sh 申请证书"></a>使用 acme.sh 申请证书</h2><blockquote><p>项目官方仓库：<a href="https://github.com/acmesh-official/acme.sh" target="_blank" rel="noopener">https://github.com/acmesh-official/acme.sh</a></p></blockquote><h3 id="安装-acme-sh"><a href="#安装-acme-sh" class="headerlink" title="安装 acme.sh"></a>安装 acme.sh</h3><p>&emsp;&emsp;安装过程很简单，一句话就能搞定：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个脚本会将 acme.sh 安装在你的家目录下的 <code>~/.acme.sh/</code>，不会污染系统和其他任何地方的文件。安装过程中会自动创建 bash 的一个 alias：<code>alias acme.sh=~/.acme.sh/acme.sh</code>，因为我用的是 <code>zsh</code> 所以需要重新载入一下配置文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样一来，我们就可以在任意地方直接使用 <code>acme.sh</code> 命令了。此外，我们还可以设置一下电子邮箱，以便在证书过期前可以收到通知（此步骤可省略）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --update-account --accountemail example@example.com</span><br></pre></td></tr></table></figure></p><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><p>&emsp;&emsp;和 Certbot 一样，acme.sh 实现了 ACME 协议支持的所有验证协议，最常使用的两种方式验证是 HTTP 和 DNS 验证。因为我们要申请的是通配符证书，所以只能选择 DNS 方式验证。<br>&emsp;&emsp;acme.sh 支持很多常用 DNS 提供商的 API，具体列表及使用方式请见 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">官方 Wiki</a>。如果你的 DNS 提供商不在这里，那么你就只能通过手动设置 DNS 的方式进行验证，而且没法自动更新证书，因为每次更新证书都需要进行 DNS 验证。<br>&emsp;&emsp;我使用的是腾讯云的 DNS 解析服务（其实就是 DNSPod），因此我们需要先取得 DNSPod 的密钥：登录 DNSPod（不是腾讯云），通过控制台进入密钥管理界面，新建一组密钥，保存好 <code>ID</code> 和 <code>Token</code>。</p><div class="image-size-80"><img src="/2020/04/apply-for-certificate-and-HTTPS-related-configuration/img1.png" title="创建密钥"></div><p>接下来将刚刚取得的 <code>ID</code> 和 <code>Token</code> 写入环境变量：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DP_Id="your ID"</span><br><span class="line">export DP_Key="your Token"</span><br></pre></td></tr></table></figure></p><p>然后我们就可以通过 acme.sh 申请 Let’s Encrypt 证书了，注意将 <code>example.com</code> 换成你的域名：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --issue --dns dns_dp -d example.com -d *.example.com</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果顺利的话，就会成功生成一张同时支持主域（<code>example.com</code>）和所有二级域名（<code>*.example.com</code>）的通配符证书。同时，acme.sh 会在本地保存你的 <code>ID</code> 和 <code>Token</code> 以便之后自动更新证书时重新验证 DNS 用。<br>&emsp;&emsp;通过 <code>acme.sh --list</code> 命令可以看到我们生成的证书列表，证书相关文件保存在 <code>~/.acme.sh/你的域名</code> 下，其中 <code>fullchain.cer</code> 和 <code>你的域名.key</code> 分别是完整证书文件和私钥文件，是接下来配置服务端需要用到的两个文件。</p><div class="image-size-80"><img src="/2020/04/apply-for-certificate-and-HTTPS-related-configuration/img2.png" title="证书列表"></div><h2 id="安装证书到-Nginx"><a href="#安装证书到-Nginx" class="headerlink" title="安装证书到 Nginx"></a>安装证书到 Nginx</h2><p>&emsp;&emsp;我们已经通过 acme.sh 申请好了证书，接下来需要将证书配置到服务端，使其支持 HTTPS。我在 <a href="https://blog.pcninja.cn/2018/11/letsencrypt-certificates-and-https-in-nodejs/">『申请Let’s Encrypt免费SSL证书并在Node.js建立HTTPS服务』</a> 一文中曾经介绍了如何在 Node.js 中配置证书，因此这里我主要介绍如何给 Nginx 配置 HTTPS 服务。<br>&emsp;&emsp;在 Nginx 配置文件 <code>nginx.conf</code> 中的 http 模块中新增如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2;  # 支持协议类型，为了安全性建议这么配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_certificate     ~/.acme.sh/example.com/fullchain.cer;   # 证书文件</span><br><span class="line">    ssl_certificate_key ~/.acme.sh/example.com/example.com.key; # 私钥文件</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;关于 <code>ssl_protocols</code> 的配置，其默认值为 <code>TLSv1 TLSv1.1 TLSv1.2</code>，但是根据最新的 PCI DSS 合规判定标准，如果开启 TLS1.0 或更早的加密协议将会判定为不合规，因此为了满足更高的要求，推荐大家禁用 TLS1.0 ，但这样做会导致诸如 IE8 等一些老旧浏览器无法兼容，所以如果你想要支持那些古董浏览器，那么就不得不牺牲安全性了。但目前 99.999% 的浏览器都是支持 TLS1.1 及更新标准的，喜欢折腾的还可以让 Nginx 支持最新的 TLS1.3标准。<br>&emsp;&emsp;接下来，在配置文件的 server 模块中加入 443 端口的监听。例如，如果我们希望用户可以同时通过 HTTP 和 HTTPS 访问的话，可以同时监听 80 和 443 端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    listen [::]:443 ssl;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后，我们检查 Nginx 配置文件并重启 Nginx 即可开启 HTTPS 访问：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t               # 检查配置文件</span><br><span class="line">sudo service nginx restart  # 重启 Nginx 服务</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们配置完成后，可以在 <a href="https://myssl.com" target="_blank" rel="noopener">MySSL</a> 上检测一下我们部署了 SSL/TLS 的网站是否符合各项行业标准和规范。如果你禁用了 TLS1.0 的话，大概会得到这样的评级：</p><div class="image-size-50"><img src="/2020/04/apply-for-certificate-and-HTTPS-related-configuration/img3.png" title="评估报告"></div><p>&emsp;&emsp;评到了 <code>A</code> 级代表我们网站的 HTTPS 服务已经十分安全，但如果你有强迫症想要评到 <code>A+</code> 级则需要开启 HSTS（HTTP Strict Transport Security，HTTP严格传输安全协议）。<br>&emsp;&emsp;关于 HTTP 强制跳转到 HTTPS 的实现方法以及 HSTS 更多信息，可以看看我的另一篇博文 <a href="https://blog.pcninja.cn/2020/04/on-HTTPS-forced-jump-and-HSTS/">『浅谈 HTTPS 强制跳转以及 HSTS』</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近小站新增了几个二级域名，如果给每个二级域名都单独申请一个 SSL/TLS 证书未免太过麻烦，因此这次希望申请一个通配符证书，使其支持所有二级域名。&lt;br&gt;&amp;emsp;&amp;emsp;此前我一直用 Certbot 申请 Let’s Encrypt 证书，这也是 Let’s Encrypt 官方推荐的证书管理工具，具体使用方法请见我的另一篇博文 &lt;a href=&quot;https://blog.pcninja.cn/2018/11/letsencrypt-certificates-and-https-in-nodejs/&quot;&gt;『申请Let’s Encrypt免费SSL证书并在Node.js建立HTTPS服务』&lt;/a&gt;。但是后来我发现 Certbot 有些不方便，因为如果用 &lt;code&gt;pip&lt;/code&gt; 进行安装很容易遇到 Python2 和 Python3 的兼容性问题，不过后来改用 &lt;code&gt;certbot-auto&lt;/code&gt; 脚本解决了大部分问题。&lt;br&gt;&amp;emsp;&amp;emsp;尝试过 acme.sh 后我彻底抛弃了 Certbot，因为它使用纯 Shell 语言编写，对各大发行版都很友好，也自然不存在 Python 的兼容问题。最重要的是 acme.sh 和 Certbot 都支持申请通配符证书，而且 acme.sh 在安装的时候就自动通过 &lt;code&gt;crontab&lt;/code&gt; 配置好了自动更新证书的定时任务，不需要我们自己手动配置。因此 acme.sh 总体给我的感觉就是比 Certbot 省事不少。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://blog.pcninja.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SSL" scheme="https://blog.pcninja.cn/tags/SSL/"/>
    
      <category term="TLS" scheme="https://blog.pcninja.cn/tags/TLS/"/>
    
      <category term="HTTPS" scheme="https://blog.pcninja.cn/tags/HTTPS/"/>
    
      <category term="Nginx" scheme="https://blog.pcninja.cn/tags/Nginx/"/>
    
      <category term="网络" scheme="https://blog.pcninja.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么 memset() 只能将 int 数组初始化为 0 或 -1</title>
    <link href="https://blog.pcninja.cn/2020/04/why-memset-can-only-initialize-int-array-to-0-or-1/"/>
    <id>https://blog.pcninja.cn/2020/04/why-memset-can-only-initialize-int-array-to-0-or-1/</id>
    <published>2020-04-12T13:32:54.000Z</published>
    <updated>2020-04-12T14:02:31.763Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;C/C++ 标准库提供了很多常用的工具函数，比如在 <code>&lt;string.h&gt;</code> 中的 <code>memset()</code> 函数就常常被用来初始化数组，但它在初始化 <code>int</code> 等类型数组的时候只能初始化为 0 或 -1，如果识图用 <code>memset()</code> 将数组初始化为 1，就会发现每个元素都变成了 16843009。<br>&emsp;&emsp;造成这种情况的原因很简单，因为 <code>memset()</code> 的作用是将内存块填充为指定的字符，这也是为什么它包含在 <code>string.h</code> 里的原因。因此，<code>memset()</code> 对内存进行赋值是以字节为单位的。<br>&emsp;&emsp;比如我们调用 <code>memset()</code> 将 <code>int</code> 数组初始化为 1，那么数组的每个字节（不是元素）都会被设置为 <code>00000001</code>，而 <code>int</code> 占 4 个字节，故每个元素的值就是 <code>00000001 00000001 00000001 00000001</code>，该二进制值就是十进制的 16843009，所以 <code>memset()</code> 函数不能把整型数组初始化为 1。<br>&emsp;&emsp;对于长度大于 1 个字节的变量，只能通过 <code>memset()</code> 设置为各字节相同的值，比如 0（全零）或 -1（全1），不能赋各字节不同的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;C/C++ 标准库提供了很多常用的工具函数，比如在 &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;memset()&lt;/code&gt; 函数就常常被用来初始化数组，但它在初始化 &lt;code&gt;int&lt;/code&gt; 等类型数组的
      
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C" scheme="https://blog.pcninja.cn/tags/C/"/>
    
      <category term="C++" scheme="https://blog.pcninja.cn/tags/C/"/>
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 48. 旋转图像</title>
    <link href="https://blog.pcninja.cn/2020/04/rotate-image/"/>
    <id>https://blog.pcninja.cn/2020/04/rotate-image/</id>
    <published>2020-04-07T03:45:28.000Z</published>
    <updated>2020-04-08T11:25:12.157Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 n × n 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。</p><p><strong>说明:</strong><br>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请<strong>不要</strong>使用另一个矩阵来旋转图像。<br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>每转一个元素，就要把目的地当前的元素也转到目标位置，以此类推，一共要转4个元素。<br>例如，要想转动 <code>m[i][j]</code>，那么对应的四个元素要按照 <code>m[i][j] -&gt; m[j][N-i-1] -&gt; m[N-i-1][N-j-1] -&gt; m[N-j-1][i]</code> 的方式转动。<br>所以，我们只需要转矩阵的左上角的元素，让其他地方的元素跟着转。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; matrixSize/<span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; (matrixSize+<span class="number">1</span>)/<span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 旋转对应位置上的4个数：</span></span><br><span class="line">            <span class="comment">// m[i][j] -&gt; m[j][N-i-1] -&gt; m[N-i-1][N-j-1] -&gt; m[N-j-1][i]</span></span><br><span class="line">            k = matrix[matrixSize-j<span class="number">-1</span>][i];</span><br><span class="line">            matrix[matrixSize-j<span class="number">-1</span>][i] = matrix[matrixSize-i<span class="number">-1</span>][matrixSize-j<span class="number">-1</span>];</span><br><span class="line">            matrix[matrixSize-i<span class="number">-1</span>][matrixSize-j<span class="number">-1</span>] = matrix[j][matrixSize-i<span class="number">-1</span>];</span><br><span class="line">            matrix[j][matrixSize-i<span class="number">-1</span>] = matrix[i][j];</span><br><span class="line">            matrix[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)。</p><div class="image-size-50"><img src="/2020/04/rotate-image/image.png" title="提交结果"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;br&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你必须在&lt;strong&gt;原地&lt;/strong&gt;旋转图像，这意味着你需要直接修改输入的二维矩阵。请&lt;strong&gt;不要&lt;/strong&gt;使用另一个矩阵来旋转图像。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="原地算法" scheme="https://blog.pcninja.cn/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 42. 接雨水</title>
    <link href="https://blog.pcninja.cn/2020/04/trapping-rain-water/"/>
    <id>https://blog.pcninja.cn/2020/04/trapping-rain-water/</id>
    <published>2020-04-04T00:50:24.000Z</published>
    <updated>2020-04-08T11:16:56.864Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><div class="image-size-50"><img src="/2020/04/trapping-rain-water/img1.png" title="上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）"></div><a id="more"></a><p><strong>示例:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>&emsp;&emsp;每个位置上能存多少水取决于它左右两侧的最高峰较低的那一峰的高度，比如图中第六个位置上，它左侧最高为2格，右侧最高为3格，所以这一列的水位能到2格的高度。<br>&emsp;&emsp;所以我们的算法就是：首先从左往右扫一趟数组，算出每个位置上左侧的最高峰；再从右往左扫一趟数组，算出每个位置上右侧的最高峰。最后遍历一遍求出每个位置上的积水量。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x,y) ((x)&lt;(y)?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span> *height, <span class="keyword">int</span> heightSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!heightSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, temp, i;</span><br><span class="line">    <span class="keyword">int</span> leftTop[heightSize], rightTop[heightSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算leftTop和rightTop */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, leftTop[<span class="number">0</span>] = <span class="number">0</span>; i &lt; heightSize; ++i)</span><br><span class="line">        leftTop[i] = max(leftTop[i<span class="number">-1</span>], height[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i = heightSize<span class="number">-2</span>, rightTop[heightSize<span class="number">-1</span>] = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        rightTop[i] = max(rightTop[i+<span class="number">1</span>], height[i+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; heightSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = min(leftTop[i], rightTop[i]) - height[i];</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">            ans += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这种解法遍历了三趟数组，所以时间复杂度为 O(n)。用到了 leftTop 和 rightTop 两个数组，所以空间复杂度也是 O(n)。</p><div class="image-size-50"><img src="/2020/04/trapping-rain-water/img2.png" title="几乎双百"></div><p>&emsp;&emsp;官方题解提供了一种更优秀的解法，可以只遍历一次数组，且空间复杂度为 O(1)：<br>&emsp;&emsp;双指针法，一个指针从左往右移动，另一个从右往左移动。维护两个变量 left_max 和 right_max ，分别存储左右两边目前为止遇到的最高峰。<br>&emsp;&emsp;一开始，两个指针分别指向最左侧和最右侧的元素。如果左侧指针的高度比右侧矮，左侧指针就右移一格，否则就右侧指针左移。换句话说，就是始终保持对侧是不矮于本侧的。这样一来，水能存多高就只取决于本侧的最大高度了。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;div class=&quot;image-size-50&quot;&gt;&lt;img src=&quot;/2020/04/trapping-rain-water/img1.png&quot; title=&quot;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="双指针" scheme="https://blog.pcninja.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1162. 地图分析</title>
    <link href="https://blog.pcninja.cn/2020/03/as-far-from-land-as-possible/"/>
    <id>https://blog.pcninja.cn/2020/03/as-far-from-land-as-possible/</id>
    <published>2020-03-29T10:01:01.000Z</published>
    <updated>2020-04-08T10:31:41.626Z</updated>
    
    <content type="html"><![CDATA[<p>你现在手里有一份大小为 N x N 的地图（网格）<code>grid</code>，上面的每个区域（单元格）都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。<br>我们这里说的距离是「曼哈顿距离」：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个区域之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。<br>如果我们的地图上只有陆地或者海洋，请返回 <code>-1</code>。<br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1,0,1],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释：海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1,0,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">输出：4</span><br><span class="line">解释：海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>多源BFS。先把所有 <code>1</code>（陆地）入队，每次循环把队首上下左右四个方向的海洋入队。为了防止重复搜索，把搜到的海洋标记为 <code>1</code>。最后一个出队的一定是离陆地最远的。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span> **grid, <span class="keyword">int</span> gridSize, <span class="keyword">int</span> *gridColSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">10000</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, x, y;</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; gridSize; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; gridSize; ++j)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">0</span>] = i;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">1</span>] = j;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">                rear++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(!rear || rear == gridSize*gridSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(rear &gt; front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">queue</span>[front][<span class="number">0</span>] + direction[i][<span class="number">0</span>];</span><br><span class="line">            y = <span class="built_in">queue</span>[front][<span class="number">1</span>] + direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; gridSize &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; gridSize &amp;&amp; !grid[x][y])</span><br><span class="line">            &#123;</span><br><span class="line">                grid[x][y] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">0</span>] = x;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">1</span>] = y;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">2</span>] = <span class="built_in">queue</span>[front][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">                rear++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>[front<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种解法的时间复杂度和空间复杂度显然都是 O(n<sup>2</sup>)。</p><div class="image-size-50"><img src="/2020/03/as-far-from-land-as-possible/image.png" title="双百解法"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你现在手里有一份大小为 N x N 的地图（网格）&lt;code&gt;grid&lt;/code&gt;，上面的每个区域（单元格）都用 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 标记好了。其中 &lt;code&gt;0&lt;/code&gt; 代表海洋，&lt;code&gt;1&lt;/code&gt; 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。&lt;br&gt;我们这里说的距离是「曼哈顿距离」：&lt;code&gt;(x0, y0)&lt;/code&gt; 和 &lt;code&gt;(x1, y1)&lt;/code&gt; 这两个区域之间的距离是 &lt;code&gt;|x0 - x1| + |y0 - y1|&lt;/code&gt; 。&lt;br&gt;如果我们的地图上只有陆地或者海洋，请返回 &lt;code&gt;-1&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://blog.pcninja.cn/tags/BFS/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 365. 水壶问题</title>
    <link href="https://blog.pcninja.cn/2020/03/water-and-jug-problem/"/>
    <id>https://blog.pcninja.cn/2020/03/water-and-jug-problem/</id>
    <published>2020-03-22T06:50:25.000Z</published>
    <updated>2020-03-22T08:20:16.746Z</updated>
    
    <content type="html"><![CDATA[<p>有两个容量分别为 <code>x</code> 升 和 <code>y</code> 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <code>z</code> 升的水？<br>如果可以，最后必须用以上水壶中的一或两个来盛放取得的 <code>z</code> 升水。<br>允许做以下操作：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><a id="more"></a><p><strong>示例 1:</strong>（出自电影《虎胆龙威》）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>操作方法：先把A壶加满，倒入B壶，再把A壶加满，倒入B壶，此时A、B各有1升和5升水。倒光B壶，把A壶中的1升水倒入B壶，加满A壶，倒入B壶，此时B壶即有4升水。</p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>&emsp;&emsp;如果从纯算法角度来考虑该问题，那么 DFS 或者 BFS 都可以。以 <code>(A壶水量, B壶水量)</code> 作为状态去搜索。每个状态需要搜下面这 6 种情况：</p><ul><li>装满A壶</li><li>装满B壶</li><li>清空A壶</li><li>清空B壶</li><li>从A壶向B壶倒水，直到装满或者倒空</li><li>从B壶向A壶倒水，直到装满或者倒空</li></ul><p>&emsp;&emsp;为了防止无限递归，需要建立一个 HashSet 来存储已经搜索过的状态，保证每个状态最多只被搜到一次。由于搜索深度很深，递归实现容易爆栈，所以可以用栈（队列）实现 DFS（BFS）。<br>&emsp;&emsp;无论 DFS 还是 BFS，因为最多有 $(x+1)(y+1)$ 种状态，所以时间复杂度和空间复杂度都是 $O(xy)$。反正我写的 DFS 在 LeetCode 上 TLE 了😩</p><div class="image-size-50"><img src="/2020/03/water-and-jug-problem/img1.png" title="TLE"></div><p>&emsp;&emsp;然而此题有个绝妙的数学解法，可秒杀 DFS/BFS：<br>&emsp;&emsp;我们首先需要明确，在初始状态下，两个水壶中水的总量是 0，之后，不管我们做六种操作的哪一种，都只会使水的总量 <code>增加x</code> 或 <code>增加y</code> 或 <code>减少x</code> 或 <code>减少y</code>。注意，两个水壶不会同时半满，所以如果我们把半满的水壶倒空或接满，虽然水的总量的变化量不是 <code>x</code> 或 <code>y</code>，但是这么操作之后就又回到了 <code>一个空一个满</code> 或 <code>两个空</code> 或 <code>两个满</code> 的状态，所以把半满的水壶倒空或接满这类操作是无意义的。<br>&emsp;&emsp;所以，水的总量的变化量一定是 <code>x</code> 或 <code>y</code>，由此我们可以得知水的总量永远等于 $ax+by$，其中$a,b\in Z$。这样一来，获取 <code>z</code> 升水的充要条件就是 $z\leq x+y$ 并且方程 $ax+by=z$ 有整数解。<br>&emsp;&emsp;由贝祖定理（或称裴蜀定理）可知，$ax+by=z$ 有解当且仅当 $z$ 是 $x, y$ 的最大公约数的倍数。所以此题数学解法的代码如下：</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>   <span class="comment">// 求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a%b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(z &gt; x + y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这种解法的时间复杂度等于辗转相除法求最大公约数的时间复杂度，即 $O(\log(\min \lbrace x, y\rbrace ))$，空间复杂度为 $O(1)$。</p><div class="image-size-50"><img src="/2020/03/water-and-jug-problem/img2.png" title="双百解法"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个容量分别为 &lt;code&gt;x&lt;/code&gt; 升 和 &lt;code&gt;y&lt;/code&gt; 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;code&gt;z&lt;/code&gt; 升的水？&lt;br&gt;如果可以，最后必须用以上水壶中的一或两个来盛放取得的 &lt;code&gt;z&lt;/code&gt; 升水。&lt;br&gt;允许做以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="数学" scheme="https://blog.pcninja.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="贝祖定理" scheme="https://blog.pcninja.cn/tags/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 695. 岛屿的最大面积</title>
    <link href="https://blog.pcninja.cn/2020/03/max-area-of-island/"/>
    <id>https://blog.pcninja.cn/2020/03/max-area-of-island/</id>
    <published>2020-03-15T13:27:29.000Z</published>
    <updated>2020-04-23T09:42:56.008Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含了一些 0 和 1 的非空二维数组 <code>grid</code> , 一个 <strong>岛屿</strong> 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。<br>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code>0</code>)<br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure></p><p>对于上面这个给定矩阵应返回 <code>6</code>。注意答案不应该是 <code>11</code>，因为岛屿只能包含水平或垂直的四个方向的 1。</p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure></p><p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p><p><strong>注意:</strong> 给定的矩阵 <code>grid</code> 的长度和宽度都不超过 50。</p><p><strong>题解:</strong><br>遍历二维数组，遇到 1 的时候就 DFS 深搜找出这个岛屿的面积，同时把经过的 1 都置为 0，避免重复搜索。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>** grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j])</span><br><span class="line">        ans += dfs(grid, m, n, i<span class="number">-1</span>, j);</span><br><span class="line">    <span class="keyword">if</span>(j<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>])</span><br><span class="line">        ans += dfs(grid, m, n, i, j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &lt; m &amp;&amp; grid[i+<span class="number">1</span>][j])</span><br><span class="line">        ans += dfs(grid, m, n, i+<span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; grid[i][j+<span class="number">1</span>])</span><br><span class="line">        ans += dfs(grid, m, n, i, j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面 gridSize 是行数，*gridColSize 是列数（不知道 LeetCode 为什么这么给参数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>** grid, <span class="keyword">int</span> gridSize, <span class="keyword">int</span>* gridColSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gridSize; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *gridColSize; ++j)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">                maxArea = max(maxArea, dfs(grid, gridSize, *gridColSize, i, j));</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h3><p>今天才发现 LeetCode 的「每日 1 题」打卡刷题活动，其实从三月一号就开始了。今天第一天做就碰上这道水题😁。</p><div class="image-size-50"><img src="/2020/03/max-area-of-island/image.png"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 &lt;code&gt;grid&lt;/code&gt; , 一个 &lt;strong&gt;岛屿&lt;/strong&gt; 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。&lt;br&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 &lt;code&gt;0&lt;/code&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://blog.pcninja.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NumPy 学习笔记</title>
    <link href="https://blog.pcninja.cn/2020/02/NumPy-learning-notes/"/>
    <id>https://blog.pcninja.cn/2020/02/NumPy-learning-notes/</id>
    <published>2020-02-21T07:21:31.000Z</published>
    <updated>2020-02-21T07:50:20.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 Jupyter Notebook 笔记转 Markdown，原 <code>.ipynb</code> 文件可点击<a href="/2020/02/NumPy-learning-notes/learn_numpy.ipynb" title="此处">此处</a>下载</p></blockquote><p>关于 Python 和 NumPy 的使用可以参考斯坦福大学<code>CS231n</code>的教程：<a href="https://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">https://cs231n.github.io/python-numpy-tutorial/</a>。</p><p>Numpy 是 Python 中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。</p><p>要想使用 NumPy，我们首先需要引入<code>numpy</code>包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>NumPy 数组是所有相同类型的值的网格，并由非负整数元组索引。维数是数组的<em>秩</em>；数组的<em>形状</em>是一个整数元组，给出沿每个维度的数组大小。</p><p>我们可以通过嵌套的 Python 列表初始化 NumPy 数组，并使用方括号访问元素：<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 创建一个秩为1的数组</span></span><br><span class="line">print(type(a))</span><br><span class="line">print(a.shape)</span><br><span class="line">print(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                 <span class="comment"># 改变数组中的一个元素</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;(3,)1 2 3[5 2 3]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  <span class="comment"># 创建一个秩为2的数组</span></span><br><span class="line">print(b)</span><br><span class="line">print(b.shape)</span><br><span class="line">print(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[[1 2 3] [4 5 6]](2, 3)1 2 4</code></pre><p>NumPy 也提供许多创建数组的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">2</span>, <span class="number">2</span>))  <span class="comment"># 创建一个全零数组</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>[[0. 0.] [0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.ones((<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 创建一个全1数组</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>[[1. 1.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.full((<span class="number">2</span>, <span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># 创建一个常量数组</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><pre><code>[[7 7] [7 7]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = np.eye(<span class="number">2</span>)  <span class="comment"># 创建一个2x2的单位矩阵</span></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><pre><code>[[1. 0.] [0. 1.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = np.random.random((<span class="number">2</span>, <span class="number">2</span>))  <span class="comment"># 创建一个填充随机数的数组</span></span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><pre><code>[[0.23316062 0.89221292] [0.15442143 0.18416244]]</code></pre><p>更多创建数组的方法请见<a href="https://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>NumPy 提供了几种索引数组的方式。</p><p><strong>切片：</strong>类似于 Python 的列表，NumPy 数组可以被切片。由于数组可能是多维的，因此必须为数组的每个维度指定一个切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建这样一个秩为2、形状为(3, 4)的数组</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片来提取由前2行，列号为1、2组成的子数组</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>[[2 3] [6 7]]</code></pre><p>数组的一个切片是对于同一数据的一个视图，因此修改它将修改原数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>    <span class="comment"># b[0, 0]与a[0, 1]是同一条数据</span></span><br><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>277</code></pre><p>你也可以将整数索引与切片索引混合使用。但是，这样做将产生比原始数组的秩低的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建这样一个秩为2、形状为(3, 4)的数组</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]</code></pre><p>两种访问数组中间行数据的方式。将整数索引与切片混合使用会产生一个较低秩的数组，而仅使用切片会产生一个与原始数组等秩的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># a的第二行的秩为1的视图</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># a的第二行的秩为2的视图</span></span><br><span class="line">row_r3 = a[[<span class="number">1</span>], :]  <span class="comment"># a的第二行的秩为2的视图</span></span><br><span class="line">print(row_r1, row_r1.shape)</span><br><span class="line">print(row_r2, row_r2.shape)</span><br><span class="line">print(row_r3, row_r3.shape)</span><br></pre></td></tr></table></figure><pre><code>[5 6 7 8] (4,)[[5 6 7 8]] (1, 4)[[5 6 7 8]] (1, 4)</code></pre><p>在访问数组的列时，我们可以进行相同的区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">print(col_r1, col_r1.shape)</span><br><span class="line">print(col_r2, col_r2.shape)</span><br></pre></td></tr></table></figure><pre><code>[ 2  6 10] (3,)[[ 2] [ 6] [10]] (3, 1)</code></pre><p><strong>整数数组索引：</strong>当使用切片对 NumPy 数组进行索引时，生成的数组视图将始终是原始数组的子数组。相反，整数数组索引允许你使用另一个数组中的数据构造任意数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数数组索引的一个例子</span></span><br><span class="line"><span class="comment"># 返回的数组将是(3,)形状的</span></span><br><span class="line">print(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的整数数组索引的例子与这个等价：</span></span><br><span class="line">print(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))</span><br></pre></td></tr></table></figure><pre><code>[1 4 5][1 4 5]</code></pre><p>使用整数数组索引时，可以重复使用源数组中的相同元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">print(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))</span><br></pre></td></tr></table></figure><pre><code>[2 2][2 2]</code></pre><p>整数数组索引的一个有用技巧是从矩阵的每一行中选择或更改一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新数组，从中选择元素</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引数组</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用b中的索引从a的每行中选择一个元素</span></span><br><span class="line">print(a[np.arange(<span class="number">4</span>), b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用b中的索引对a的每行中的一个元素进行改变</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]][ 1  6  7 11][[11  2  3] [ 4  5 16] [17  8  9] [10 21 12]]</code></pre><p><strong>布尔数组索引：</strong>布尔数组索引使您可以挑选出数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)  <span class="comment"># 找出大于2的元素；</span></span><br><span class="line">                    <span class="comment"># 这将返回一个与a形状相同的numpy布尔数组，</span></span><br><span class="line">                    <span class="comment"># 其中bool_idx的每个位置代表a中对应元素是否大于2。</span></span><br><span class="line"></span><br><span class="line">print(bool_idx)</span><br></pre></td></tr></table></figure><pre><code>[[False False] [ True  True] [ True  True]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们使用布尔数组索引来构建一个秩为1的数组，</span></span><br><span class="line"><span class="comment"># 该数组由bool_idx中值为True的对应元素组成</span></span><br><span class="line">print(a[bool_idx])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用一个简洁的语句完成上述操作：</span></span><br><span class="line">print(a[a &gt; <span class="number">2</span>])</span><br></pre></td></tr></table></figure><pre><code>[3 4 5 6][3 4 5 6]</code></pre><p>更多关于 NumPy 数组索引的信息请见<a href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个 NumPy 数组都是相同类型的元素的网格。NumPy 提供了大量可用于构造数组的数据类型。在创建数组时，NumPy 会尝试猜测一个数据类型，但是构造数组的函数通常还包含一个可选参数来明确指定数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 让NumPy选择数据类型</span></span><br><span class="line">print(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])  <span class="comment"># 让NumPy选择数据类型</span></span><br><span class="line">print(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)  <span class="comment"># 强制数据类型</span></span><br><span class="line">print(x.dtype)</span><br></pre></td></tr></table></figure><pre><code>int32float64int64</code></pre><p>更多关于 NumPy 数据类型的信息请见<a href="https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>基本数学函数在数组上逐元素进行操作，并且可用作运算符重载和 NumPy 模块中的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐元素求和；都产生数组</span></span><br><span class="line">print(x + y)</span><br><span class="line">print(np.add(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[ 6.  8.] [10. 12.]][[ 6.  8.] [10. 12.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素求差；都产生数组</span></span><br><span class="line">print(x - y)</span><br><span class="line">print(np.subtract(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[-4. -4.] [-4. -4.]][[-4. -4.] [-4. -4.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素相乘；都产生数组</span></span><br><span class="line">print(x * y)</span><br><span class="line">print(np.multiply(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[ 5. 12.] [21. 32.]][[ 5. 12.] [21. 32.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素相除；都产生数组</span></span><br><span class="line">print(x / y)</span><br><span class="line">print(np.divide(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[0.2        0.33333333] [0.42857143 0.5       ]][[0.2        0.33333333] [0.42857143 0.5       ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素求平方根；产生数组</span></span><br><span class="line">print(np.sqrt(x))</span><br></pre></td></tr></table></figure><pre><code>[[1.         1.41421356] [1.73205081 2.        ]]</code></pre><p>注意，<code>*</code>是逐元素相乘，不是矩阵乘法。取而代之，用<code>dot</code>函数计算向量的内积、向量与矩阵的乘积以及矩阵与矩阵的乘积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量的内积；都是219</span></span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v, w))</span><br></pre></td></tr></table></figure><pre><code>219219</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵/向量乘积；都产生秩为1的数组[29 67]</span></span><br><span class="line">print(x.dot(v))</span><br><span class="line">print(np.dot(x, v))</span><br></pre></td></tr></table></figure><pre><code>[29 67][29 67]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵/矩阵乘积；都产生秩为2的数组</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line">print(x.dot(y))</span><br><span class="line">print(np.dot(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[19 22] [43 50]][[19 22] [43 50]]</code></pre><p>NumPy 提供了许多有用的函数来对数组执行计算。最有用的之一是<code>sum</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  <span class="comment"># 计算所有元素之和</span></span><br><span class="line">print(np.sum(x, axis=<span class="number">0</span>))  <span class="comment"># 计算每一列之和</span></span><br><span class="line">print(np.sum(x, axis=<span class="number">1</span>))  <span class="comment"># 计算每一行之和</span></span><br></pre></td></tr></table></figure><pre><code>10[4 6][3 7]</code></pre><p>NumPy 提供的数学函数的完整列表请见<a href="https://docs.scipy.org/doc/numpy/reference/routines.math.html" target="_blank" rel="noopener">官方文档</a>。</p><p>除了用数组计算数学函数外，我们经常需要整形或以其他方式处理数组中的数据。此类操作的最简单的例子是转置矩阵；要转置矩阵，只需使用数组对象的<code>T</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(x.T)</span><br></pre></td></tr></table></figure><pre><code>[[1 2] [3 4]][[1 3] [2 4]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，对秩为1的数组求转置不会有任何变化：</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(v)</span><br><span class="line">print(v.T)</span><br></pre></td></tr></table></figure><pre><code>[1 2 3][1 2 3]</code></pre><p>NumPy 提供了许多操作数组的函数，完整列表请见<a href="https://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播是一种强大的机制，允许 NumPy 在执行算术运算时处理不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，并且我们想多次使用较小的数组对较大的数组执行某些操作。</p><p>例如，假设我们要向矩阵的每一行添加一个常向量。我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们将向量v加到矩阵x的每一行，</span></span><br><span class="line"><span class="comment"># 并将结果存储在矩阵y中</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># 创建一个与x形状相同的空矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过显式循环将向量v加到矩阵x的每一行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  2  4] [ 5  5  7] [ 8  8 10] [11 11 13]]</code></pre><p>这是可行的；但是当矩阵<code>x</code>非常大时，在 Python 中计算显式循环可能会很慢。注意，将向量<code>v</code>加到矩阵<code>x</code>的每一行相当于：垂直堆叠<code>v</code>的多个副本形成矩阵<code>vv</code>，然后执行<code>x</code>和<code>vv</code>的逐元素求和。我们可以这样实现这种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># 将v的4个副本堆叠在一起</span></span><br><span class="line">print(vv)</span><br></pre></td></tr></table></figure><pre><code>[[1 0 1] [1 0 1] [1 0 1] [1 0 1]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x + vv  <span class="comment"># x和vv逐元素相加</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  2  4] [ 5  5  7] [ 8  8 10] [11 11 13]]</code></pre><p>NumPy 广播使我们无需实际创建多个v的副本即可执行此计算。考虑使用广播的这个版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们将向量v加到矩阵x的每一行，</span></span><br><span class="line"><span class="comment"># 并将结果存储在矩阵y中</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># 通过广播将v加到x的每一行</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  2  4] [ 5  5  7] [ 8  8 10] [11 11 13]]</code></pre><p>即使<code>x</code>的形状是<code>(4, 3)</code>而<code>v</code>的形状是<code>(3,)</code>，但由于广播，<code>y = x + v</code>这一行仍然可以工作；这一行的工作方式就好像v实际具有<code>(4, 3)</code>的形状，其中每一行都是<code>v</code>的一个副本，并且求和是逐元素进行的。</p><p>将两个阵列广播到一起遵循以下规则：</p><ol><li>如果几个数组的秩不同，则在低秩数组的形状前面加1补齐，直到二者的形状具有相同的长度；</li><li>如果两个数组在某个维度上的大小相同，或者其中一个数组在该维度上的大小为1，则称这两个数组该维度上<em>兼容</em>；</li><li>如果几个数组在所有维度上都兼容，则它们可以广播到一起；</li><li>广播后的数组形状等于输入数组的形状在各个维度上的最大值；</li><li>在任一维度中，如果一个数组的大小为1而另一个数组的大小大于1，则第一个数组的行为就像是沿着该维度复制的一样。</li></ol><p>如果上述解释难以理解，可以尝试阅读<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">官方文档</a>中的解释或<a href="https://docs.scipy.org/doc/numpy/user/theory.broadcasting.html" target="_blank" rel="noopener">这篇解释</a>。</p><p>支持广播的函数称为通用函数。所有通用功能的列表请见<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs" target="_blank" rel="noopener">官方文档</a>。</p><p>以下是广播的一些应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算向量的张量积：</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># v具有形状(3,)</span></span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    <span class="comment"># w具有形状(2,)</span></span><br><span class="line"><span class="comment"># 为了计算外积，我们首先将v整形为形状为(3, 1)的列向量；</span></span><br><span class="line"><span class="comment"># 然后我们可以把它广播到w上，以产生形状(3, 2)的输出，</span></span><br><span class="line"><span class="comment"># 即v和w的外积：</span></span><br><span class="line">print(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br></pre></td></tr></table></figure><pre><code>[[ 4  5] [ 8 10] [12 15]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将向量加到矩阵的每一行：</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># x具有形状(2, 3)而v具有形状(3,)，因此它们广播到(2, 3)</span></span><br><span class="line">print(x + v)</span><br></pre></td></tr></table></figure><pre><code>[[2 4 6] [5 7 9]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将向量加到矩阵的每一列：</span></span><br><span class="line"><span class="comment"># x具有形状(2, 3)而w具有形状(2,)。</span></span><br><span class="line"><span class="comment"># 如果我们对x求转置，则它具有形状(3, 2)，</span></span><br><span class="line"><span class="comment"># 并且可以对w进行广播以产生形状(3, 2)的结果；</span></span><br><span class="line"><span class="comment"># 转置此结果将得出形状(2, 3)的最终结果，</span></span><br><span class="line"><span class="comment"># 即将向量w加到矩阵x的每一列的矩阵。</span></span><br><span class="line">print((x.T + w).T)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种解决方案是将w整形为(2, 1)的列向量；</span></span><br><span class="line"><span class="comment"># 然后我们可以直接对x广播它以产生相同的输出。</span></span><br><span class="line">print(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><pre><code>[[ 5  6  7] [ 9 10 11]][[ 5  6  7] [ 9 10 11]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘以常数：</span></span><br><span class="line"><span class="comment"># x具有形状(2, 3)。NumPy将标量视为形状为()的数组；</span></span><br><span class="line"><span class="comment"># 它们可以广播到一起，生成形状为(2, 3)的数组。</span></span><br><span class="line">print(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  4  6] [ 8 10 12]]</code></pre><p>广播通常会使您的代码更简洁，更快捷，因此，您应尽可能使用它。</p><h2 id="NumPy-文档"><a href="#NumPy-文档" class="headerlink" title="NumPy 文档"></a>NumPy 文档</h2><p>上文中简短的描述涉及到了您需要了解的有关 NumPy 的许多重要知识，但还远远不够。查看<a href="https://docs.scipy.org/doc/numpy/reference/" target="_blank" rel="noopener">NumPy参考</a>以了解更多关于 NumPy 的信息。</p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p><a href="https://matplotlib.org/" target="_blank" rel="noopener">Matplotlib</a> 是一个绘图库。在本节中将简要介绍<code>matplotlib.pyplot</code>模块，该模块提供了类似于 MATLAB 的绘图系统。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>通过运行这个特殊的 iPython 命令，我们将内联显示绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>Matplotlib 中最重要的函数是<code>plot</code>，它允许您绘制2D数据。这是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算正弦曲线上的点的x和y坐标</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Matplotlib绘制这些点</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()  <span class="comment"># 必须调用plt.show()才能显示图形</span></span><br></pre></td></tr></table></figure><img src="/2020/02/NumPy-learning-notes/1.png"><p>仅需一点点额外的工作，我们就可以轻松地一次绘制多条线，并添加标题、图例和轴标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Matplotlib绘制这些点</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(<span class="string">'x axis label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y axis label'</span>)</span><br><span class="line">plt.title(<span class="string">'Sine and Cosine'</span>)</span><br><span class="line">plt.legend([<span class="string">'Sine'</span>, <span class="string">'Cosine'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/2020/02/NumPy-learning-notes/2.png"><p>您可以在<a href="https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot" target="_blank" rel="noopener">官方文档</a>中阅读有关<code>plot</code>函数的更多信息。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>可以使用<code>subplot</code>函数在同一图中绘制不同的内容。下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算正弦和余弦曲线上的点的x和y坐标</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立高度为2、宽度为1的子图网格，</span></span><br><span class="line"><span class="comment"># 并将第一个子图设置为活动状态</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制第一个图</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(<span class="string">'Sine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第二个子图设置为活动状态，并绘制第二个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(<span class="string">'Cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示该图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/2020/02/NumPy-learning-notes/3.png"><p>您可以在<a href="https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot" target="_blank" rel="noopener">官方文档</a>中阅读有关<code>subplot</code>函数的更多信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为 Jupyter Notebook 笔记转 Markdown，原 &lt;code&gt;.ipynb&lt;/code&gt; 文件可点击&lt;a href=&quot;/2020/02/NumPy-learning-notes/learn_numpy.ipynb&quot; title=&quot;此处&quot;&gt;此处&lt;/a&gt;下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 Python 和 NumPy 的使用可以参考斯坦福大学&lt;code&gt;CS231n&lt;/code&gt;的教程：&lt;a href=&quot;https://cs231n.github.io/python-numpy-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cs231n.github.io/python-numpy-tutorial/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Numpy 是 Python 中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。&lt;/p&gt;
&lt;p&gt;要想使用 NumPy，我们首先需要引入&lt;code&gt;numpy&lt;/code&gt;包：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;NumPy 数组是所有相同类型的值的网格，并由非负整数元组索引。维数是数组的&lt;em&gt;秩&lt;/em&gt;；数组的&lt;em&gt;形状&lt;/em&gt;是一个整数元组，给出沿每个维度的数组大小。&lt;/p&gt;
&lt;p&gt;我们可以通过嵌套的 Python 列表初始化 NumPy 数组，并使用方括号访问元素：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://blog.pcninja.cn/tags/Python/"/>
    
      <category term="NumPy" scheme="https://blog.pcninja.cn/tags/NumPy/"/>
    
      <category term="Matplotlib" scheme="https://blog.pcninja.cn/tags/Matplotlib/"/>
    
      <category term="科学计算" scheme="https://blog.pcninja.cn/tags/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>几种外积的概念辨析</title>
    <link href="https://blog.pcninja.cn/2020/02/discrimination-of-several-outer-products/"/>
    <id>https://blog.pcninja.cn/2020/02/discrimination-of-several-outer-products/</id>
    <published>2020-02-13T08:09:04.000Z</published>
    <updated>2020-02-20T10:41:19.033Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在学习 PyTorch 的时候，看到文档中计算两个向量的“outer product”后得到一个矩阵。我刚开始理所当然地把“outer product”理解为高中所学的外积，即叉积。但我越想越不对劲：两个向量的叉积不应该还是向量吗，怎么会叉出矩阵来呢？查了一波资料后发现这里的“outer product”不是叉积，而是张量积。<br>&emsp;&emsp;中文里的<strong>外积</strong>一词常出现在代数、几何学等领域中。对两向量 $\vec{A}$ 与 $\vec{B}$ 而言，外积可指：</p><ul><li style="overflow: visible;"><strong>叉积</strong>（Cross product），又称<strong>向量积</strong>（Vector product），常写为 $\vec{A}\times\vec{B}$；</li><li style="overflow: visible;"><strong>楔积</strong>（Wedge product 或 Exterior product），常写为 $\vec{A}\wedge\vec{B}$；</li><li style="overflow: visible;"><strong>张量积</strong>（Tensor product 或 Outer product），常写为 $\vec{A}\otimes\vec{B}$。</li></ul><p>&emsp;&emsp;上述三种都可称作外积，但含义却大相径庭，因此极易出现混淆，尤其是“exterior”和“outer”都有外面的意思，我发现网上许多文章甚至一些教科书中都出现了翻译、解释上的错误。我认为避免混淆的最好办法就是使用“叉积”、“向量积”、“楔积”、“张量积”这些没有歧义的词语，而避免使用“外积”一词。<br>&emsp;&emsp;下面是对几种外积概念的简要辨析。<br><a id="more"></a></p><h3 id="一、叉积"><a href="#一、叉积" class="headerlink" title="一、叉积"></a>一、叉积</h3><p>&emsp;&emsp;两个向量 $\vec{a}$ 和 $\vec{b}$ 的叉积仅在三维空间中有定义，写作 $\vec{a}\times\vec{b}$。在物理学中，叉积有时也被写成 $\vec{a}\wedge\vec{b}$，但在数学中 $\vec{a}\wedge\vec{b}$ 是外代数中的外积（楔积）。<br>&emsp;&emsp;叉积可以定义为：</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = |\vec{a}||\vec{b}|\sin{\theta}\ \vec{n}</script><p>其中 $\sin{\theta}$ 表示 $\vec{a}$ 和 $\vec{b}$ 在它们所定义的平面上的夹角（$0^{\circ}\leq\theta\leq180^{\circ}$）。$|\vec{a}|$ 和 $|\vec{b}|$ 是向量 $\vec{a}$ 和 $\vec{b}$ 的模长，而 $\vec{n}$ 则是一个与 $\vec{a}$、$\vec{b}$ 所构成的平面垂直的单位向量，方向由右手定则决定。</p><div class="image-size-30"><img src="/2020/02/discrimination-of-several-outer-products/1.png" title="在右手坐标系中的向量积"></div><p>&emsp;&emsp;叉积可以表达为这样的行列式：</p><script type="math/tex; mode=display">\vec{u}\times\vec{v} = \begin{vmatrix}\vec{i}&\vec{j}&\vec{k}\\u_{1}&u_{2}&u_{3}\\v_{1}&v_{2}&v_{3}\end{vmatrix}</script><p>&emsp;&emsp;沿第一行进行拉普拉斯展开可得：</p><script type="math/tex; mode=display">\begin{aligned}\vec{u}\times\vec{v} &= \begin{vmatrix}u_{2}&u_{3}\\v_{2}&v_{3}\end{vmatrix}\vec{i} + \begin{vmatrix}u_{1}&u_{3}\\v_{1}&v_{3}\end{vmatrix}\vec{j} + \begin{vmatrix}u_{1}&u_{2}\\v_{1}&v_{2}\end{vmatrix}\vec{k}\\&= (u_{2}v_{3}-u_{3}v_{2})\vec{i} - (u_{1}v_{3}-u_{3}v_{1})\vec{j} + (u_{1}v_{2}-u_{2}v_{1})\vec{k}\end{aligned}</script><h3 id="二、楔积"><a href="#二、楔积" class="headerlink" title="二、楔积"></a>二、楔积</h3><p>&emsp;&emsp;不了解，貌似是定义在张量空间上的一种运算。具体细节请移步维基百科<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">外代数（格拉斯曼代数）</a>词条，我反正看不懂。</p><h3 id="三、张量积"><a href="#三、张量积" class="headerlink" title="三、张量积"></a>三、张量积</h3><p>&emsp;&emsp;在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中,如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的：最一般的双线性运算。在某些上下文中也叫做外积。<br>&emsp;&emsp;向量的外积是矩阵的克罗内克积的特殊情况。<br>&emsp;&emsp;给定$m \times 1$列向量$\vec{u}$和$1 \times n$行向量$\vec{v}$，它们的外积$\vec{u} \otimes \vec{v}$被定义为$m \times n$矩阵$\mathbf{A}$，结果出自</p><script type="math/tex; mode=display">\vec{u} \otimes \vec{v} = \mathbf{A} = \vec{u}\ \vec{v}</script><p>这里的张量积就是向量的乘法。<br><strong>例子：</strong></p><script type="math/tex; mode=display">\vec{b} \otimes \vec{a} \rightarrow\begin{bmatrix}b_1 \\ b_2 \\ b_3 \\ b_4\end{bmatrix}  \begin{bmatrix}a_1 & a_2 & a_3\end{bmatrix} = \begin{bmatrix}a_1b_1 & a_2b_1 & a_3b_1 \\ a_1b_2 & a_2b_2 & a_3b_2 \\ a_1b_3 & a_2b_3 & a_3b_3 \\ a_1b_4 & a_2b_4 & a_3b_4\end{bmatrix}</script><p>&emsp;&emsp;结果的秩为1，结果的维数为 4×3 = 12。这里的秩指的是“张量秩”（所需指标数），而维数计算在结果数组(阵列)中自由度的数目。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近在学习 PyTorch 的时候，看到文档中计算两个向量的“outer product”后得到一个矩阵。我刚开始理所当然地把“outer product”理解为高中所学的外积，即叉积。但我越想越不对劲：两个向量的叉积不应该还是向量吗，怎么会叉出矩阵来呢？查了一波资料后发现这里的“outer product”不是叉积，而是张量积。&lt;br&gt;&amp;emsp;&amp;emsp;中文里的&lt;strong&gt;外积&lt;/strong&gt;一词常出现在代数、几何学等领域中。对两向量 $\vec{A}$ 与 $\vec{B}$ 而言，外积可指：&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;overflow: visible;&quot;&gt;&lt;strong&gt;叉积&lt;/strong&gt;（Cross product），又称&lt;strong&gt;向量积&lt;/strong&gt;（Vector product），常写为 $\vec{A}\times\vec{B}$；&lt;/li&gt;
&lt;li style=&quot;overflow: visible;&quot;&gt;&lt;strong&gt;楔积&lt;/strong&gt;（Wedge product 或 Exterior product），常写为 $\vec{A}\wedge\vec{B}$；&lt;/li&gt;
&lt;li style=&quot;overflow: visible;&quot;&gt;&lt;strong&gt;张量积&lt;/strong&gt;（Tensor product 或 Outer product），常写为 $\vec{A}\otimes\vec{B}$。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;上述三种都可称作外积，但含义却大相径庭，因此极易出现混淆，尤其是“exterior”和“outer”都有外面的意思，我发现网上许多文章甚至一些教科书中都出现了翻译、解释上的错误。我认为避免混淆的最好办法就是使用“叉积”、“向量积”、“楔积”、“张量积”这些没有歧义的词语，而避免使用“外积”一词。&lt;br&gt;&amp;emsp;&amp;emsp;下面是对几种外积概念的简要辨析。&lt;br&gt;
    
    </summary>
    
      <category term="学科" scheme="https://blog.pcninja.cn/categories/%E5%AD%A6%E7%A7%91/"/>
    
    
      <category term="数学" scheme="https://blog.pcninja.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="向量" scheme="https://blog.pcninja.cn/tags/%E5%90%91%E9%87%8F/"/>
    
      <category term="外积" scheme="https://blog.pcninja.cn/tags/%E5%A4%96%E7%A7%AF/"/>
    
      <category term="矩阵" scheme="https://blog.pcninja.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="线性代数" scheme="https://blog.pcninja.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="几何" scheme="https://blog.pcninja.cn/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>勇气的赞歌</title>
    <link href="https://blog.pcninja.cn/2020/02/the-paean-of-courage/"/>
    <id>https://blog.pcninja.cn/2020/02/the-paean-of-courage/</id>
    <published>2020-02-02T09:32:16.000Z</published>
    <updated>2020-04-21T06:17:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;截至2月2日24时，持续肆虐的2019-nCoV急性呼吸疾病已经确诊超过1.7万例，此外还有超过2.2万疑似病例和近19万密切接触者。自从疫情爆发以来，越来越多的恐慌、谣言、猜忌、不信任甚至谩骂充斥在社交网络。越是在这种政府公信力和民族凝聚力最脆弱的时候，故宫停车、人民日报带货、鄂A0260W、武汉红十字会阻拦央视记者一类的事件便越会被积怨已久的人们无限放大，并以此作为宣泄心中愤懑的对象。然而，当人们都沉浸在对丑恶的斥责中时，会不会忘记了世间仍然存在的美好，会不会忘记了此时此刻还有多少人在坚守自己的岗位。我想，赞美勇气，要远比抨击怯懦来得有意义。<br>&emsp;&emsp;刚刚看了回形针最新一期的视频<a href="https://www.bilibili.com/video/av86216616" target="_blank" rel="noopener">《关于新冠肺炎的一切》</a>，难能可贵的是，视频作者用客观的数据与文献资料向我们分析展示了关于此次疫情的真实信息。我在此对这些仍能保持冷静头脑的科普作者表示由衷的敬佩，并在下文引述视频中的一些内容，试图描绘此次疫情的大致轮廓。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/latest-animation.gif" title="2019-nCoV传播趋势（截至2月3日7时33分）"></div><a id="more"></a><blockquote><p>以下包含非原创内容</p></blockquote><h2 id="关于疫情的伊始"><a href="#关于疫情的伊始" class="headerlink" title="关于疫情的伊始"></a>关于疫情的伊始</h2><p>&emsp;&emsp;2019年12月8日，一位来自华南海鲜市场病人因为持续7天的发热、咳嗽和呼吸困难入院。5天后，他没有去过海鲜市场妻子也因为不明原因肺炎入院。<br>&emsp;&emsp;2020年1月1日，华南海鲜市场关闭。1月2日，41名新型肺炎患者被确诊。<br>&emsp;&emsp;此时喜迎新年的市民们还不知道，一场会感染上万人的瘟疫已经开始了。</p><h2 id="关于人传人"><a href="#关于人传人" class="headerlink" title="关于人传人"></a>关于人传人</h2><p>&emsp;&emsp;在1月24日发表于《柳叶刀》的论文《2019-nCoV感染患者的临床特征》（<a href="/2020/02/the-paean-of-courage/Clinical_features_of_patients_infected_with_2019_novel_coronavirus_in_Wuhan_China.pdf" title="下载">下载</a>）中，我们可以了解最早被确诊的 41 名患者的具体情况。<br>&emsp;&emsp;截至1月22日，41人中有28人出院，6人死亡。发烧和咳嗽是最常见的症状，从起病到呼吸困难，平均8天。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/1.png" title="2019-nCoV发病后时间线"></div><p>&emsp;&emsp;在肺炎初期，人传人的信号就已经很明显了，这41人中有14人都<strong>没有去过</strong>华南海鲜市场。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/2.png" title="14人无华南海鲜市场暴露史"></div><p>&emsp;&emsp;1月24日的另一篇论文《一场与2019年新型冠状病毒相关的家族肺炎表明了人与人之间的传播：家庭聚集研究》（<a href="/2020/02/the-paean-of-courage/A_familial_cluster_of_pneumonia_associated_with_the_2019_novel_coronavirus_indicating_person-to-person_transmission-_a_study_of_a_family_cluster.pdf" title="下载">下载</a>）研究了一个12月29前往在武汉旅行的深圳家庭。<br>&emsp;&emsp;最早出现症状的男士在到达武汉后的第4天开始发烧腹泻，之后3天，他的老婆岳父岳母和也都开始发烧咳嗽。1月5日，全家返回深圳，4天后，<strong>没有去过武汉</strong>的母亲开始全身乏力。最终，这个7口之家里，6人确诊新冠肺炎，包括他没有明显症状的儿子。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/3.png" title="深圳一家庭聚集传播案例"></div><p>&emsp;&emsp;1月30的论文《新型冠状病毒感染的肺炎在武汉的早期传播动态》（<a href="/2020/02/the-paean-of-courage/Early_Transmission_Dynamics_in_Wuhan_China_of_Novel_Coronavirus_Infected_Pneumonia.pdf" title="下载">下载</a>）进一步分析了武汉前425例确诊患者的数据。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/4.png" title="潜伏期分布"></div><p>&emsp;&emsp;这张表中，横坐标是从感染至发病的时间，纵坐标是相对概率。可以看到大部分感染者7天内就会发病，病毒的平均潜伏期是5.2天。<br>&emsp;&emsp;现在我们知道，在2020年1月11日之前确诊的295人里，<strong>只有45人去过华南海鲜市场，此外还有7名医护人员</strong>。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/5.png" title="多数患者与华南海鲜市场并无关联"></div><p>&emsp;&emsp;但在<strong>十天之后</strong>，人们才意识到要戴口罩了。</p><p><video src="/2020/02/the-paean-of-courage/video.mp4" width="500px" preload="preload" controls="controls"><br>您的浏览器不支持video标签。</video></p><p class="image-caption" style="padding-top: 15px;">1月20日晚，官方首次肯定人传人</p><h2 id="关于死亡率"><a href="#关于死亡率" class="headerlink" title="关于死亡率"></a>关于死亡率</h2><p>&emsp;&emsp;这是从1月16日到2月1日全中国累计确诊和死亡人数的增长曲线。如果我们用总死亡数除以总确诊数，可以得到一个2%左右的患病死亡率。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/6.png" title="确诊和死亡增长曲线（对数坐标）"></div><p>&emsp;&emsp;但这样的计算方式并不准确。根据前425名确诊患者的数据，我们可以知道病毒的平均潜伏期是5.2天，从发病到就诊平均是4.6天，就诊到入院平均4.5天，而入院到ICU是3.5天，假设从ICU到死亡是3天，整个过程就是21天左右。而如果就诊3天后就能确诊，那从确诊到死亡大概是8天。<br>&emsp;&emsp;所以，<strong>1月31号的死亡患者大概在1月23号确诊</strong>。如果我们用湖北省1月29日—1月31日这三天死亡的124人除以1月21日—1月23日确诊的279人的话，<strong>病死率高达44.4%</strong>。<br>&emsp;&emsp;但因为湖北省的医疗资源紧张确诊困难，很多老年病患发展到了重症才能确诊，病死率肯定偏高。相比之下，除湖北省外全国其他地区的数据更能反映真实情况。1月29日—1月31日，中国其他省份死亡患者共3人，除以1月21日—1月23日确诊的260人，病死率在1.1%左右，确实不高。<br>&emsp;&emsp;如果按照这个病死率倒推1月21日—1月23日的湖北感染者，那应该<strong>不是279人，而是10700人</strong>。<br>&emsp;&emsp;当然，这也只是一个非常粗糙的计算过程，样本量小，也不一定那么准确。但随着未来数据的完善，病死率的结果会越来越清晰。</p><h2 id="关于勇气"><a href="#关于勇气" class="headerlink" title="关于勇气"></a>关于勇气</h2><p>&emsp;&emsp;这场瘟疫让我们所有人精神紧张，但实际上，倒霉的事情每天都在发生。<br>&emsp;&emsp;过去几年，中国平均每年有8.8万人死于流感引发的呼吸系统疾病，6.3万人死于交通事故，3.8万人死于安全事故。只要我们迈出家门，去工地，去写字楼，去流水线，风险就已经存在了。<br>&emsp;&emsp;我们当然应该把倒霉的概率尽可能降低，<strong>但我们之所以赞颂勇气，是因为我们人类总是在明知风险的时候，仍然选择做我们该做的事情</strong>。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/7.jpeg" title="2019-nCoV电镜照片"></div><p>&emsp;&emsp;最后我们来看一眼这场肺炎的主角——这个直径在 0.1 微米左右的畸形圆球。可怕吗？我们已经知道了它的RNA序列、知道了它的感染机制、传播机制、临床表现和致死概率。其实也没那么吓人。<br>&emsp;&emsp;如果我们被这个吓到，吓到要锁死来自武汉的邻居，吓到要攻击陌生的求助者，吓到要<strong>以谣言的名义让大家不敢说话</strong>。那才是真的吓人。<br>&emsp;&emsp;<strong>人类的赞歌是勇气的赞歌</strong>，赞美所有还在认真工作的人们，希望新的一年，我们都能有更多勇气。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>&emsp;&emsp;惨象，已使我目不忍视了；流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵！不在沉默中爆发，就在沉默中灭亡。</p><p align="right">——鲁迅</p></blockquote><p>&emsp;&emsp;值得庆幸的是，我们的社会还没有到“不在沉默中爆发，就在沉默中灭亡”的地步。但是，在这次疫情中，人民的政府、人民的红十字会，或者说我们的政府、我们的红十字会，仿佛已然陷入了塔西佗陷阱的无尽深渊。<br>&emsp;&emsp;真正的人民政府不会允许官员全副武装却让医生手无寸铁，真正的红十字会也不会把人民的捐赠据为己有。人民永远是历史的创造者，当“人民政府”不再“人民”，当公权力开始丧失公信力之时，新的历史就会被人民书写。<br>&emsp;&emsp;五千年屹立不倒的中华民族不会消亡，会消亡的只有失信于民的政权。真诚希望如今这个延续了七十年的政权能够幡然悔悟，带领人民走向安宁与富足，不要再让我们回到鲁迅所处的那至暗时代了。<br>&emsp;&emsp;人类的赞歌是勇气的赞歌,人类的伟大是勇气的伟大。人们的勇气终将战胜疫情，希望这一天早日到来。最后，祝愿正笼罩在恐惧中的同胞幸福安康，向依然奋战在一线的医务工作者致以崇高的敬意。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;截至2月2日24时，持续肆虐的2019-nCoV急性呼吸疾病已经确诊超过1.7万例，此外还有超过2.2万疑似病例和近19万密切接触者。自从疫情爆发以来，越来越多的恐慌、谣言、猜忌、不信任甚至谩骂充斥在社交网络。越是在这种政府公信力和民族凝聚力最脆弱的时候，故宫停车、人民日报带货、鄂A0260W、武汉红十字会阻拦央视记者一类的事件便越会被积怨已久的人们无限放大，并以此作为宣泄心中愤懑的对象。然而，当人们都沉浸在对丑恶的斥责中时，会不会忘记了世间仍然存在的美好，会不会忘记了此时此刻还有多少人在坚守自己的岗位。我想，赞美勇气，要远比抨击怯懦来得有意义。&lt;br&gt;&amp;emsp;&amp;emsp;刚刚看了回形针最新一期的视频&lt;a href=&quot;https://www.bilibili.com/video/av86216616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《关于新冠肺炎的一切》&lt;/a&gt;，难能可贵的是，视频作者用客观的数据与文献资料向我们分析展示了关于此次疫情的真实信息。我在此对这些仍能保持冷静头脑的科普作者表示由衷的敬佩，并在下文引述视频中的一些内容，试图描绘此次疫情的大致轮廓。&lt;/p&gt;
&lt;div class=&quot;image-size-50&quot;&gt;&lt;img src=&quot;/2020/02/the-paean-of-courage/latest-animation.gif&quot; title=&quot;2019-nCoV传播趋势（截至2月3日7时33分）&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他" scheme="https://blog.pcninja.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="疫情" scheme="https://blog.pcninja.cn/tags/%E7%96%AB%E6%83%85/"/>
    
      <category term="死亡" scheme="https://blog.pcninja.cn/tags/%E6%AD%BB%E4%BA%A1/"/>
    
      <category term="勇气" scheme="https://blog.pcninja.cn/tags/%E5%8B%87%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>【备忘】 youtube-dl使用方法</title>
    <link href="https://blog.pcninja.cn/2020/02/usage-of-youtube-dl/"/>
    <id>https://blog.pcninja.cn/2020/02/usage-of-youtube-dl/</id>
    <published>2020-02-01T12:15:23.000Z</published>
    <updated>2020-02-01T13:29:05.869Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;youtube-dl是一个Python编写的开源的音视频下载工具，只支持命令行操作。虽然名为youtube-dl，但它支持的站点非常多，包括了诸多国内外知名的音视频网站（<a href="https://github.com/ytdl-org/youtube-dl/blob/master/docs/supportedsites.md" target="_blank" rel="noopener">查看完整的支持列表</a>）。由于指令较多，容易忘记，故将常用的指令记录在此，以备不时之需。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方GitHub仓库地址：<a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener">https://github.com/ytdl-org/youtube-dl</a><br>Windows下可以在releases页面找到最新发布版并直接下载<code>youtube-dl.exe</code>即可使用，更新方法如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl -U</span><br></pre></td></tr></table></figure></p><p>Linux下可以通过<code>pip</code>安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install youtube-dl           # 安装</span><br><span class="line">pip uninstall youtube-dl         # 卸载</span><br><span class="line">pip install --upgrade youtube-dl # 更新</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>完整的指令列表和参数说明请见GitHub仓库里的官方文档，这里只记录最常用到的音视频下载指令<br>由于众所周知的原因，大多数情况下都需要使用代理下载YouTube上的内容，因此下面所有指令都加上了<code>--proxy socks5://127.0.0.1:1080/</code>，即通过socks5协议的本地代理下载，记得挂上梯子并开启本地端口</p><ul><li>列出所有可用的音视频格式<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -F [url]</span><br></pre></td></tr></table></figure></li></ul><p><div class="image-size-50"><img src="/2020/02/usage-of-youtube-dl/image.png" title="可用列表"></div><br>可以看到程序列出了该资源每个可用项的格式码、扩展名以及说明，其中包括<code>audio only</code>和<code>video only</code></p><ul><li><p>通过指定格式码下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f [format code] [url]</span><br></pre></td></tr></table></figure></li><li><p>下载纯音频至指定格式（需ffmpeg）<br>需要保证ffmpeg在环境变量中或者与youtube-dl在同一目录才可正常转码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -x --audio-format mp3 [url]</span><br></pre></td></tr></table></figure></li></ul><p>该指令可以下载音频并通过ffmpeg转至mp3格式，仅保留<code>-x</code>参数可以不转格式</p><ul><li>下载最佳质量的音视频<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载最佳质量的音视频格式</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f best [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载最佳质量的仅视频格式</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestvideo [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载最佳质量的仅音频格式</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestaudio [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别下载最高质量的仅视频和最高质量的仅音频格式，再用ffmpeg合并成一个最佳质量的mkv文件</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestvideo+bestaudio [url]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;youtube-dl是一个Python编写的开源的音视频下载工具，只支持命令行操作。虽然名为youtube-dl，但它支持的站点非常多，包括了诸多国内外知名的音视频网站（&lt;a href=&quot;https://github.com/ytdl-org/youtube-dl/blob/master/docs/supportedsites.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;查看完整的支持列表&lt;/a&gt;）。由于指令较多，容易忘记，故将常用的指令记录在此，以备不时之需。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://blog.pcninja.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="下载" scheme="https://blog.pcninja.cn/tags/%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="工具" scheme="https://blog.pcninja.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="视频" scheme="https://blog.pcninja.cn/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="YouTube" scheme="https://blog.pcninja.cn/tags/YouTube/"/>
    
  </entry>
  
  <entry>
    <title>除夕夜小记</title>
    <link href="https://blog.pcninja.cn/2020/01/happy-chinese-new-year-2020/"/>
    <id>https://blog.pcninja.cn/2020/01/happy-chinese-new-year-2020/</id>
    <published>2020-01-24T15:00:11.000Z</published>
    <updated>2020-01-24T15:36:39.081Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;除夕夜，万家灯火，十四亿华人共同迎接庚子年的到来。<br><a id="more"></a><br>&emsp;&emsp;这个新年并不太平，刚一进入2020年，中华民族的儿女就历经了巨大挑战：</p><ul><li>1月11日，蔡英文以史无前例的得票数连任台湾地区领导人，两岸关系不知将何去何从</li><li>1月16日，中美第一阶段经贸协议的签署让中国蒙受巨大损失，为即将打响的科技战、金融战埋下巨大隐患</li><li>1月23日，武汉封城，却难以阻止2019-nCoV在全国范围内大规模爆发，无人知晓真实的感染情况，无人知晓最终会付出多大的代价……</li></ul><p>&emsp;&emsp;2020年，无论是国家命运，亦或是每一个国民的命运，都将注定不凡。真诚祝愿中华民族能够“风雨压不垮，苦难中开花”，继续屹立在世界东方。<br>&emsp;&emsp;<strong>天佑中华！</strong></p><p></p><p align="right">己亥年除夕于家中</p><p></p><div class="image-size-50"><img src="/2020/01/happy-chinese-new-year-2020/image.png" title="鼠年快乐"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;除夕夜，万家灯火，十四亿华人共同迎接庚子年的到来。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://blog.pcninja.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="https://blog.pcninja.cn/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="https://blog.pcninja.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="新年" scheme="https://blog.pcninja.cn/tags/%E6%96%B0%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>辩证法三大规律在生活中的体现</title>
    <link href="https://blog.pcninja.cn/2019/12/embodiment-of-three-laws-of-dialectics-in-life/"/>
    <id>https://blog.pcninja.cn/2019/12/embodiment-of-three-laws-of-dialectics-in-life/</id>
    <published>2019-12-22T15:33:59.000Z</published>
    <updated>2020-03-17T13:16:52.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二上学期《马克思主义基本原理概论》实践环节报告</p></blockquote><p>&emsp;&emsp;在本学期的《马克思主义基本原理概论》课堂上，我对辩证法及其三大规律即对立统一规律、量变质变规律和否定之否定规律有了系统的学习。为了对其有更为深刻的认识与理解，我尝试运用这三大规律来解释日常生活中的问题。以下我将分三个部分，分别阐述我在生活中对对立统一规律、量变质变规律和否定之否定规律的体会与感悟。<a id="more"></a><br><strong>一、生活中的对立统一规律</strong><br>&emsp;&emsp;对立统一规律作为唯物辩证法的实质和核心，在生活的各个角落都体现得淋漓尽致。例如平时我们在打篮球时，往往会遇到在攻守两端的体能分配问题：当我们在进攻端投入太多精力时，防守就会出现注意力不集中、漏人等情况；反之，若将重心放在防守上，那么进攻时就会出现体力不支、命中率下降的弊端。这告诉我们事物内部以及事物之间都包含着矛盾，即矛盾具有普遍性。<br>&emsp;&emsp;除此以外，攻与守互为对立面，二者相互排斥、相互分离，体现着矛盾的斗争性；而攻与守又相互依存，在比赛中处于一个矛盾统一体中，因而出现所谓“以攻代守”、“防守带动进攻”等战术思想，体现了矛盾的同一性。攻守这对矛盾的同一性与斗争性共同作用在事物的发展即比赛的进程上，矛盾的两个对立面由于同一性和斗争性而相互转化，只有当攻守这对矛盾平衡、协调时事物才展现出和谐状态，球队才可能取胜。<br>&emsp;&emsp;对立统一规律还体现在我们生病时吃药中，众所周知，大多数药物在帮助治疗疾病的同时，往往还伴随着或多或少的副作用，使我们出现不良反应。药物的正作用与副作用便构成了一对矛盾统一体。对立统一规律教导我们要把握主要矛盾和矛盾的主要方面，因此需要综合考量药物的治疗作用与副作用，判断其治疗作用带来的利与副作用带来的弊孰大孰小，当利大于弊时，医生或药师就会让我们服药，并且严格控制剂量以寻求矛盾的平衡。<br>&emsp;&emsp;在生活中，我们应该学会用对立统一的眼光看待每一件事物，发现其内在的矛盾，坚持“两点论”和“重点论”的统一，这样我们才会对我们所处的这个世界有更为透彻的认识。<br><strong>二、生活中的量变质变规律</strong><br>&emsp;&emsp;量变和质变是事物变化的两种基本状态和形式，它们间的相互作用、相互转化在日常生活中极其常见，举一个最简单的例子：用水杯接水，在杯子满之前，杯内水的体积连续增加，属于持续的量变，当杯满的瞬间，其状态就会发生质变，即水开始溢出。这个质变的过程标志着水杯的状态阶段的更替，即由接水阶段更替为溢水阶段，这就是为什么说量变质变规律指出了连续性与阶段性的统一。<br>&emsp;&emsp;除了接水，生活中处处体现着量变质变的规律。上学以来，许多老师都曾教导过我们要注重平时的积累，不论是英文单词的积累、诗词歌赋的积累，还是如今对代码量的积累，都是为了在相应领域的水平能够从量变到质变。<br>&emsp;&emsp;量变和质变的辩证关系告诉我们量变是质变的必要准备。诚然，如果没有对英文单词的大量积累，我们就不可能读懂英文前沿期刊上的长篇大论；如果没有对诗词歌赋的大量背诵，就不会有“腹有诗书气自华”的精神风骨；如果没有对各类数据结构与算法的大量代码书写，就不可能在大型项目工程中熟练地运用各种算法并有效率地写出优质代码。这些积累就好比摩天大楼的根基，它们的必要性不言而喻。<br>&emsp;&emsp;量变和质变的辩证关系还告诉我们质变是量变的必然结果。所以说，当一个人能够坚持一个好习惯足够长时间，这个好习惯最终注定会让他受益；同理，当一个人迟迟不肯改正他的坏习惯，那么这个坏习惯最终同样会给他烙上深深的烙印。因此量变质变规律教导我们，要坚持优良习惯，追求量变向质变的转化，同时要及时摒弃不良习惯，以防量变转向质变。<br><strong>三、生活中的否定之否定规律</strong><br>&emsp;&emsp;我们时常听到诸如“前途是光明的,道路是曲折的”一类的话语，其中就蕴含着否定之否定规律所揭示的事物发展的前进性与曲折性的统一。<br>&emsp;&emsp;提到一规律时，我想最为人熟知的就是由地心说到日心说到现代天文学的曲折发展历程，在此我不想赘述。作为计算机科学与技术专业的本科生，适逢本学期学习了《计算机组成原理》一课，我想用否定之否定规律对CPU控制器的演进历程做出解读：在早期计算机中，由于逻辑功能简单，电路并不复杂，因此多采用硬布线控制器的设计，这就是第一阶段——肯定阶段；随着人们对计算机的功能需求不断增多以及复杂指令集的出现，若沿用硬布线控制器，则电路将十分复杂，因此人们摒弃了难以实现的硬布线控制器，设计了牺牲效率但电路简单的微程序控制器，这是第二阶段——否定阶段；如今，芯片制造技术极其成熟，生产复杂的硬布线控制器已不再是难事，故追求极致效率的人们便否定了效率低下的微程序控制器，重新采用硬布线控制器，这便是第三阶段——否定之否定。由此可见CPU控制器的演化并不是一帆风顺的，而是不断对此前的缺陷进行否定，螺旋式上升，很好的体现了事物发展的前进性与曲折性。<br>&emsp;&emsp;其实，在我们的身边一样能找到类似的事情。比如，若我们闷头读书，只注重理论学习，那么在实践操作时我们就会束手无策，于是我们对此前的做法进行了否定，开始投入实践，尝试新鲜技术，减少理论学习；然而缺少了理论的支撑，我们对新生技术的原理就会感到茫然，无法透彻理解，因此我们需要进行否定之否定，做到理论与实践并重。<br>&emsp;&emsp;由此可见，辩证法的三大规律体现在我们日常生活中的方方面面，很多实际问题都可以运用这三大规律进行很好地解释。通过这段时间的实践，我逐渐感受到对立统一规律、量变质变规律和否定之否定规律不但可以帮助我们解释问题，还对我们的学习生活有着很强的指导作用，让我们的行为更具智慧。在今后的生活中，我们需要勤于思考，时刻按辩证法所教导我们的规律行事，不要违背客观规律，否则只会与成功渐行渐远。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大二上学期《马克思主义基本原理概论》实践环节报告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在本学期的《马克思主义基本原理概论》课堂上，我对辩证法及其三大规律即对立统一规律、量变质变规律和否定之否定规律有了系统的学习。为了对其有更为深刻的认识与理解，我尝试运用这三大规律来解释日常生活中的问题。以下我将分三个部分，分别阐述我在生活中对对立统一规律、量变质变规律和否定之否定规律的体会与感悟。
    
    </summary>
    
      <category term="文学" scheme="https://blog.pcninja.cn/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="写作" scheme="https://blog.pcninja.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="辩证法" scheme="https://blog.pcninja.cn/tags/%E8%BE%A9%E8%AF%81%E6%B3%95/"/>
    
      <category term="马克思主义" scheme="https://blog.pcninja.cn/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>为什么人类命运共同体理念产生了广泛而深远的国际影响？</title>
    <link href="https://blog.pcninja.cn/2019/11/the-international-influence-of-the-concept-of-a-community-of-shared-future-for-mankind/"/>
    <id>https://blog.pcninja.cn/2019/11/the-international-influence-of-the-concept-of-a-community-of-shared-future-for-mankind/</id>
    <published>2019-11-09T15:23:13.000Z</published>
    <updated>2020-03-17T12:42:37.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二上学期《形式与政策》论文</p></blockquote><p>&emsp;&emsp;自党的十八大习近平总书记首次提出人类命运共同体理念以来，这一追求共同发展的价值观越来越被国际社会所接受。中国也不断提出构建人类命运共同体的中国方案，贡献着中国智慧。我认为，之所以人类命运共同体理念能够产生如此广泛而深远的国际影响，是因为这个价值理念维护着全世界人民的共同利益，能够兼容不同文化、不同种族的人民的价值理念。<a id="more"></a><br>&emsp;&emsp;我认为，“人类命运共同体”不是哪一个人、哪一政党或是哪一国家的专利，而是一个客观存在的事实，全人类本就是一个“一荣俱荣，一损俱损”的命运共同体。纵观地球46亿年的浩瀚历史，人类的发展仅仅持续了不过15万年，因此人类文明的存在对于我们的家园——地球来说，只是弹指一挥间。我们主宰不了地球的命运，我们能够左右的，只有我们人类自己的命运。生存是文明的第一需要，人类利益远高于国家利益或是个人利益，因为当人类的共同利益即生存需要受到威胁时，国家间的较量、个人的财富和社会地位也就变得毫无意义。然而此时此刻，我们的生存正受到威胁，领土争端、民族宗教矛盾、恐怖袭击等事件时刻破坏着世界人民的安全与秩序，对地球资源的过度开发、碳排放的持续增加、核武器的扩散更是让人类愈发接近毁灭的边缘。<br>&emsp;&emsp;要想捍卫全人类的共同利益，必须各个国家通力合作、达成共识，在追求自身利益的同时兼顾他国利益，时刻站在全人类的共同立场，与地球上的人民同呼吸、共命运。尤其是大国，更应该站在更高的角度审视问题，因为能够主宰人类命运的往往正是世界当中的强权。正如1962年的古巴导弹危机，美苏两国的军备竞赛把全人类推向了毁灭的边缘，国家间的不正当竞争险些让千年人类文明付之一炬。如今两极格局的世界已不复存在，但热核战争的威胁依旧笼罩在全世界人民头上，在朝核、伊核问题上，中国坚持倡导以对话、谈判的方式解决争端，在维护地区和平稳定方面贡献了自己的力量，体现出了大国外交的国际责任感。<br>&emsp;&emsp;我认为，中国首先提出人类命运共同体理论，是中国和平崛起的象征，体现了我国的大国担当与大国责任。在当今世界多极化、经济全球化的趋势下，有更多的国家需要承担起维护人类共同利益的责任与使命，在这一方面，中国起到了很好的表率作用。在博鳌亚洲论坛、联合国大会、“一带一路”国际合作高峰论坛、二十国集团领导人峰会等国际会议上，我国多次向全世界发出构建人类命运共同体的倡议，并不断传达中国理念、提出中国方案。此外，中国身体力行，在经济、文化、教育、环境等诸多领域都为全世界做出了重大贡献，我们摒弃冷战思维的零和博弈，倡导互利共赢，“一带一路”建设为人类创造了巨大利益，是人类命运共同体理念的最好表现。<br>&emsp;&emsp;中国从来没有像今天这样接近世界舞台中心, 从来没有像今天这样全方位影响世界。如今的中国，正在成为构建人类命运共同体的倡导者、实践者、先行者, 不断为人类做出更大贡献。正是因为符合全人类的价值理念、保障全人类的切身利益，人类命运共同体理念才会产生如此广泛而深远的国际影响。我相信世界各国会同中国一道，用互利共赢取代零和博弈，为全人类谋福祉，实现共同繁荣的“世界梦”。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大二上学期《形式与政策》论文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;自党的十八大习近平总书记首次提出人类命运共同体理念以来，这一追求共同发展的价值观越来越被国际社会所接受。中国也不断提出构建人类命运共同体的中国方案，贡献着中国智慧。我认为，之所以人类命运共同体理念能够产生如此广泛而深远的国际影响，是因为这个价值理念维护着全世界人民的共同利益，能够兼容不同文化、不同种族的人民的价值理念。
    
    </summary>
    
      <category term="文学" scheme="https://blog.pcninja.cn/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="写作" scheme="https://blog.pcninja.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="形式与政策" scheme="https://blog.pcninja.cn/tags/%E5%BD%A2%E5%BC%8F%E4%B8%8E%E6%94%BF%E7%AD%96/"/>
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="人类命运共同体" scheme="https://blog.pcninja.cn/tags/%E4%BA%BA%E7%B1%BB%E5%91%BD%E8%BF%90%E5%85%B1%E5%90%8C%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>我与共和国共成长</title>
    <link href="https://blog.pcninja.cn/2019/10/I-grow-with-the-Republic/"/>
    <id>https://blog.pcninja.cn/2019/10/I-grow-with-the-Republic/</id>
    <published>2019-10-30T07:18:01.000Z</published>
    <updated>2020-03-17T13:09:55.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二上学期《马克思主义基本原理概论》实践环节报告<br>注：虽然是为了完成作业，但参加这次大典我确实感触颇多，此次经历真的胜过千百次爱国主义教育，令人记忆深刻，因此这篇文章具有一定纪念意义。</p><div class="image-size-30"><img src="/2019/10/I-grow-with-the-Republic/image.jpg" title="游行归来，不能自已"></div></blockquote><p>&emsp;&emsp;“今天是你的生日，我的中国。清晨我放飞一群白鸽，为你衔来一枚橄榄叶，鸽子在崇山峻岭飞过。”当童声演唱的《今天是你的生日》打破长安街清晨的寂静，仿佛有一股电流瞬间穿过我的脊背，使原本睡眼惺忪的我不禁颤栗，泪珠在眼眶中打转。这是我由衷地为祖国母亲感到动容，因为我深深地知道，我的祖国七十年一路走来，经历了什么样的惊涛骇浪，克服了什么样的艰难险阻。我想，只有了解了新中国走到今天的不易，才会发自肺腑地为之献上最美好的祝福，才会从心底里说出那句“我爱你，中国”。<a id="more"></a><br>&emsp;&emsp;直到此时回顾参加群众游行的经历，我仍心潮澎湃。我们数十天的训练，为的是向全世界展示当代中国青年的朝气蓬勃，为的是向全世界展示中国人民群众强大的凝聚力。能够有幸成为十四亿中华儿女的代表，我感到无比荣幸与自豪。在10月1日的正义路上，我们聆听了习近平主席在庆祝中华人民共和国成立70周年大会上的讲话，其中讲到：“今天，社会主义中国巍然屹立在世界东方，没有任何力量能够撼动我们伟大祖国的地位，没有任何力量能够阻挡中国人民和中华民族的前进步伐”<sup>[1]</sup>，我相信我身边的每个人听到这里都像我一样慷慨激昂，这种空前的民族自豪感，是新中国从站起来富起来到强起来的最好印证。<br>&emsp;&emsp;随着分列式的开始，我们涌入长安街两侧，坦克、装甲车的轰鸣声充斥着我的双耳，雄壮威武的武器装备从我眼前缓缓经过。难以想象无侦-8、攻击-11、东风-17、东风-41等最先进的国防重器竟距离我不足10米远。我想，这种场景所带来的震撼，远比任何爱国主义教育都要来得实在。新中国国防实力的提升一举改变了近代中国落后挨打的局面，也使中国人有底气屹立在世界民族之林。<br>&emsp;&emsp;当《红旗颂》奏响，“致敬”方阵的礼宾车从我面前驶过，大家情不自禁地向车上的新中国缔造者亲属、老红军、老八路军、老解放军挥动五星红旗。他们为了民族独立和人民幸福做出了卓著贡献，铸就了坚强不屈的民族脊梁，他们值得接受我们每一名中国人向他们的致敬。<br>&emsp;&emsp;走在“一国两制”方阵里，我们挥舞旗帜，欢呼致意。当我们经过天安门前，我向左望去，看到孙中山先生凝望着广场，这位革命的先行者曾经奋力让黑暗的中国走向黎明；我又向右望去，看到毛泽东主席注视着广场，这位开国领袖让沉睡的东方雄狮昂起了头颅。我们每一个人高喊“祖国我爱你”，喊出的不光是我们自己的心声，更代表了包含港澳台同胞在内的十四亿中华儿女的心声。我坚信，在“一国两制”伟大构想的框架下，香港明天会更好，澳门明天会更好，祖国统一大业也终将实现。<br>&emsp;&emsp;在我回看这次庆祝大会的时候，一句解说词让我久久不能忘怀：“今天的天安门广场是世界瞩目的中心，今天的中国正前所未有的靠近世界舞台中心。”诚然，中国正以和平崛起的方式，悄然走向世界的中心。回望我与共和国共同走过的这十九年，我见证了中国加入世界贸易组织，见证了一届难以超越的奥运会，见证了诺贝尔文学奖和诺贝尔生理学或医学奖花落神州大地，见证了北京的“APEC蓝”，见证了G20峰会的“最忆是杭州”，见证了世界第二大经济体之名的易主，这些都是中国一步步迈向世界舞台中心所留下的坚实脚印。<br>&emsp;&emsp;中国的和平崛起必将经历艰难险阻的考验，当今的中国，正面临着前所未有的巨大挑战。对外，在美国坚持奉行单边主义、贸然向中国挑起“贸易战”的情形下，需要我们众志成城、共同面对，同时坚持以和平谈判的方式解决争端；对内，香港“反送中”运动的延烧仍需林郑政府在“一国两制”的框架下提出一个智慧的解决方案，台湾问题同样要求双方领导集团运用各自的大智慧，以政治谈判的方式共同推进和平统一进程。诚然，当下的形势是严峻的，但这也是复兴之路上我们不得不面对的挑战。<br>&emsp;&emsp;面对挑战，需要我们青年一代做出自己的贡献。经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位<sup>[2]</sup>。随着我阅历的增长与思想认识的不断深化，我愈发意识到自己处在这个令我心潮澎湃的“黄金时代”：我今年19岁，到2035年社会主义现代化基本实现时，还不到40岁；到本世纪中叶全面建成社会主义现代化强国时，刚刚50岁。我将有幸成为民族复兴伟大进程的见证者与亲历者，但是，我更想成为开创者与建设者。我深知，如今的青春中国风华正茂，民族复兴的梦想正由我们去实现。为此，需要我继续加强理论知识学习，增强自身能力，在学校、社会中起积极带头作用，用自己的奋斗走好我们这一代人的新长征。<br>&emsp;&emsp;共和国见证着我的成长，我也见证着共和国一步步走向强盛。在接下来的漫长道路上，我与共和国仍将继续披荆斩棘，共同成长，向民族复兴的共同目标不断迈进。祝福我与共和国的明天更加灿烂辉煌！</p><p><strong>参考文献：</strong><br><small>&emsp;&emsp;[1]习近平.在庆祝中华人民共和国成立70周年大会上的讲话[M].人民出版社:北京,2019:1.<br>&emsp;&emsp;[2]习近平.决胜全面建成小康社会夺取新时代中国特色社会主义伟大胜利——在中国共产党第十九次全国代表大会上的报告[M].人民出版社:北京,2017:1.</small></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大二上学期《马克思主义基本原理概论》实践环节报告&lt;br&gt;注：虽然是为了完成作业，但参加这次大典我确实感触颇多，此次经历真的胜过千百次爱国主义教育，令人记忆深刻，因此这篇文章具有一定纪念意义。&lt;/p&gt;
&lt;div class=&quot;image-size-30&quot;&gt;&lt;img src=&quot;/2019/10/I-grow-with-the-Republic/image.jpg&quot; title=&quot;游行归来，不能自已&quot;&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;“今天是你的生日，我的中国。清晨我放飞一群白鸽，为你衔来一枚橄榄叶，鸽子在崇山峻岭飞过。”当童声演唱的《今天是你的生日》打破长安街清晨的寂静，仿佛有一股电流瞬间穿过我的脊背，使原本睡眼惺忪的我不禁颤栗，泪珠在眼眶中打转。这是我由衷地为祖国母亲感到动容，因为我深深地知道，我的祖国七十年一路走来，经历了什么样的惊涛骇浪，克服了什么样的艰难险阻。我想，只有了解了新中国走到今天的不易，才会发自肺腑地为之献上最美好的祝福，才会从心底里说出那句“我爱你，中国”。
    
    </summary>
    
      <category term="文学" scheme="https://blog.pcninja.cn/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="写作" scheme="https://blog.pcninja.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="国庆" scheme="https://blog.pcninja.cn/tags/%E5%9B%BD%E5%BA%86/"/>
    
      <category term="群众游行" scheme="https://blog.pcninja.cn/tags/%E7%BE%A4%E4%BC%97%E6%B8%B8%E8%A1%8C/"/>
    
      <category term="爱国" scheme="https://blog.pcninja.cn/tags/%E7%88%B1%E5%9B%BD/"/>
    
  </entry>
  
  <entry>
    <title>【音乐】庆祝中华人民共和国成立70周年阅兵式军乐欣赏</title>
    <link href="https://blog.pcninja.cn/2019/10/the-military-music-of-the-parade/"/>
    <id>https://blog.pcninja.cn/2019/10/the-military-music-of-the-parade/</id>
    <published>2019-10-03T12:12:54.000Z</published>
    <updated>2020-04-06T08:36:16.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://pcninja.cn/player" target="_blank" rel="noopener">点击进入播放器</a></p></blockquote><ul><li><strong>《钢铁洪流进行曲》</strong> - 中国人民解放军联合军乐团</li><li><strong>《东风浩荡进行曲》</strong> - 中国人民解放军联合军乐团</li><li><strong>《雄鹰出击进行曲》</strong> - 中国人民解放军联合军乐团</li><li><strong>《冲上云霄》</strong> - 中国人民解放军联合军乐团</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pcninja.cn/player&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击进入播放器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;《钢铁洪流进行曲》&lt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blog.pcninja.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="军乐" scheme="https://blog.pcninja.cn/tags/%E5%86%9B%E4%B9%90/"/>
    
      <category term="交响乐" scheme="https://blog.pcninja.cn/tags/%E4%BA%A4%E5%93%8D%E4%B9%90/"/>
    
      <category term="阅兵" scheme="https://blog.pcninja.cn/tags/%E9%98%85%E5%85%B5/"/>
    
  </entry>
  
</feed>
