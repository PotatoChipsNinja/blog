<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>薯片忍者的小站</title>
  
  <subtitle>今天的故事 是明天的回忆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pcninja.cn/"/>
  <updated>2020-04-08T11:25:12.157Z</updated>
  <id>https://blog.pcninja.cn/</id>
  
  <author>
    <name>薯片忍者</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 48. 旋转图像</title>
    <link href="https://blog.pcninja.cn/2020/04/rotate-image/"/>
    <id>https://blog.pcninja.cn/2020/04/rotate-image/</id>
    <published>2020-04-07T03:45:28.000Z</published>
    <updated>2020-04-08T11:25:12.157Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 n × n 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。</p><p><strong>说明:</strong><br>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请<strong>不要</strong>使用另一个矩阵来旋转图像。<br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>每转一个元素，就要把目的地当前的元素也转到目标位置，以此类推，一共要转4个元素。<br>例如，要想转动 <code>m[i][j]</code>，那么对应的四个元素要按照 <code>m[i][j] -&gt; m[j][N-i-1] -&gt; m[N-i-1][N-j-1] -&gt; m[N-j-1][i]</code> 的方式转动。<br>所以，我们只需要转矩阵的左上角的元素，让其他地方的元素跟着转。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; matrixSize/<span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; (matrixSize+<span class="number">1</span>)/<span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 旋转对应位置上的4个数：</span></span><br><span class="line">            <span class="comment">// m[i][j] -&gt; m[j][N-i-1] -&gt; m[N-i-1][N-j-1] -&gt; m[N-j-1][i]</span></span><br><span class="line">            k = matrix[matrixSize-j<span class="number">-1</span>][i];</span><br><span class="line">            matrix[matrixSize-j<span class="number">-1</span>][i] = matrix[matrixSize-i<span class="number">-1</span>][matrixSize-j<span class="number">-1</span>];</span><br><span class="line">            matrix[matrixSize-i<span class="number">-1</span>][matrixSize-j<span class="number">-1</span>] = matrix[j][matrixSize-i<span class="number">-1</span>];</span><br><span class="line">            matrix[j][matrixSize-i<span class="number">-1</span>] = matrix[i][j];</span><br><span class="line">            matrix[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)。</p><div class="image-size-50"><img src="/2020/04/rotate-image/image.png" title="提交结果"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;br&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你必须在&lt;strong&gt;原地&lt;/strong&gt;旋转图像，这意味着你需要直接修改输入的二维矩阵。请&lt;strong&gt;不要&lt;/strong&gt;使用另一个矩阵来旋转图像。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="原地算法" scheme="https://blog.pcninja.cn/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 42. 接雨水</title>
    <link href="https://blog.pcninja.cn/2020/04/trapping-rain-water/"/>
    <id>https://blog.pcninja.cn/2020/04/trapping-rain-water/</id>
    <published>2020-04-04T00:50:24.000Z</published>
    <updated>2020-04-08T11:16:56.864Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><div class="image-size-50"><img src="/2020/04/trapping-rain-water/img1.png" title="上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）"></div><a id="more"></a><p><strong>示例:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>&emsp;&emsp;每个位置上能存多少水取决于它左右两侧的最高峰较低的那一峰的高度，比如图中第六个位置上，它左侧最高为2格，右侧最高为3格，所以这一列的水位能到2格的高度。<br>&emsp;&emsp;所以我们的算法就是：首先从左往右扫一趟数组，算出每个位置上左侧的最高峰；再从右往左扫一趟数组，算出每个位置上右侧的最高峰。最后遍历一遍求出每个位置上的积水量。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x,y) ((x)&lt;(y)?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span> *height, <span class="keyword">int</span> heightSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!heightSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, temp, i;</span><br><span class="line">    <span class="keyword">int</span> leftTop[heightSize], rightTop[heightSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算leftTop和rightTop */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, leftTop[<span class="number">0</span>] = <span class="number">0</span>; i &lt; heightSize; ++i)</span><br><span class="line">        leftTop[i] = max(leftTop[i<span class="number">-1</span>], height[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i = heightSize<span class="number">-2</span>, rightTop[heightSize<span class="number">-1</span>] = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        rightTop[i] = max(rightTop[i+<span class="number">1</span>], height[i+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; heightSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = min(leftTop[i], rightTop[i]) - height[i];</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">            ans += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这种解法遍历了三趟数组，所以时间复杂度为 O(n)。用到了 leftTop 和 rightTop 两个数组，所以空间复杂度也是 O(n)。</p><div class="image-size-50"><img src="/2020/04/trapping-rain-water/img2.png" title="几乎双百"></div><p>&emsp;&emsp;官方题解提供了一种更优秀的解法，可以只遍历一次数组，且空间复杂度为 O(1)：<br>&emsp;&emsp;双指针法，一个指针从左往右移动，另一个从右往左移动。维护两个变量 left_max 和 right_max ，分别存储左右两边目前为止遇到的最高峰。<br>&emsp;&emsp;一开始，两个指针分别指向最左侧和最右侧的元素。如果左侧指针的高度比右侧矮，左侧指针就右移一格，否则就右侧指针左移。换句话说，就是始终保持对侧是不矮于本侧的。这样一来，水能存多高就只取决于本侧的最大高度了。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;div class=&quot;image-size-50&quot;&gt;&lt;img src=&quot;/2020/04/trapping-rain-water/img1.png&quot; title=&quot;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="双指针" scheme="https://blog.pcninja.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1162. 地图分析</title>
    <link href="https://blog.pcninja.cn/2020/03/as-far-from-land-as-possible/"/>
    <id>https://blog.pcninja.cn/2020/03/as-far-from-land-as-possible/</id>
    <published>2020-03-29T10:01:01.000Z</published>
    <updated>2020-04-08T10:31:41.626Z</updated>
    
    <content type="html"><![CDATA[<p>你现在手里有一份大小为 N x N 的地图（网格）<code>grid</code>，上面的每个区域（单元格）都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。<br>我们这里说的距离是「曼哈顿距离」：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个区域之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。<br>如果我们的地图上只有陆地或者海洋，请返回 <code>-1</code>。<br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1,0,1],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释：海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1,0,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">输出：4</span><br><span class="line">解释：海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>多源BFS。先把所有 <code>1</code>（陆地）入队，每次循环把队首上下左右四个方向的海洋入队。为了防止重复搜索，把搜到的海洋标记为 <code>1</code>。最后一个出队的一定是离陆地最远的。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span> **grid, <span class="keyword">int</span> gridSize, <span class="keyword">int</span> *gridColSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">10000</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, x, y;</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; gridSize; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; gridSize; ++j)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">0</span>] = i;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">1</span>] = j;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">                rear++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(!rear || rear == gridSize*gridSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(rear &gt; front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">queue</span>[front][<span class="number">0</span>] + direction[i][<span class="number">0</span>];</span><br><span class="line">            y = <span class="built_in">queue</span>[front][<span class="number">1</span>] + direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; gridSize &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; gridSize &amp;&amp; !grid[x][y])</span><br><span class="line">            &#123;</span><br><span class="line">                grid[x][y] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">0</span>] = x;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">1</span>] = y;</span><br><span class="line">                <span class="built_in">queue</span>[rear][<span class="number">2</span>] = <span class="built_in">queue</span>[front][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">                rear++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>[front<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种解法的时间复杂度和空间复杂度显然都是 O(n<sup>2</sup>)。</p><div class="image-size-50"><img src="/2020/03/as-far-from-land-as-possible/image.png" title="双百解法"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你现在手里有一份大小为 N x N 的地图（网格）&lt;code&gt;grid&lt;/code&gt;，上面的每个区域（单元格）都用 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 标记好了。其中 &lt;code&gt;0&lt;/code&gt; 代表海洋，&lt;code&gt;1&lt;/code&gt; 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。&lt;br&gt;我们这里说的距离是「曼哈顿距离」：&lt;code&gt;(x0, y0)&lt;/code&gt; 和 &lt;code&gt;(x1, y1)&lt;/code&gt; 这两个区域之间的距离是 &lt;code&gt;|x0 - x1| + |y0 - y1|&lt;/code&gt; 。&lt;br&gt;如果我们的地图上只有陆地或者海洋，请返回 &lt;code&gt;-1&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://blog.pcninja.cn/tags/BFS/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 365. 水壶问题</title>
    <link href="https://blog.pcninja.cn/2020/03/water-and-jug-problem/"/>
    <id>https://blog.pcninja.cn/2020/03/water-and-jug-problem/</id>
    <published>2020-03-22T06:50:25.000Z</published>
    <updated>2020-03-22T08:20:16.746Z</updated>
    
    <content type="html"><![CDATA[<p>有两个容量分别为 <code>x</code> 升 和 <code>y</code> 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <code>z</code> 升的水？<br>如果可以，最后必须用以上水壶中的一或两个来盛放取得的 <code>z</code> 升水。<br>允许做以下操作：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><a id="more"></a><p><strong>示例 1:</strong>（出自电影《虎胆龙威》）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>操作方法：先把A壶加满，倒入B壶，再把A壶加满，倒入B壶，此时A、B各有1升和5升水。倒光B壶，把A壶中的1升水倒入B壶，加满A壶，倒入B壶，此时B壶即有4升水。</p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><p><strong>题解:</strong><br>&emsp;&emsp;如果从纯算法角度来考虑该问题，那么 DFS 或者 BFS 都可以。以 <code>(A壶水量, B壶水量)</code> 作为状态去搜索。每个状态需要搜下面这 6 种情况：</p><ul><li>装满A壶</li><li>装满B壶</li><li>清空A壶</li><li>清空B壶</li><li>从A壶向B壶倒水，直到装满或者倒空</li><li>从B壶向A壶倒水，直到装满或者倒空</li></ul><p>&emsp;&emsp;为了防止无限递归，需要建立一个 HashSet 来存储已经搜索过的状态，保证每个状态最多只被搜到一次。由于搜索深度很深，递归实现容易爆栈，所以可以用栈（队列）实现 DFS（BFS）。<br>&emsp;&emsp;无论 DFS 还是 BFS，因为最多有 $(x+1)(y+1)$ 种状态，所以时间复杂度和空间复杂度都是 $O(xy)$。反正我写的 DFS 在 LeetCode 上 TLE 了😩</p><div class="image-size-50"><img src="/2020/03/water-and-jug-problem/img1.png" title="TLE"></div><p>&emsp;&emsp;然而此题有个绝妙的数学解法，可秒杀 DFS/BFS：<br>&emsp;&emsp;我们首先需要明确，在初始状态下，两个水壶中水的总量是 0，之后，不管我们做六种操作的哪一种，都只会使水的总量 <code>增加x</code> 或 <code>增加y</code> 或 <code>减少x</code> 或 <code>减少y</code>。注意，两个水壶不会同时半满，所以如果我们把半满的水壶倒空或接满，虽然水的总量的变化量不是 <code>x</code> 或 <code>y</code>，但是这么操作之后就又回到了 <code>一个空一个满</code> 或 <code>两个空</code> 或 <code>两个满</code> 的状态，所以把半满的水壶倒空或接满这类操作是无意义的。<br>&emsp;&emsp;所以，水的总量的变化量一定是 <code>x</code> 或 <code>y</code>，由此我们可以得知水的总量永远等于 $ax+by$，其中$a,b\in Z$。这样一来，获取 <code>z</code> 升水的充要条件就是 $z\leq x+y$ 并且方程 $ax+by=z$ 有整数解。<br>&emsp;&emsp;由贝祖定理（或称裴蜀定理）可知，$ax+by=z$ 有解当且仅当 $z$ 是 $x, y$ 的最大公约数的倍数。所以此题数学解法的代码如下：</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>   <span class="comment">// 求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a%b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(z &gt; x + y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这种解法的时间复杂度等于辗转相除法求最大公约数的时间复杂度，即 $O(\log(\min \lbrace x, y\rbrace ))$，空间复杂度为 $O(1)$。</p><div class="image-size-50"><img src="/2020/03/water-and-jug-problem/img2.png" title="双百解法"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个容量分别为 &lt;code&gt;x&lt;/code&gt; 升 和 &lt;code&gt;y&lt;/code&gt; 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;code&gt;z&lt;/code&gt; 升的水？&lt;br&gt;如果可以，最后必须用以上水壶中的一或两个来盛放取得的 &lt;code&gt;z&lt;/code&gt; 升水。&lt;br&gt;允许做以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="数学" scheme="https://blog.pcninja.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="贝祖定理" scheme="https://blog.pcninja.cn/tags/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 695. 岛屿的最大面积</title>
    <link href="https://blog.pcninja.cn/2020/03/max-area-of-island/"/>
    <id>https://blog.pcninja.cn/2020/03/max-area-of-island/</id>
    <published>2020-03-15T13:27:29.000Z</published>
    <updated>2020-03-15T14:03:38.556Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含了一些 0 和 1 的非空二维数组 <code>grid</code> , 一个 <strong>岛屿</strong> 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。<br>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code>0</code>)<br><a id="more"></a><br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure></p><p>对于上面这个给定矩阵应返回 <code>6</code>。注意答案不应该是 <code>11</code>，因为岛屿只能包含水平或垂直的四个方向的 1。</p><p><strong>示例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure></p><p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p><p><strong>注意:</strong> 给定的矩阵 <code>grid</code> 的长度和宽度都不超过 50。</p><p><strong>题解:</strong><br>遍历二维数组，遇到 1 的时候就 DFS 深搜找出这个岛屿的面积，同时把经过的 1 都置为 0，避免重复搜索。</p><p><strong>代码:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>** grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j])</span><br><span class="line">        ans += dfs(grid, m, n, i<span class="number">-1</span>, j);</span><br><span class="line">    <span class="keyword">if</span>(j<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>])</span><br><span class="line">        ans += dfs(grid, m, n, i, j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &lt; m &amp;&amp; grid[i+<span class="number">1</span>][j])</span><br><span class="line">        ans += dfs(grid, m, n, i+<span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; grid[i][j+<span class="number">1</span>])</span><br><span class="line">        ans += dfs(grid, m, n, i, j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面 gridSize 是行数，*gridColSize 是列数（不知道 LeetCode 为什么这么给参数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>** grid, <span class="keyword">int</span> gridSize, <span class="keyword">int</span>* gridColSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gridSize; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *gridColSize; ++j)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">                maxArea = max(maxArea, dfs(grid, gridSize, *gridColSize, i, j));</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h3><p>今天才发现 LeetCode 的「每日 1 题」打卡刷题活动，其实从三月一号就开始了。今天第一天做就碰上这道水题，神人品😁。<br>提交上去之后得到的结果是这样的：</p><p><div class="image-size-50"><img src="/2020/03/max-area-of-island/image.png"></div><br>真是惊了，是因为用 C 写的人比较少吗😮</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 &lt;code&gt;grid&lt;/code&gt; , 一个 &lt;strong&gt;岛屿&lt;/strong&gt; 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。&lt;br&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 &lt;code&gt;0&lt;/code&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://blog.pcninja.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://blog.pcninja.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NumPy 学习笔记</title>
    <link href="https://blog.pcninja.cn/2020/02/NumPy-learning-notes/"/>
    <id>https://blog.pcninja.cn/2020/02/NumPy-learning-notes/</id>
    <published>2020-02-21T07:21:31.000Z</published>
    <updated>2020-02-21T07:50:20.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 Jupyter Notebook 笔记转 Markdown，原 <code>.ipynb</code> 文件可点击<a href="/2020/02/NumPy-learning-notes/learn_numpy.ipynb" title="此处">此处</a>下载</p></blockquote><p>关于 Python 和 NumPy 的使用可以参考斯坦福大学<code>CS231n</code>的教程：<a href="https://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">https://cs231n.github.io/python-numpy-tutorial/</a>。</p><p>Numpy 是 Python 中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。</p><p>要想使用 NumPy，我们首先需要引入<code>numpy</code>包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>NumPy 数组是所有相同类型的值的网格，并由非负整数元组索引。维数是数组的<em>秩</em>；数组的<em>形状</em>是一个整数元组，给出沿每个维度的数组大小。</p><p>我们可以通过嵌套的 Python 列表初始化 NumPy 数组，并使用方括号访问元素：<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 创建一个秩为1的数组</span></span><br><span class="line">print(type(a))</span><br><span class="line">print(a.shape)</span><br><span class="line">print(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                 <span class="comment"># 改变数组中的一个元素</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;(3,)1 2 3[5 2 3]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  <span class="comment"># 创建一个秩为2的数组</span></span><br><span class="line">print(b)</span><br><span class="line">print(b.shape)</span><br><span class="line">print(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[[1 2 3] [4 5 6]](2, 3)1 2 4</code></pre><p>NumPy 也提供许多创建数组的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">2</span>, <span class="number">2</span>))  <span class="comment"># 创建一个全零数组</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>[[0. 0.] [0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.ones((<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 创建一个全1数组</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>[[1. 1.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.full((<span class="number">2</span>, <span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># 创建一个常量数组</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><pre><code>[[7 7] [7 7]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = np.eye(<span class="number">2</span>)  <span class="comment"># 创建一个2x2的单位矩阵</span></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><pre><code>[[1. 0.] [0. 1.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = np.random.random((<span class="number">2</span>, <span class="number">2</span>))  <span class="comment"># 创建一个填充随机数的数组</span></span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><pre><code>[[0.23316062 0.89221292] [0.15442143 0.18416244]]</code></pre><p>更多创建数组的方法请见<a href="https://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>NumPy 提供了几种索引数组的方式。</p><p><strong>切片：</strong>类似于 Python 的列表，NumPy 数组可以被切片。由于数组可能是多维的，因此必须为数组的每个维度指定一个切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建这样一个秩为2、形状为(3, 4)的数组</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片来提取由前2行，列号为1、2组成的子数组</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>[[2 3] [6 7]]</code></pre><p>数组的一个切片是对于同一数据的一个视图，因此修改它将修改原数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>    <span class="comment"># b[0, 0]与a[0, 1]是同一条数据</span></span><br><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>277</code></pre><p>你也可以将整数索引与切片索引混合使用。但是，这样做将产生比原始数组的秩低的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建这样一个秩为2、形状为(3, 4)的数组</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]</code></pre><p>两种访问数组中间行数据的方式。将整数索引与切片混合使用会产生一个较低秩的数组，而仅使用切片会产生一个与原始数组等秩的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># a的第二行的秩为1的视图</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># a的第二行的秩为2的视图</span></span><br><span class="line">row_r3 = a[[<span class="number">1</span>], :]  <span class="comment"># a的第二行的秩为2的视图</span></span><br><span class="line">print(row_r1, row_r1.shape)</span><br><span class="line">print(row_r2, row_r2.shape)</span><br><span class="line">print(row_r3, row_r3.shape)</span><br></pre></td></tr></table></figure><pre><code>[5 6 7 8] (4,)[[5 6 7 8]] (1, 4)[[5 6 7 8]] (1, 4)</code></pre><p>在访问数组的列时，我们可以进行相同的区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">print(col_r1, col_r1.shape)</span><br><span class="line">print(col_r2, col_r2.shape)</span><br></pre></td></tr></table></figure><pre><code>[ 2  6 10] (3,)[[ 2] [ 6] [10]] (3, 1)</code></pre><p><strong>整数数组索引：</strong>当使用切片对 NumPy 数组进行索引时，生成的数组视图将始终是原始数组的子数组。相反，整数数组索引允许你使用另一个数组中的数据构造任意数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数数组索引的一个例子</span></span><br><span class="line"><span class="comment"># 返回的数组将是(3,)形状的</span></span><br><span class="line">print(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的整数数组索引的例子与这个等价：</span></span><br><span class="line">print(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))</span><br></pre></td></tr></table></figure><pre><code>[1 4 5][1 4 5]</code></pre><p>使用整数数组索引时，可以重复使用源数组中的相同元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">print(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))</span><br></pre></td></tr></table></figure><pre><code>[2 2][2 2]</code></pre><p>整数数组索引的一个有用技巧是从矩阵的每一行中选择或更改一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新数组，从中选择元素</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引数组</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用b中的索引从a的每行中选择一个元素</span></span><br><span class="line">print(a[np.arange(<span class="number">4</span>), b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用b中的索引对a的每行中的一个元素进行改变</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]][ 1  6  7 11][[11  2  3] [ 4  5 16] [17  8  9] [10 21 12]]</code></pre><p><strong>布尔数组索引：</strong>布尔数组索引使您可以挑选出数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)  <span class="comment"># 找出大于2的元素；</span></span><br><span class="line">                    <span class="comment"># 这将返回一个与a形状相同的numpy布尔数组，</span></span><br><span class="line">                    <span class="comment"># 其中bool_idx的每个位置代表a中对应元素是否大于2。</span></span><br><span class="line"></span><br><span class="line">print(bool_idx)</span><br></pre></td></tr></table></figure><pre><code>[[False False] [ True  True] [ True  True]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们使用布尔数组索引来构建一个秩为1的数组，</span></span><br><span class="line"><span class="comment"># 该数组由bool_idx中值为True的对应元素组成</span></span><br><span class="line">print(a[bool_idx])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用一个简洁的语句完成上述操作：</span></span><br><span class="line">print(a[a &gt; <span class="number">2</span>])</span><br></pre></td></tr></table></figure><pre><code>[3 4 5 6][3 4 5 6]</code></pre><p>更多关于 NumPy 数组索引的信息请见<a href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个 NumPy 数组都是相同类型的元素的网格。NumPy 提供了大量可用于构造数组的数据类型。在创建数组时，NumPy 会尝试猜测一个数据类型，但是构造数组的函数通常还包含一个可选参数来明确指定数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 让NumPy选择数据类型</span></span><br><span class="line">print(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])  <span class="comment"># 让NumPy选择数据类型</span></span><br><span class="line">print(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)  <span class="comment"># 强制数据类型</span></span><br><span class="line">print(x.dtype)</span><br></pre></td></tr></table></figure><pre><code>int32float64int64</code></pre><p>更多关于 NumPy 数据类型的信息请见<a href="https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>基本数学函数在数组上逐元素进行操作，并且可用作运算符重载和 NumPy 模块中的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐元素求和；都产生数组</span></span><br><span class="line">print(x + y)</span><br><span class="line">print(np.add(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[ 6.  8.] [10. 12.]][[ 6.  8.] [10. 12.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素求差；都产生数组</span></span><br><span class="line">print(x - y)</span><br><span class="line">print(np.subtract(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[-4. -4.] [-4. -4.]][[-4. -4.] [-4. -4.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素相乘；都产生数组</span></span><br><span class="line">print(x * y)</span><br><span class="line">print(np.multiply(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[ 5. 12.] [21. 32.]][[ 5. 12.] [21. 32.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素相除；都产生数组</span></span><br><span class="line">print(x / y)</span><br><span class="line">print(np.divide(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[0.2        0.33333333] [0.42857143 0.5       ]][[0.2        0.33333333] [0.42857143 0.5       ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素求平方根；产生数组</span></span><br><span class="line">print(np.sqrt(x))</span><br></pre></td></tr></table></figure><pre><code>[[1.         1.41421356] [1.73205081 2.        ]]</code></pre><p>注意，<code>*</code>是逐元素相乘，不是矩阵乘法。取而代之，用<code>dot</code>函数计算向量的内积、向量与矩阵的乘积以及矩阵与矩阵的乘积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量的内积；都是219</span></span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v, w))</span><br></pre></td></tr></table></figure><pre><code>219219</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵/向量乘积；都产生秩为1的数组[29 67]</span></span><br><span class="line">print(x.dot(v))</span><br><span class="line">print(np.dot(x, v))</span><br></pre></td></tr></table></figure><pre><code>[29 67][29 67]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵/矩阵乘积；都产生秩为2的数组</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line">print(x.dot(y))</span><br><span class="line">print(np.dot(x, y))</span><br></pre></td></tr></table></figure><pre><code>[[19 22] [43 50]][[19 22] [43 50]]</code></pre><p>NumPy 提供了许多有用的函数来对数组执行计算。最有用的之一是<code>sum</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  <span class="comment"># 计算所有元素之和</span></span><br><span class="line">print(np.sum(x, axis=<span class="number">0</span>))  <span class="comment"># 计算每一列之和</span></span><br><span class="line">print(np.sum(x, axis=<span class="number">1</span>))  <span class="comment"># 计算每一行之和</span></span><br></pre></td></tr></table></figure><pre><code>10[4 6][3 7]</code></pre><p>NumPy 提供的数学函数的完整列表请见<a href="https://docs.scipy.org/doc/numpy/reference/routines.math.html" target="_blank" rel="noopener">官方文档</a>。</p><p>除了用数组计算数学函数外，我们经常需要整形或以其他方式处理数组中的数据。此类操作的最简单的例子是转置矩阵；要转置矩阵，只需使用数组对象的<code>T</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(x.T)</span><br></pre></td></tr></table></figure><pre><code>[[1 2] [3 4]][[1 3] [2 4]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，对秩为1的数组求转置不会有任何变化：</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(v)</span><br><span class="line">print(v.T)</span><br></pre></td></tr></table></figure><pre><code>[1 2 3][1 2 3]</code></pre><p>NumPy 提供了许多操作数组的函数，完整列表请见<a href="https://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播是一种强大的机制，允许 NumPy 在执行算术运算时处理不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，并且我们想多次使用较小的数组对较大的数组执行某些操作。</p><p>例如，假设我们要向矩阵的每一行添加一个常向量。我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们将向量v加到矩阵x的每一行，</span></span><br><span class="line"><span class="comment"># 并将结果存储在矩阵y中</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># 创建一个与x形状相同的空矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过显式循环将向量v加到矩阵x的每一行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  2  4] [ 5  5  7] [ 8  8 10] [11 11 13]]</code></pre><p>这是可行的；但是当矩阵<code>x</code>非常大时，在 Python 中计算显式循环可能会很慢。注意，将向量<code>v</code>加到矩阵<code>x</code>的每一行相当于：垂直堆叠<code>v</code>的多个副本形成矩阵<code>vv</code>，然后执行<code>x</code>和<code>vv</code>的逐元素求和。我们可以这样实现这种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># 将v的4个副本堆叠在一起</span></span><br><span class="line">print(vv)</span><br></pre></td></tr></table></figure><pre><code>[[1 0 1] [1 0 1] [1 0 1] [1 0 1]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x + vv  <span class="comment"># x和vv逐元素相加</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  2  4] [ 5  5  7] [ 8  8 10] [11 11 13]]</code></pre><p>NumPy 广播使我们无需实际创建多个v的副本即可执行此计算。考虑使用广播的这个版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们将向量v加到矩阵x的每一行，</span></span><br><span class="line"><span class="comment"># 并将结果存储在矩阵y中</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># 通过广播将v加到x的每一行</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  2  4] [ 5  5  7] [ 8  8 10] [11 11 13]]</code></pre><p>即使<code>x</code>的形状是<code>(4, 3)</code>而<code>v</code>的形状是<code>(3,)</code>，但由于广播，<code>y = x + v</code>这一行仍然可以工作；这一行的工作方式就好像v实际具有<code>(4, 3)</code>的形状，其中每一行都是<code>v</code>的一个副本，并且求和是逐元素进行的。</p><p>将两个阵列广播到一起遵循以下规则：</p><ol><li>如果几个数组的秩不同，则在低秩数组的形状前面加1补齐，直到二者的形状具有相同的长度；</li><li>如果两个数组在某个维度上的大小相同，或者其中一个数组在该维度上的大小为1，则称这两个数组该维度上<em>兼容</em>；</li><li>如果几个数组在所有维度上都兼容，则它们可以广播到一起；</li><li>广播后的数组形状等于输入数组的形状在各个维度上的最大值；</li><li>在任一维度中，如果一个数组的大小为1而另一个数组的大小大于1，则第一个数组的行为就像是沿着该维度复制的一样。</li></ol><p>如果上述解释难以理解，可以尝试阅读<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">官方文档</a>中的解释或<a href="https://docs.scipy.org/doc/numpy/user/theory.broadcasting.html" target="_blank" rel="noopener">这篇解释</a>。</p><p>支持广播的函数称为通用函数。所有通用功能的列表请见<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs" target="_blank" rel="noopener">官方文档</a>。</p><p>以下是广播的一些应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算向量的张量积：</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># v具有形状(3,)</span></span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    <span class="comment"># w具有形状(2,)</span></span><br><span class="line"><span class="comment"># 为了计算外积，我们首先将v整形为形状为(3, 1)的列向量；</span></span><br><span class="line"><span class="comment"># 然后我们可以把它广播到w上，以产生形状(3, 2)的输出，</span></span><br><span class="line"><span class="comment"># 即v和w的外积：</span></span><br><span class="line">print(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br></pre></td></tr></table></figure><pre><code>[[ 4  5] [ 8 10] [12 15]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将向量加到矩阵的每一行：</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># x具有形状(2, 3)而v具有形状(3,)，因此它们广播到(2, 3)</span></span><br><span class="line">print(x + v)</span><br></pre></td></tr></table></figure><pre><code>[[2 4 6] [5 7 9]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将向量加到矩阵的每一列：</span></span><br><span class="line"><span class="comment"># x具有形状(2, 3)而w具有形状(2,)。</span></span><br><span class="line"><span class="comment"># 如果我们对x求转置，则它具有形状(3, 2)，</span></span><br><span class="line"><span class="comment"># 并且可以对w进行广播以产生形状(3, 2)的结果；</span></span><br><span class="line"><span class="comment"># 转置此结果将得出形状(2, 3)的最终结果，</span></span><br><span class="line"><span class="comment"># 即将向量w加到矩阵x的每一列的矩阵。</span></span><br><span class="line">print((x.T + w).T)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种解决方案是将w整形为(2, 1)的列向量；</span></span><br><span class="line"><span class="comment"># 然后我们可以直接对x广播它以产生相同的输出。</span></span><br><span class="line">print(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><pre><code>[[ 5  6  7] [ 9 10 11]][[ 5  6  7] [ 9 10 11]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘以常数：</span></span><br><span class="line"><span class="comment"># x具有形状(2, 3)。NumPy将标量视为形状为()的数组；</span></span><br><span class="line"><span class="comment"># 它们可以广播到一起，生成形状为(2, 3)的数组。</span></span><br><span class="line">print(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><pre><code>[[ 2  4  6] [ 8 10 12]]</code></pre><p>广播通常会使您的代码更简洁，更快捷，因此，您应尽可能使用它。</p><h2 id="NumPy-文档"><a href="#NumPy-文档" class="headerlink" title="NumPy 文档"></a>NumPy 文档</h2><p>上文中简短的描述涉及到了您需要了解的有关 NumPy 的许多重要知识，但还远远不够。查看<a href="https://docs.scipy.org/doc/numpy/reference/" target="_blank" rel="noopener">NumPy参考</a>以了解更多关于 NumPy 的信息。</p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p><a href="https://matplotlib.org/" target="_blank" rel="noopener">Matplotlib</a> 是一个绘图库。在本节中将简要介绍<code>matplotlib.pyplot</code>模块，该模块提供了类似于 MATLAB 的绘图系统。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>通过运行这个特殊的 iPython 命令，我们将内联显示绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>Matplotlib 中最重要的函数是<code>plot</code>，它允许您绘制2D数据。这是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算正弦曲线上的点的x和y坐标</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Matplotlib绘制这些点</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()  <span class="comment"># 必须调用plt.show()才能显示图形</span></span><br></pre></td></tr></table></figure><img src="/2020/02/NumPy-learning-notes/1.png"><p>仅需一点点额外的工作，我们就可以轻松地一次绘制多条线，并添加标题、图例和轴标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Matplotlib绘制这些点</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(<span class="string">'x axis label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y axis label'</span>)</span><br><span class="line">plt.title(<span class="string">'Sine and Cosine'</span>)</span><br><span class="line">plt.legend([<span class="string">'Sine'</span>, <span class="string">'Cosine'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/2020/02/NumPy-learning-notes/2.png"><p>您可以在<a href="https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot" target="_blank" rel="noopener">官方文档</a>中阅读有关<code>plot</code>函数的更多信息。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>可以使用<code>subplot</code>函数在同一图中绘制不同的内容。下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算正弦和余弦曲线上的点的x和y坐标</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立高度为2、宽度为1的子图网格，</span></span><br><span class="line"><span class="comment"># 并将第一个子图设置为活动状态</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制第一个图</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(<span class="string">'Sine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第二个子图设置为活动状态，并绘制第二个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(<span class="string">'Cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示该图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/2020/02/NumPy-learning-notes/3.png"><p>您可以在<a href="https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot" target="_blank" rel="noopener">官方文档</a>中阅读有关<code>subplot</code>函数的更多信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为 Jupyter Notebook 笔记转 Markdown，原 &lt;code&gt;.ipynb&lt;/code&gt; 文件可点击&lt;a href=&quot;/2020/02/NumPy-learning-notes/learn_numpy.ipynb&quot; title=&quot;此处&quot;&gt;此处&lt;/a&gt;下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 Python 和 NumPy 的使用可以参考斯坦福大学&lt;code&gt;CS231n&lt;/code&gt;的教程：&lt;a href=&quot;https://cs231n.github.io/python-numpy-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cs231n.github.io/python-numpy-tutorial/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Numpy 是 Python 中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。&lt;/p&gt;
&lt;p&gt;要想使用 NumPy，我们首先需要引入&lt;code&gt;numpy&lt;/code&gt;包：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;NumPy 数组是所有相同类型的值的网格，并由非负整数元组索引。维数是数组的&lt;em&gt;秩&lt;/em&gt;；数组的&lt;em&gt;形状&lt;/em&gt;是一个整数元组，给出沿每个维度的数组大小。&lt;/p&gt;
&lt;p&gt;我们可以通过嵌套的 Python 列表初始化 NumPy 数组，并使用方括号访问元素：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://blog.pcninja.cn/tags/Python/"/>
    
      <category term="NumPy" scheme="https://blog.pcninja.cn/tags/NumPy/"/>
    
      <category term="Matplotlib" scheme="https://blog.pcninja.cn/tags/Matplotlib/"/>
    
      <category term="科学计算" scheme="https://blog.pcninja.cn/tags/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>几种外积的概念辨析</title>
    <link href="https://blog.pcninja.cn/2020/02/discrimination-of-several-outer-products/"/>
    <id>https://blog.pcninja.cn/2020/02/discrimination-of-several-outer-products/</id>
    <published>2020-02-13T08:09:04.000Z</published>
    <updated>2020-02-20T10:41:19.033Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在学习 PyTorch 的时候，看到文档中计算两个向量的“outer product”后得到一个矩阵。我刚开始理所当然地把“outer product”理解为高中所学的外积，即叉积。但我越想越不对劲：两个向量的叉积不应该还是向量吗，怎么会叉出矩阵来呢？查了一波资料后发现这里的“outer product”不是叉积，而是张量积。<br>&emsp;&emsp;中文里的<strong>外积</strong>一词常出现在代数、几何学等领域中。对两向量 $\vec{A}$ 与 $\vec{B}$ 而言，外积可指：</p><ul><li style="overflow: visible;"><strong>叉积</strong>（Cross product），又称<strong>向量积</strong>（Vector product），常写为 $\vec{A}\times\vec{B}$；</li><li style="overflow: visible;"><strong>楔积</strong>（Wedge product 或 Exterior product），常写为 $\vec{A}\wedge\vec{B}$；</li><li style="overflow: visible;"><strong>张量积</strong>（Tensor product 或 Outer product），常写为 $\vec{A}\otimes\vec{B}$。</li></ul><p>&emsp;&emsp;上述三种都可称作外积，但含义却大相径庭，因此极易出现混淆，尤其是“exterior”和“outer”都有外面的意思，我发现网上许多文章甚至一些教科书中都出现了翻译、解释上的错误。我认为避免混淆的最好办法就是使用“叉积”、“向量积”、“楔积”、“张量积”这些没有歧义的词语，而避免使用“外积”一词。<br>&emsp;&emsp;下面是对几种外积概念的简要辨析。<br><a id="more"></a></p><h3 id="一、叉积"><a href="#一、叉积" class="headerlink" title="一、叉积"></a>一、叉积</h3><p>&emsp;&emsp;两个向量 $\vec{a}$ 和 $\vec{b}$ 的叉积仅在三维空间中有定义，写作 $\vec{a}\times\vec{b}$。在物理学中，叉积有时也被写成 $\vec{a}\wedge\vec{b}$，但在数学中 $\vec{a}\wedge\vec{b}$ 是外代数中的外积（楔积）。<br>&emsp;&emsp;叉积可以定义为：</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = |\vec{a}||\vec{b}|\sin{\theta}\ \vec{n}</script><p>其中 $\sin{\theta}$ 表示 $\vec{a}$ 和 $\vec{b}$ 在它们所定义的平面上的夹角（$0^{\circ}\leq\theta\leq180^{\circ}$）。$|\vec{a}|$ 和 $|\vec{b}|$ 是向量 $\vec{a}$ 和 $\vec{b}$ 的模长，而 $\vec{n}$ 则是一个与 $\vec{a}$、$\vec{b}$ 所构成的平面垂直的单位向量，方向由右手定则决定。</p><div class="image-size-30"><img src="/2020/02/discrimination-of-several-outer-products/1.png" title="在右手坐标系中的向量积"></div><p>&emsp;&emsp;叉积可以表达为这样的行列式：</p><script type="math/tex; mode=display">\vec{u}\times\vec{v} = \begin{vmatrix}\vec{i}&\vec{j}&\vec{k}\\u_{1}&u_{2}&u_{3}\\v_{1}&v_{2}&v_{3}\end{vmatrix}</script><p>&emsp;&emsp;沿第一行进行拉普拉斯展开可得：</p><script type="math/tex; mode=display">\begin{aligned}\vec{u}\times\vec{v} &= \begin{vmatrix}u_{2}&u_{3}\\v_{2}&v_{3}\end{vmatrix}\vec{i} + \begin{vmatrix}u_{1}&u_{3}\\v_{1}&v_{3}\end{vmatrix}\vec{j} + \begin{vmatrix}u_{1}&u_{2}\\v_{1}&v_{2}\end{vmatrix}\vec{k}\\&= (u_{2}v_{3}-u_{3}v_{2})\vec{i} - (u_{1}v_{3}-u_{3}v_{1})\vec{j} + (u_{1}v_{2}-u_{2}v_{1})\vec{k}\end{aligned}</script><h3 id="二、楔积"><a href="#二、楔积" class="headerlink" title="二、楔积"></a>二、楔积</h3><p>&emsp;&emsp;不了解，貌似是定义在张量空间上的一种运算。具体细节请移步维基百科<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">外代数（格拉斯曼代数）</a>词条，我反正看不懂。</p><h3 id="三、张量积"><a href="#三、张量积" class="headerlink" title="三、张量积"></a>三、张量积</h3><p>&emsp;&emsp;在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中,如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的：最一般的双线性运算。在某些上下文中也叫做外积。<br>&emsp;&emsp;向量的外积是矩阵的克罗内克积的特殊情况。<br>&emsp;&emsp;给定$m \times 1$列向量$\vec{u}$和$1 \times n$行向量$\vec{v}$，它们的外积$\vec{u} \otimes \vec{v}$被定义为$m \times n$矩阵$\mathbf{A}$，结果出自</p><script type="math/tex; mode=display">\vec{u} \otimes \vec{v} = \mathbf{A} = \vec{u}\ \vec{v}</script><p>这里的张量积就是向量的乘法。<br><strong>例子：</strong></p><script type="math/tex; mode=display">\vec{b} \otimes \vec{a} \rightarrow\begin{bmatrix}b_1 \\ b_2 \\ b_3 \\ b_4\end{bmatrix}  \begin{bmatrix}a_1 & a_2 & a_3\end{bmatrix} = \begin{bmatrix}a_1b_1 & a_2b_1 & a_3b_1 \\ a_1b_2 & a_2b_2 & a_3b_2 \\ a_1b_3 & a_2b_3 & a_3b_3 \\ a_1b_4 & a_2b_4 & a_3b_4\end{bmatrix}</script><p>&emsp;&emsp;结果的秩为1，结果的维数为 4×3 = 12。这里的秩指的是“张量秩”（所需指标数），而维数计算在结果数组(阵列)中自由度的数目。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近在学习 PyTorch 的时候，看到文档中计算两个向量的“outer product”后得到一个矩阵。我刚开始理所当然地把“outer product”理解为高中所学的外积，即叉积。但我越想越不对劲：两个向量的叉积不应该还是向量吗，怎么会叉出矩阵来呢？查了一波资料后发现这里的“outer product”不是叉积，而是张量积。&lt;br&gt;&amp;emsp;&amp;emsp;中文里的&lt;strong&gt;外积&lt;/strong&gt;一词常出现在代数、几何学等领域中。对两向量 $\vec{A}$ 与 $\vec{B}$ 而言，外积可指：&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;overflow: visible;&quot;&gt;&lt;strong&gt;叉积&lt;/strong&gt;（Cross product），又称&lt;strong&gt;向量积&lt;/strong&gt;（Vector product），常写为 $\vec{A}\times\vec{B}$；&lt;/li&gt;
&lt;li style=&quot;overflow: visible;&quot;&gt;&lt;strong&gt;楔积&lt;/strong&gt;（Wedge product 或 Exterior product），常写为 $\vec{A}\wedge\vec{B}$；&lt;/li&gt;
&lt;li style=&quot;overflow: visible;&quot;&gt;&lt;strong&gt;张量积&lt;/strong&gt;（Tensor product 或 Outer product），常写为 $\vec{A}\otimes\vec{B}$。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;上述三种都可称作外积，但含义却大相径庭，因此极易出现混淆，尤其是“exterior”和“outer”都有外面的意思，我发现网上许多文章甚至一些教科书中都出现了翻译、解释上的错误。我认为避免混淆的最好办法就是使用“叉积”、“向量积”、“楔积”、“张量积”这些没有歧义的词语，而避免使用“外积”一词。&lt;br&gt;&amp;emsp;&amp;emsp;下面是对几种外积概念的简要辨析。&lt;br&gt;
    
    </summary>
    
      <category term="学科" scheme="https://blog.pcninja.cn/categories/%E5%AD%A6%E7%A7%91/"/>
    
    
      <category term="数学" scheme="https://blog.pcninja.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="向量" scheme="https://blog.pcninja.cn/tags/%E5%90%91%E9%87%8F/"/>
    
      <category term="外积" scheme="https://blog.pcninja.cn/tags/%E5%A4%96%E7%A7%AF/"/>
    
      <category term="矩阵" scheme="https://blog.pcninja.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="线性代数" scheme="https://blog.pcninja.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="几何" scheme="https://blog.pcninja.cn/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>勇气的赞歌</title>
    <link href="https://blog.pcninja.cn/2020/02/the-paean-of-courage/"/>
    <id>https://blog.pcninja.cn/2020/02/the-paean-of-courage/</id>
    <published>2020-02-02T09:32:16.000Z</published>
    <updated>2020-02-03T05:15:27.983Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;截至2月2日24时，持续肆虐的2019-nCoV急性呼吸疾病已经确诊超过1.7万例，此外还有超过2.2万疑似病例和近19万密切接触者。自从疫情爆发以来，越来越多的恐慌、谣言、猜忌、不信任甚至谩骂充斥在社交网络。诚然，现在人民的爆发并不全是天灾造成的，而是更多的来自于从地方政府到中央政府的错误决策与丑闻。越是在这种政府公信力和民族凝聚力最脆弱的时候，故宫停车、人民日报带货、鄂A0260W、武汉红十字会阻拦央视记者一类的事件便越会被积怨已久的人们无限放大，并以此作为宣泄心中愤懑的对象。然而，当人们都沉浸在对丑恶的斥责中时，会不会忘记了世间仍然存在的美好，会不会忘记了此时此刻还有多少人在坚守自己的岗位。我想，赞美勇气，要远比抨击怯懦来得有意义。<br>&emsp;&emsp;刚刚看了回形针最新一期的视频<a href="https://www.bilibili.com/video/av86216616" target="_blank" rel="noopener">《关于新冠肺炎的一切》</a>，难能可贵的是，视频作者用客观的数据与文献资料向我们分析展示了关于此次疫情的真实信息。我在此对这些仍能保持冷静头脑的科普作者表示由衷的敬佩，并在下文引述视频中的一些内容，试图描绘此次疫情的大致轮廓。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/latest-animation.gif" title="2019-nCoV传播趋势（截至2月3日7时33分）"></div><a id="more"></a><blockquote><p>以下包含非原创内容</p></blockquote><h2 id="关于疫情的伊始"><a href="#关于疫情的伊始" class="headerlink" title="关于疫情的伊始"></a>关于疫情的伊始</h2><p>&emsp;&emsp;2019年12月8日，一位来自华南海鲜市场病人因为持续7天的发热、咳嗽和呼吸困难入院。5天后，他没有去过海鲜市场妻子也因为不明原因肺炎入院。<br>&emsp;&emsp;2020年1月1日，华南海鲜市场关闭。1月2日，41名新型肺炎患者被确诊。<br>&emsp;&emsp;此时喜迎新年的市民们还不知道，一场会感染上万人的瘟疫已经开始了。</p><h2 id="关于人传人"><a href="#关于人传人" class="headerlink" title="关于人传人"></a>关于人传人</h2><p>&emsp;&emsp;在1月24日发表于《柳叶刀》的论文《2019-nCoV感染患者的临床特征》（<a href="/2020/02/the-paean-of-courage/Clinical_features_of_patients_infected_with_2019_novel_coronavirus_in_Wuhan_China.pdf" title="下载">下载</a>）中，我们可以了解最早被确诊的 41 名患者的具体情况。<br>&emsp;&emsp;截至1月22日，41人中有28人出院，6人死亡。发烧和咳嗽是最常见的症状，从起病到呼吸困难，平均8天。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/1.png" title="2019-nCoV发病后时间线"></div><p>&emsp;&emsp;在肺炎初期，人传人的信号就已经很明显了，这41人中有14人都<strong>没有去过</strong>华南海鲜市场。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/2.png" title="14人无华南海鲜市场暴露史"></div><p>&emsp;&emsp;1月24日的另一篇论文《一场与2019年新型冠状病毒相关的家族肺炎表明了人与人之间的传播：家庭聚集研究》（<a href="/2020/02/the-paean-of-courage/A_familial_cluster_of_pneumonia_associated_with_the_2019_novel_coronavirus_indicating_person-to-person_transmission-_a_study_of_a_family_cluster.pdf" title="下载">下载</a>）研究了一个12月29前往在武汉旅行的深圳家庭。<br>&emsp;&emsp;最早出现症状的男士在到达武汉后的第4天开始发烧腹泻，之后3天，他的老婆岳父岳母和也都开始发烧咳嗽。1月5日，全家返回深圳，4天后，<strong>没有去过武汉</strong>的母亲开始全身乏力。最终，这个7口之家里，6人确诊新冠肺炎，包括他没有明显症状的儿子。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/3.png" title="深圳一家庭聚集传播案例"></div><p>&emsp;&emsp;1月30的论文《新型冠状病毒感染的肺炎在武汉的早期传播动态》（<a href="/2020/02/the-paean-of-courage/Early_Transmission_Dynamics_in_Wuhan_China_of_Novel_Coronavirus_Infected_Pneumonia.pdf" title="下载">下载</a>）进一步分析了武汉前425例确诊患者的数据。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/4.png" title="潜伏期分布"></div><p>&emsp;&emsp;这张表中，横坐标是从感染至发病的时间，纵坐标是相对概率。可以看到大部分感染者7天内就会发病，病毒的平均潜伏期是5.2天。<br>&emsp;&emsp;现在我们知道，在2020年1月11日之前确诊的295人里，<strong>只有45人去过华南海鲜市场，此外还有7名医护人员</strong>。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/5.png" title="多数患者与华南海鲜市场并无关联"></div><p>&emsp;&emsp;但在<strong>十天之后</strong>，人们才意识到要戴口罩了。</p><p><video src="/2020/02/the-paean-of-courage/video.mp4" width="500px" preload="preload" controls="controls"><br>您的浏览器不支持video标签。</video></p><p class="image-caption" style="padding-top: 15px;">1月20日晚，官方首次肯定人传人</p><h2 id="关于死亡率"><a href="#关于死亡率" class="headerlink" title="关于死亡率"></a>关于死亡率</h2><p>&emsp;&emsp;这是从1月16日到2月1日全中国累计确诊和死亡人数的增长曲线。如果我们用总死亡数除以总确诊数，可以得到一个2%左右的患病死亡率。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/6.png" title="确诊和死亡增长曲线（对数坐标）"></div><p>&emsp;&emsp;但这样的计算方式并不准确。根据前425名确诊患者的数据，我们可以知道病毒的平均潜伏期是5.2天，从发病到就诊平均是4.6天，就诊到入院平均4.5天，而入院到ICU是3.5天，假设从ICU到死亡是3天，整个过程就是21天左右。而如果就诊3天后就能确诊，那从确诊到死亡大概是8天。<br>&emsp;&emsp;所以，<strong>1月31号的死亡患者大概在1月23号确诊</strong>。如果我们用湖北省1月29日—1月31日这三天死亡的124人除以1月21日—1月23日确诊的279人的话，<strong>病死率高达44.4%</strong>。<br>&emsp;&emsp;但因为湖北省的医疗资源紧张确诊困难，很多老年病患发展到了重症才能确诊，病死率肯定偏高。相比之下，除湖北省外全国其他地区的数据更能反映真实情况。1月29日—1月31日，中国其他省份死亡患者共3人，除以1月21日—1月23日确诊的260人，病死率在1.1%左右，确实不高。<br>&emsp;&emsp;如果按照这个病死率倒推1月21日—1月23日的湖北感染者，那应该<strong>不是279人，而是10700人</strong>。<br>&emsp;&emsp;当然，这也只是一个非常粗糙的计算过程，样本量小，也不一定那么准确。但随着未来数据的完善，病死率的结果会越来越清晰。</p><h2 id="关于勇气"><a href="#关于勇气" class="headerlink" title="关于勇气"></a>关于勇气</h2><p>&emsp;&emsp;这场瘟疫让我们所有人精神紧张，但实际上，倒霉的事情每天都在发生。<br>&emsp;&emsp;过去几年，中国平均每年有8.8万人死于流感引发的呼吸系统疾病，6.3万人死于交通事故，3.8万人死于安全事故。只要我们迈出家门，去工地，去写字楼，去流水线，风险就已经存在了。<br>&emsp;&emsp;我们当然应该把倒霉的概率尽可能降低，<strong>但我们之所以赞颂勇气，是因为我们人类总是在明知风险的时候，仍然选择做我们该做的事情</strong>。</p><div class="image-size-50"><img src="/2020/02/the-paean-of-courage/7.jpeg" title="2019-nCoV电镜照片"></div><p>&emsp;&emsp;最后我们来看一眼这场肺炎的主角——这个直径在 0.1 微米左右的畸形圆球。可怕吗？我们已经知道了它的RNA序列、知道了它的感染机制、传播机制、临床表现和致死概率。其实也没那么吓人。<br>&emsp;&emsp;如果我们被这个吓到，吓到要锁死来自武汉的邻居，吓到要攻击陌生的求助者，吓到要<strong>以谣言的名义让大家不敢说话</strong>。那才是真的吓人。<br>&emsp;&emsp;<strong>人类的赞歌是勇气的赞歌</strong>，赞美所有还在认真工作的人们，希望新的一年，我们都能有更多勇气。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>&emsp;&emsp;惨象，已使我目不忍视了；流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵！不在沉默中爆发，就在沉默中灭亡。</p><p align="right">——鲁迅</p></blockquote><p>&emsp;&emsp;值得庆幸的是，我们的社会还没有到“不在沉默中爆发，就在沉默中灭亡”的地步。但是，在这次疫情中，人民的政府、人民的红十字会，或者说我们的政府、我们的红十字会，仿佛已然陷入了塔西佗陷阱的无尽深渊。<br>&emsp;&emsp;真正的人民政府不会允许官员全副武装却让医生手无寸铁，真正的红十字会也不会把人民的捐赠据为己有。人民永远是历史的创造者，当“人民政府”不再“人民”，当公权力开始丧失公信力之时，新的历史就会被人民书写。<br>&emsp;&emsp;五千年屹立不倒的中华民族不会消亡，会消亡的只有失信于民的政权。真诚希望如今这个延续了七十年的政权能够幡然悔悟，带领人民走向安宁与富足，不要再让我们回到鲁迅所处的那至暗时代了。<br>&emsp;&emsp;人类的赞歌是勇气的赞歌,人类的伟大是勇气的伟大。人们的勇气终将战胜疫情，希望这一天早日到来。最后，祝愿正笼罩在恐惧中的同胞幸福安康，向依然奋战在一线的医务工作者致以崇高的敬意。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;截至2月2日24时，持续肆虐的2019-nCoV急性呼吸疾病已经确诊超过1.7万例，此外还有超过2.2万疑似病例和近19万密切接触者。自从疫情爆发以来，越来越多的恐慌、谣言、猜忌、不信任甚至谩骂充斥在社交网络。诚然，现在人民的爆发并不全是天灾造成的，而是更多的来自于从地方政府到中央政府的错误决策与丑闻。越是在这种政府公信力和民族凝聚力最脆弱的时候，故宫停车、人民日报带货、鄂A0260W、武汉红十字会阻拦央视记者一类的事件便越会被积怨已久的人们无限放大，并以此作为宣泄心中愤懑的对象。然而，当人们都沉浸在对丑恶的斥责中时，会不会忘记了世间仍然存在的美好，会不会忘记了此时此刻还有多少人在坚守自己的岗位。我想，赞美勇气，要远比抨击怯懦来得有意义。&lt;br&gt;&amp;emsp;&amp;emsp;刚刚看了回形针最新一期的视频&lt;a href=&quot;https://www.bilibili.com/video/av86216616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《关于新冠肺炎的一切》&lt;/a&gt;，难能可贵的是，视频作者用客观的数据与文献资料向我们分析展示了关于此次疫情的真实信息。我在此对这些仍能保持冷静头脑的科普作者表示由衷的敬佩，并在下文引述视频中的一些内容，试图描绘此次疫情的大致轮廓。&lt;/p&gt;
&lt;div class=&quot;image-size-50&quot;&gt;&lt;img src=&quot;/2020/02/the-paean-of-courage/latest-animation.gif&quot; title=&quot;2019-nCoV传播趋势（截至2月3日7时33分）&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他" scheme="https://blog.pcninja.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="疫情" scheme="https://blog.pcninja.cn/tags/%E7%96%AB%E6%83%85/"/>
    
      <category term="死亡" scheme="https://blog.pcninja.cn/tags/%E6%AD%BB%E4%BA%A1/"/>
    
      <category term="勇气" scheme="https://blog.pcninja.cn/tags/%E5%8B%87%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>【备忘】 youtube-dl使用方法</title>
    <link href="https://blog.pcninja.cn/2020/02/usage-of-youtube-dl/"/>
    <id>https://blog.pcninja.cn/2020/02/usage-of-youtube-dl/</id>
    <published>2020-02-01T12:15:23.000Z</published>
    <updated>2020-02-01T13:29:05.869Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;youtube-dl是一个Python编写的开源的音视频下载工具，只支持命令行操作。虽然名为youtube-dl，但它支持的站点非常多，包括了诸多国内外知名的音视频网站（<a href="https://github.com/ytdl-org/youtube-dl/blob/master/docs/supportedsites.md" target="_blank" rel="noopener">查看完整的支持列表</a>）。由于指令较多，容易忘记，故将常用的指令记录在此，以备不时之需。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方GitHub仓库地址：<a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener">https://github.com/ytdl-org/youtube-dl</a><br>Windows下可以在releases页面找到最新发布版并直接下载<code>youtube-dl.exe</code>即可使用，更新方法如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl -U</span><br></pre></td></tr></table></figure></p><p>Linux下可以通过<code>pip</code>安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install youtube-dl           # 安装</span><br><span class="line">pip uninstall youtube-dl         # 卸载</span><br><span class="line">pip install --upgrade youtube-dl # 更新</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>完整的指令列表和参数说明请见GitHub仓库里的官方文档，这里只记录最常用到的音视频下载指令<br>由于众所周知的原因，大多数情况下都需要使用代理下载YouTube上的内容，因此下面所有指令都加上了<code>--proxy socks5://127.0.0.1:1080/</code>，即通过socks5协议的本地代理下载，记得挂上梯子并开启本地端口</p><ul><li>列出所有可用的音视频格式<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -F [url]</span><br></pre></td></tr></table></figure></li></ul><p><div class="image-size-50"><img src="/2020/02/usage-of-youtube-dl/image.png" title="可用列表"></div><br>可以看到程序列出了该资源每个可用项的格式码、扩展名以及说明，其中包括<code>audio only</code>和<code>video only</code></p><ul><li><p>通过指定格式码下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f [format code] [url]</span><br></pre></td></tr></table></figure></li><li><p>下载纯音频至指定格式（需ffmpeg）<br>需要保证ffmpeg在环境变量中或者与youtube-dl在同一目录才可正常转码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -x --audio-format mp3 [url]</span><br></pre></td></tr></table></figure></li></ul><p>该指令可以下载音频并通过ffmpeg转至mp3格式，仅保留<code>-x</code>参数可以不转格式</p><ul><li>下载最佳质量的音视频<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载最佳质量的音视频格式</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f best [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载最佳质量的仅视频格式</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestvideo [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载最佳质量的仅音频格式</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestaudio [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别下载最高质量的仅视频和最高质量的仅音频格式，再用ffmpeg合并成一个最佳质量的mkv文件</span></span><br><span class="line">youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestvideo+bestaudio [url]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;youtube-dl是一个Python编写的开源的音视频下载工具，只支持命令行操作。虽然名为youtube-dl，但它支持的站点非常多，包括了诸多国内外知名的音视频网站（&lt;a href=&quot;https://github.com/ytdl-org/youtube-dl/blob/master/docs/supportedsites.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;查看完整的支持列表&lt;/a&gt;）。由于指令较多，容易忘记，故将常用的指令记录在此，以备不时之需。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://blog.pcninja.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="下载" scheme="https://blog.pcninja.cn/tags/%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="工具" scheme="https://blog.pcninja.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="视频" scheme="https://blog.pcninja.cn/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="YouTube" scheme="https://blog.pcninja.cn/tags/YouTube/"/>
    
  </entry>
  
  <entry>
    <title>除夕夜小记</title>
    <link href="https://blog.pcninja.cn/2020/01/happy-chinese-new-year-2020/"/>
    <id>https://blog.pcninja.cn/2020/01/happy-chinese-new-year-2020/</id>
    <published>2020-01-24T15:00:11.000Z</published>
    <updated>2020-01-24T15:36:39.081Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;除夕夜，万家灯火，十四亿华人共同迎接庚子年的到来。<br><a id="more"></a><br>&emsp;&emsp;这个新年并不太平，刚一进入2020年，中华民族的儿女就历经了巨大挑战：</p><ul><li>1月11日，蔡英文以史无前例的得票数连任台湾地区领导人，两岸关系不知将何去何从</li><li>1月16日，中美第一阶段经贸协议的签署让中国蒙受巨大损失，为即将打响的科技战、金融战埋下巨大隐患</li><li>1月23日，武汉封城，却难以阻止2019-nCoV在全国范围内大规模爆发，无人知晓真实的感染情况，无人知晓最终会付出多大的代价……</li></ul><p>&emsp;&emsp;2020年，无论是国家命运，亦或是每一个国民的命运，都将注定不凡。真诚祝愿中华民族能够“风雨压不垮，苦难中开花”，继续屹立在世界东方。<br>&emsp;&emsp;<strong>天佑中华！</strong></p><p></p><p align="right">己亥年除夕于家中</p><p></p><div class="image-size-50"><img src="/2020/01/happy-chinese-new-year-2020/image.png" title="鼠年快乐"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;除夕夜，万家灯火，十四亿华人共同迎接庚子年的到来。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://blog.pcninja.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="https://blog.pcninja.cn/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="https://blog.pcninja.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="新年" scheme="https://blog.pcninja.cn/tags/%E6%96%B0%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>辩证法三大规律在生活中的体现</title>
    <link href="https://blog.pcninja.cn/2019/12/embodiment-of-three-laws-of-dialectics-in-life/"/>
    <id>https://blog.pcninja.cn/2019/12/embodiment-of-three-laws-of-dialectics-in-life/</id>
    <published>2019-12-22T15:33:59.000Z</published>
    <updated>2020-03-17T13:16:52.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二上学期《马克思主义基本原理概论》实践环节报告</p></blockquote><p>&emsp;&emsp;在本学期的《马克思主义基本原理概论》课堂上，我对辩证法及其三大规律即对立统一规律、量变质变规律和否定之否定规律有了系统的学习。为了对其有更为深刻的认识与理解，我尝试运用这三大规律来解释日常生活中的问题。以下我将分三个部分，分别阐述我在生活中对对立统一规律、量变质变规律和否定之否定规律的体会与感悟。<a id="more"></a><br><strong>一、生活中的对立统一规律</strong><br>&emsp;&emsp;对立统一规律作为唯物辩证法的实质和核心，在生活的各个角落都体现得淋漓尽致。例如平时我们在打篮球时，往往会遇到在攻守两端的体能分配问题：当我们在进攻端投入太多精力时，防守就会出现注意力不集中、漏人等情况；反之，若将重心放在防守上，那么进攻时就会出现体力不支、命中率下降的弊端。这告诉我们事物内部以及事物之间都包含着矛盾，即矛盾具有普遍性。<br>&emsp;&emsp;除此以外，攻与守互为对立面，二者相互排斥、相互分离，体现着矛盾的斗争性；而攻与守又相互依存，在比赛中处于一个矛盾统一体中，因而出现所谓“以攻代守”、“防守带动进攻”等战术思想，体现了矛盾的同一性。攻守这对矛盾的同一性与斗争性共同作用在事物的发展即比赛的进程上，矛盾的两个对立面由于同一性和斗争性而相互转化，只有当攻守这对矛盾平衡、协调时事物才展现出和谐状态，球队才可能取胜。<br>&emsp;&emsp;对立统一规律还体现在我们生病时吃药中，众所周知，大多数药物在帮助治疗疾病的同时，往往还伴随着或多或少的副作用，使我们出现不良反应。药物的正作用与副作用便构成了一对矛盾统一体。对立统一规律教导我们要把握主要矛盾和矛盾的主要方面，因此需要综合考量药物的治疗作用与副作用，判断其治疗作用带来的利与副作用带来的弊孰大孰小，当利大于弊时，医生或药师就会让我们服药，并且严格控制剂量以寻求矛盾的平衡。<br>&emsp;&emsp;在生活中，我们应该学会用对立统一的眼光看待每一件事物，发现其内在的矛盾，坚持“两点论”和“重点论”的统一，这样我们才会对我们所处的这个世界有更为透彻的认识。<br><strong>二、生活中的量变质变规律</strong><br>&emsp;&emsp;量变和质变是事物变化的两种基本状态和形式，它们间的相互作用、相互转化在日常生活中极其常见，举一个最简单的例子：用水杯接水，在杯子满之前，杯内水的体积连续增加，属于持续的量变，当杯满的瞬间，其状态就会发生质变，即水开始溢出。这个质变的过程标志着水杯的状态阶段的更替，即由接水阶段更替为溢水阶段，这就是为什么说量变质变规律指出了连续性与阶段性的统一。<br>&emsp;&emsp;除了接水，生活中处处体现着量变质变的规律。上学以来，许多老师都曾教导过我们要注重平时的积累，不论是英文单词的积累、诗词歌赋的积累，还是如今对代码量的积累，都是为了在相应领域的水平能够从量变到质变。<br>&emsp;&emsp;量变和质变的辩证关系告诉我们量变是质变的必要准备。诚然，如果没有对英文单词的大量积累，我们就不可能读懂英文前沿期刊上的长篇大论；如果没有对诗词歌赋的大量背诵，就不会有“腹有诗书气自华”的精神风骨；如果没有对各类数据结构与算法的大量代码书写，就不可能在大型项目工程中熟练地运用各种算法并有效率地写出优质代码。这些积累就好比摩天大楼的根基，它们的必要性不言而喻。<br>&emsp;&emsp;量变和质变的辩证关系还告诉我们质变是量变的必然结果。所以说，当一个人能够坚持一个好习惯足够长时间，这个好习惯最终注定会让他受益；同理，当一个人迟迟不肯改正他的坏习惯，那么这个坏习惯最终同样会给他烙上深深的烙印。因此量变质变规律教导我们，要坚持优良习惯，追求量变向质变的转化，同时要及时摒弃不良习惯，以防量变转向质变。<br><strong>三、生活中的否定之否定规律</strong><br>&emsp;&emsp;我们时常听到诸如“前途是光明的,道路是曲折的”一类的话语，其中就蕴含着否定之否定规律所揭示的事物发展的前进性与曲折性的统一。<br>&emsp;&emsp;提到一规律时，我想最为人熟知的就是由地心说到日心说到现代天文学的曲折发展历程，在此我不想赘述。作为计算机科学与技术专业的本科生，适逢本学期学习了《计算机组成原理》一课，我想用否定之否定规律对CPU控制器的演进历程做出解读：在早期计算机中，由于逻辑功能简单，电路并不复杂，因此多采用硬布线控制器的设计，这就是第一阶段——肯定阶段；随着人们对计算机的功能需求不断增多以及复杂指令集的出现，若沿用硬布线控制器，则电路将十分复杂，因此人们摒弃了难以实现的硬布线控制器，设计了牺牲效率但电路简单的微程序控制器，这是第二阶段——否定阶段；如今，芯片制造技术极其成熟，生产复杂的硬布线控制器已不再是难事，故追求极致效率的人们便否定了效率低下的微程序控制器，重新采用硬布线控制器，这便是第三阶段——否定之否定。由此可见CPU控制器的演化并不是一帆风顺的，而是不断对此前的缺陷进行否定，螺旋式上升，很好的体现了事物发展的前进性与曲折性。<br>&emsp;&emsp;其实，在我们的身边一样能找到类似的事情。比如，若我们闷头读书，只注重理论学习，那么在实践操作时我们就会束手无策，于是我们对此前的做法进行了否定，开始投入实践，尝试新鲜技术，减少理论学习；然而缺少了理论的支撑，我们对新生技术的原理就会感到茫然，无法透彻理解，因此我们需要进行否定之否定，做到理论与实践并重。<br>&emsp;&emsp;由此可见，辩证法的三大规律体现在我们日常生活中的方方面面，很多实际问题都可以运用这三大规律进行很好地解释。通过这段时间的实践，我逐渐感受到对立统一规律、量变质变规律和否定之否定规律不但可以帮助我们解释问题，还对我们的学习生活有着很强的指导作用，让我们的行为更具智慧。在今后的生活中，我们需要勤于思考，时刻按辩证法所教导我们的规律行事，不要违背客观规律，否则只会与成功渐行渐远。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大二上学期《马克思主义基本原理概论》实践环节报告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在本学期的《马克思主义基本原理概论》课堂上，我对辩证法及其三大规律即对立统一规律、量变质变规律和否定之否定规律有了系统的学习。为了对其有更为深刻的认识与理解，我尝试运用这三大规律来解释日常生活中的问题。以下我将分三个部分，分别阐述我在生活中对对立统一规律、量变质变规律和否定之否定规律的体会与感悟。
    
    </summary>
    
      <category term="文学" scheme="https://blog.pcninja.cn/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="写作" scheme="https://blog.pcninja.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="辩证法" scheme="https://blog.pcninja.cn/tags/%E8%BE%A9%E8%AF%81%E6%B3%95/"/>
    
      <category term="马克思主义" scheme="https://blog.pcninja.cn/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>为什么人类命运共同体理念产生了广泛而深远的国际影响？</title>
    <link href="https://blog.pcninja.cn/2019/11/the-international-influence-of-the-concept-of-a-community-of-shared-future-for-mankind/"/>
    <id>https://blog.pcninja.cn/2019/11/the-international-influence-of-the-concept-of-a-community-of-shared-future-for-mankind/</id>
    <published>2019-11-09T15:23:13.000Z</published>
    <updated>2020-03-17T12:42:37.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二上学期《形式与政策》论文</p></blockquote><p>&emsp;&emsp;自党的十八大习近平总书记首次提出人类命运共同体理念以来，这一追求共同发展的价值观越来越被国际社会所接受。中国也不断提出构建人类命运共同体的中国方案，贡献着中国智慧。我认为，之所以人类命运共同体理念能够产生如此广泛而深远的国际影响，是因为这个价值理念维护着全世界人民的共同利益，能够兼容不同文化、不同种族的人民的价值理念。<a id="more"></a><br>&emsp;&emsp;我认为，“人类命运共同体”不是哪一个人、哪一政党或是哪一国家的专利，而是一个客观存在的事实，全人类本就是一个“一荣俱荣，一损俱损”的命运共同体。纵观地球46亿年的浩瀚历史，人类的发展仅仅持续了不过15万年，因此人类文明的存在对于我们的家园——地球来说，只是弹指一挥间。我们主宰不了地球的命运，我们能够左右的，只有我们人类自己的命运。生存是文明的第一需要，人类利益远高于国家利益或是个人利益，因为当人类的共同利益即生存需要受到威胁时，国家间的较量、个人的财富和社会地位也就变得毫无意义。然而此时此刻，我们的生存正受到威胁，领土争端、民族宗教矛盾、恐怖袭击等事件时刻破坏着世界人民的安全与秩序，对地球资源的过度开发、碳排放的持续增加、核武器的扩散更是让人类愈发接近毁灭的边缘。<br>&emsp;&emsp;要想捍卫全人类的共同利益，必须各个国家通力合作、达成共识，在追求自身利益的同时兼顾他国利益，时刻站在全人类的共同立场，与地球上的人民同呼吸、共命运。尤其是大国，更应该站在更高的角度审视问题，因为能够主宰人类命运的往往正是世界当中的强权。正如1962年的古巴导弹危机，美苏两国的军备竞赛把全人类推向了毁灭的边缘，国家间的不正当竞争险些让千年人类文明付之一炬。如今两极格局的世界已不复存在，但热核战争的威胁依旧笼罩在全世界人民头上，在朝核、伊核问题上，中国坚持倡导以对话、谈判的方式解决争端，在维护地区和平稳定方面贡献了自己的力量，体现出了大国外交的国际责任感。<br>&emsp;&emsp;我认为，中国首先提出人类命运共同体理论，是中国和平崛起的象征，体现了我国的大国担当与大国责任。在当今世界多极化、经济全球化的趋势下，有更多的国家需要承担起维护人类共同利益的责任与使命，在这一方面，中国起到了很好的表率作用。在博鳌亚洲论坛、联合国大会、“一带一路”国际合作高峰论坛、二十国集团领导人峰会等国际会议上，我国多次向全世界发出构建人类命运共同体的倡议，并不断传达中国理念、提出中国方案。此外，中国身体力行，在经济、文化、教育、环境等诸多领域都为全世界做出了重大贡献，我们摒弃冷战思维的零和博弈，倡导互利共赢，“一带一路”建设为人类创造了巨大利益，是人类命运共同体理念的最好表现。<br>&emsp;&emsp;中国从来没有像今天这样接近世界舞台中心, 从来没有像今天这样全方位影响世界。如今的中国，正在成为构建人类命运共同体的倡导者、实践者、先行者, 不断为人类做出更大贡献。正是因为符合全人类的价值理念、保障全人类的切身利益，人类命运共同体理念才会产生如此广泛而深远的国际影响。我相信世界各国会同中国一道，用互利共赢取代零和博弈，为全人类谋福祉，实现共同繁荣的“世界梦”。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大二上学期《形式与政策》论文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;自党的十八大习近平总书记首次提出人类命运共同体理念以来，这一追求共同发展的价值观越来越被国际社会所接受。中国也不断提出构建人类命运共同体的中国方案，贡献着中国智慧。我认为，之所以人类命运共同体理念能够产生如此广泛而深远的国际影响，是因为这个价值理念维护着全世界人民的共同利益，能够兼容不同文化、不同种族的人民的价值理念。
    
    </summary>
    
      <category term="文学" scheme="https://blog.pcninja.cn/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="写作" scheme="https://blog.pcninja.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="形式与政策" scheme="https://blog.pcninja.cn/tags/%E5%BD%A2%E5%BC%8F%E4%B8%8E%E6%94%BF%E7%AD%96/"/>
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="人类命运共同体" scheme="https://blog.pcninja.cn/tags/%E4%BA%BA%E7%B1%BB%E5%91%BD%E8%BF%90%E5%85%B1%E5%90%8C%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>我与共和国共成长</title>
    <link href="https://blog.pcninja.cn/2019/10/I-grow-with-the-Republic/"/>
    <id>https://blog.pcninja.cn/2019/10/I-grow-with-the-Republic/</id>
    <published>2019-10-30T07:18:01.000Z</published>
    <updated>2020-03-17T13:09:55.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二上学期《马克思主义基本原理概论》实践环节报告<br>注：虽然是为了完成作业，但参加这次大典我确实感触颇多，此次经历真的胜过千百次爱国主义教育，令人记忆深刻，因此这篇文章具有一定纪念意义。</p><div class="image-size-30"><img src="/2019/10/I-grow-with-the-Republic/image.jpg" title="游行归来，不能自已"></div></blockquote><p>&emsp;&emsp;“今天是你的生日，我的中国。清晨我放飞一群白鸽，为你衔来一枚橄榄叶，鸽子在崇山峻岭飞过。”当童声演唱的《今天是你的生日》打破长安街清晨的寂静，仿佛有一股电流瞬间穿过我的脊背，使原本睡眼惺忪的我不禁颤栗，泪珠在眼眶中打转。这是我由衷地为祖国母亲感到动容，因为我深深地知道，我的祖国七十年一路走来，经历了什么样的惊涛骇浪，克服了什么样的艰难险阻。我想，只有了解了新中国走到今天的不易，才会发自肺腑地为之献上最美好的祝福，才会从心底里说出那句“我爱你，中国”。<a id="more"></a><br>&emsp;&emsp;直到此时回顾参加群众游行的经历，我仍心潮澎湃。我们数十天的训练，为的是向全世界展示当代中国青年的朝气蓬勃，为的是向全世界展示中国人民群众强大的凝聚力。能够有幸成为十四亿中华儿女的代表，我感到无比荣幸与自豪。在10月1日的正义路上，我们聆听了习近平主席在庆祝中华人民共和国成立70周年大会上的讲话，其中讲到：“今天，社会主义中国巍然屹立在世界东方，没有任何力量能够撼动我们伟大祖国的地位，没有任何力量能够阻挡中国人民和中华民族的前进步伐”<sup>[1]</sup>，我相信我身边的每个人听到这里都像我一样慷慨激昂，这种空前的民族自豪感，是新中国从站起来富起来到强起来的最好印证。<br>&emsp;&emsp;随着分列式的开始，我们涌入长安街两侧，坦克、装甲车的轰鸣声充斥着我的双耳，雄壮威武的武器装备从我眼前缓缓经过。难以想象无侦-8、攻击-11、东风-17、东风-41等最先进的国防重器竟距离我不足10米远。我想，这种场景所带来的震撼，远比任何爱国主义教育都要来得实在。新中国国防实力的提升一举改变了近代中国落后挨打的局面，也使中国人有底气屹立在世界民族之林。<br>&emsp;&emsp;当《红旗颂》奏响，“致敬”方阵的礼宾车从我面前驶过，大家情不自禁地向车上的新中国缔造者亲属、老红军、老八路军、老解放军挥动五星红旗。他们为了民族独立和人民幸福做出了卓著贡献，铸就了坚强不屈的民族脊梁，他们值得接受我们每一名中国人向他们的致敬。<br>&emsp;&emsp;走在“一国两制”方阵里，我们挥舞旗帜，欢呼致意。当我们经过天安门前，我向左望去，看到孙中山先生凝望着广场，这位革命的先行者曾经奋力让黑暗的中国走向黎明；我又向右望去，看到毛泽东主席注视着广场，这位开国领袖让沉睡的东方雄狮昂起了头颅。我们每一个人高喊“祖国我爱你”，喊出的不光是我们自己的心声，更代表了包含港澳台同胞在内的十四亿中华儿女的心声。我坚信，在“一国两制”伟大构想的框架下，香港明天会更好，澳门明天会更好，祖国统一大业也终将实现。<br>&emsp;&emsp;在我回看这次庆祝大会的时候，一句解说词让我久久不能忘怀：“今天的天安门广场是世界瞩目的中心，今天的中国正前所未有的靠近世界舞台中心。”诚然，中国正以和平崛起的方式，悄然走向世界的中心。回望我与共和国共同走过的这十九年，我见证了中国加入世界贸易组织，见证了一届难以超越的奥运会，见证了诺贝尔文学奖和诺贝尔生理学或医学奖花落神州大地，见证了北京的“APEC蓝”，见证了G20峰会的“最忆是杭州”，见证了世界第二大经济体之名的易主，这些都是中国一步步迈向世界舞台中心所留下的坚实脚印。<br>&emsp;&emsp;中国的和平崛起必将经历艰难险阻的考验，当今的中国，正面临着前所未有的巨大挑战。对外，在美国坚持奉行单边主义、贸然向中国挑起“贸易战”的情形下，需要我们众志成城、共同面对，同时坚持以和平谈判的方式解决争端；对内，香港“反送中”运动的延烧仍需林郑政府在“一国两制”的框架下提出一个智慧的解决方案，台湾问题同样要求双方领导集团运用各自的大智慧，以政治谈判的方式共同推进和平统一进程。诚然，当下的形势是严峻的，但这也是复兴之路上我们不得不面对的挑战。<br>&emsp;&emsp;面对挑战，需要我们青年一代做出自己的贡献。经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位<sup>[2]</sup>。随着我阅历的增长与思想认识的不断深化，我愈发意识到自己处在这个令我心潮澎湃的“黄金时代”：我今年19岁，到2035年社会主义现代化基本实现时，还不到40岁；到本世纪中叶全面建成社会主义现代化强国时，刚刚50岁。我将有幸成为民族复兴伟大进程的见证者与亲历者，但是，我更想成为开创者与建设者。我深知，如今的青春中国风华正茂，民族复兴的梦想正由我们去实现。为此，需要我继续加强理论知识学习，增强自身能力，在学校、社会中起积极带头作用，用自己的奋斗走好我们这一代人的新长征。<br>&emsp;&emsp;共和国见证着我的成长，我也见证着共和国一步步走向强盛。在接下来的漫长道路上，我与共和国仍将继续披荆斩棘，共同成长，向民族复兴的共同目标不断迈进。祝福我与共和国的明天更加灿烂辉煌！</p><p><strong>参考文献：</strong><br><small>&emsp;&emsp;[1]习近平.在庆祝中华人民共和国成立70周年大会上的讲话[M].人民出版社:北京,2019:1.<br>&emsp;&emsp;[2]习近平.决胜全面建成小康社会夺取新时代中国特色社会主义伟大胜利——在中国共产党第十九次全国代表大会上的报告[M].人民出版社:北京,2017:1.</small></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大二上学期《马克思主义基本原理概论》实践环节报告&lt;br&gt;注：虽然是为了完成作业，但参加这次大典我确实感触颇多，此次经历真的胜过千百次爱国主义教育，令人记忆深刻，因此这篇文章具有一定纪念意义。&lt;/p&gt;
&lt;div class=&quot;image-size-30&quot;&gt;&lt;img src=&quot;/2019/10/I-grow-with-the-Republic/image.jpg&quot; title=&quot;游行归来，不能自已&quot;&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;“今天是你的生日，我的中国。清晨我放飞一群白鸽，为你衔来一枚橄榄叶，鸽子在崇山峻岭飞过。”当童声演唱的《今天是你的生日》打破长安街清晨的寂静，仿佛有一股电流瞬间穿过我的脊背，使原本睡眼惺忪的我不禁颤栗，泪珠在眼眶中打转。这是我由衷地为祖国母亲感到动容，因为我深深地知道，我的祖国七十年一路走来，经历了什么样的惊涛骇浪，克服了什么样的艰难险阻。我想，只有了解了新中国走到今天的不易，才会发自肺腑地为之献上最美好的祝福，才会从心底里说出那句“我爱你，中国”。
    
    </summary>
    
      <category term="文学" scheme="https://blog.pcninja.cn/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="写作" scheme="https://blog.pcninja.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="国庆" scheme="https://blog.pcninja.cn/tags/%E5%9B%BD%E5%BA%86/"/>
    
      <category term="群众游行" scheme="https://blog.pcninja.cn/tags/%E7%BE%A4%E4%BC%97%E6%B8%B8%E8%A1%8C/"/>
    
      <category term="爱国" scheme="https://blog.pcninja.cn/tags/%E7%88%B1%E5%9B%BD/"/>
    
  </entry>
  
  <entry>
    <title>【音乐】庆祝中华人民共和国成立70周年阅兵式军乐欣赏</title>
    <link href="https://blog.pcninja.cn/2019/10/the-military-music-of-the-parade/"/>
    <id>https://blog.pcninja.cn/2019/10/the-military-music-of-the-parade/</id>
    <published>2019-10-03T12:12:54.000Z</published>
    <updated>2020-04-06T08:36:16.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://pcninja.cn/player" target="_blank" rel="noopener">点击进入播放器</a></p></blockquote><ul><li><strong>《钢铁洪流进行曲》</strong> - 中国人民解放军联合军乐团</li><li><strong>《东风浩荡进行曲》</strong> - 中国人民解放军联合军乐团</li><li><strong>《雄鹰出击进行曲》</strong> - 中国人民解放军联合军乐团</li><li><strong>《冲上云霄》</strong> - 中国人民解放军联合军乐团</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pcninja.cn/player&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击进入播放器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;《钢铁洪流进行曲》&lt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blog.pcninja.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="军乐" scheme="https://blog.pcninja.cn/tags/%E5%86%9B%E4%B9%90/"/>
    
      <category term="交响乐" scheme="https://blog.pcninja.cn/tags/%E4%BA%A4%E5%93%8D%E4%B9%90/"/>
    
      <category term="阅兵" scheme="https://blog.pcninja.cn/tags/%E9%98%85%E5%85%B5/"/>
    
  </entry>
  
  <entry>
    <title>暑假小结</title>
    <link href="https://blog.pcninja.cn/2019/08/summer-vacation-summary/"/>
    <id>https://blog.pcninja.cn/2019/08/summer-vacation-summary/</id>
    <published>2019-08-30T14:15:17.000Z</published>
    <updated>2019-08-30T14:30:31.284Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;此时此刻，窗外不断传来大一新生军训中演讲比赛的激昂呐喊。新鲜血液的涌入着实给了我一种紧迫感，回想一年前，我也和他们一样，刚刚踏入大学的校门，心中有憧憬也有迷茫。转眼一年过去了，仿佛憧憬与迷惘都变多了。<br>&emsp;&emsp;从7月13号到今天，一个半月的暑假已接近尾声。其实这个暑假做的事有限，掰着手指头数都能数的过来，所以本来没想写这个总结。但思前想后觉得还是应该简要记录一下，也算是警醒自己今后要做更多有意义的事。<a id="more"></a><br>&emsp;&emsp;文字能力有限，依旧是流水账。<br>&emsp;&emsp;小学期里，我们的任务是完成“外卖派单模拟系统”，这是我第一次着手这种具有一定规模的项目，项目需求与规则繁杂且模糊，并且几经修改，最要命的是在7月13号验收的前一天傍晚被要求新增不少功能，所有人都很无奈。好在经历了几天几夜的爆肝之后，顺利完成了验收。最终，我们花大量精力研究的算法在所有组的比拼中喜提头名，可喜可贺。然而看了别的组华丽的GUI之后我们才意识到我们在用户体验上所做的工作确实有些简陋，不过这也是在时间紧迫的前提下所做出的必然取舍，因为在我们看来，相比于图形界面，算法是我们更应该投入精力去琢磨的地方。<br>&emsp;&emsp;暑假伊始，由于刚刚结束了小学期的项目，有些身心俱疲，所以没干什么正事。唯一做的就是 Express + EJS + ajax + MongoDB 写了一个 ToDo List，顺带学到了些前端知识。到了七月底回到学校，参加某大型红色活动的训练，为期二十余天，除了太阳晒点，还是比较轻松欢愉的。训练之余，在宿舍学习了 Docker，并尝试把我所有的站点和服务进行容器化，不过目前还只是在虚拟机上，没有上线。等过段时间域名完成备案，可以A记录解析到服务器上之后应该就可以享受 <code>docker-compose up -d</code> 一键部署的快感了😝。<br>&emsp;&emsp;在此之后训练任务断断续续，我的暑假生活也以娱乐为主，通关了老早以前搁下的弹丸论破1和2，没事就和舍友开黑GTAOL，还是挺轻松加写意的。<br>&emsp;&emsp;总的来说这个暑假过得很快活，但有意义的事做得不多，换句话说，有点浪费。不过这一切都是我自己的选择，也不会后悔。期待下学期的学习生活，也期待十月一号能够用最好的表现为祖国母亲七十华诞献礼！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;此时此刻，窗外不断传来大一新生军训中演讲比赛的激昂呐喊。新鲜血液的涌入着实给了我一种紧迫感，回想一年前，我也和他们一样，刚刚踏入大学的校门，心中有憧憬也有迷茫。转眼一年过去了，仿佛憧憬与迷惘都变多了。&lt;br&gt;&amp;emsp;&amp;emsp;从7月13号到今天，一个半月的暑假已接近尾声。其实这个暑假做的事有限，掰着手指头数都能数的过来，所以本来没想写这个总结。但思前想后觉得还是应该简要记录一下，也算是警醒自己今后要做更多有意义的事。
    
    </summary>
    
      <category term="生活" scheme="https://blog.pcninja.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="日记" scheme="https://blog.pcninja.cn/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>中文文案排版指北</title>
    <link href="https://blog.pcninja.cn/2019/08/chinese-copywriting-guidelines/"/>
    <id>https://blog.pcninja.cn/2019/08/chinese-copywriting-guidelines/</id>
    <published>2019-08-19T14:32:27.000Z</published>
    <updated>2019-08-19T14:37:29.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/sparanoid/chinese-copywriting-guidelines</a></p></blockquote><h1 id="中文文案排版指北"><a href="#中文文案排版指北" class="headerlink" title="中文文案排版指北"></a>中文文案排版指北</h1><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。 毕竟爱情跟书写都需要适时地留白。</p><p>与大家共勉之。」——<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></p><h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。<br><a id="more"></a></p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a href="#数字与单位之间需要增加空格" class="headerlink" title="数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h3 id="用-text-spacing-来挽救？"><a href="#用-text-spacing-来挽救？" class="headerlink" title="用 text-spacing 来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h3><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property" target="_blank" rel="noopener"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85" target="_blank" rel="noopener"><code>-ms-text-autospace</code></a>.aspx) 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a href="#不重复使用标点符号" class="headerlink" title="不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2" target="_blank" rel="noopener">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其内容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a href="#简体中文使用直角引号" class="headerlink" title="简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://github.com/sparanoid/chinese-copywriting-guidelines&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sparanoid/chinese-copywriting-guidelines&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;中文文案排版指北&quot;&gt;&lt;a href=&quot;#中文文案排版指北&quot; class=&quot;headerlink&quot; title=&quot;中文文案排版指北&quot;&gt;&lt;/a&gt;中文文案排版指北&lt;/h1&gt;&lt;h2 id=&quot;空格&quot;&gt;&lt;a href=&quot;#空格&quot; class=&quot;headerlink&quot; title=&quot;空格&quot;&gt;&lt;/a&gt;空格&lt;/h2&gt;&lt;p&gt;「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。 毕竟爱情跟书写都需要适时地留白。&lt;/p&gt;
&lt;p&gt;与大家共勉之。」——&lt;a href=&quot;https://github.com/vinta/pangu.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vinta/paranoid-auto-spacing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;中英文之间需要增加空格&quot;&gt;&lt;a href=&quot;#中英文之间需要增加空格&quot; class=&quot;headerlink&quot; title=&quot;中英文之间需要增加空格&quot;&gt;&lt;/a&gt;中英文之间需要增加空格&lt;/h3&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 LeanCloud 上，数据存储是围绕 &lt;code&gt;AVObject&lt;/code&gt; 进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在LeanCloud上，数据存储是围绕&lt;code&gt;AVObject&lt;/code&gt;进行的。&lt;/p&gt;
&lt;p&gt;在 LeanCloud上，数据存储是围绕&lt;code&gt;AVObject&lt;/code&gt; 进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完整的正确用法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 LeanCloud 上，数据存储是围绕 &lt;code&gt;AVObject&lt;/code&gt; 进行的。每个 &lt;code&gt;AVObject&lt;/code&gt; 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 &lt;code&gt;AVObject&lt;/code&gt; 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="文档" scheme="https://blog.pcninja.cn/tags/%E6%96%87%E6%A1%A3/"/>
    
      <category term="标准" scheme="https://blog.pcninja.cn/tags/%E6%A0%87%E5%87%86/"/>
    
      <category term="规范" scheme="https://blog.pcninja.cn/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>virtualenv创建Python虚拟环境时抛出UnicodeDecodeError异常的解决</title>
    <link href="https://blog.pcninja.cn/2019/07/solution-of-UnicodeDecodeError-thrown-by-virtualenv/"/>
    <id>https://blog.pcninja.cn/2019/07/solution-of-UnicodeDecodeError-thrown-by-virtualenv/</id>
    <published>2019-07-25T12:04:12.000Z</published>
    <updated>2019-07-25T12:36:14.533Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在通过pip安装TensorFlow时遇到了一个问题，当执行<code>virtualenv --system-site-packages -p python ./venv</code>创建新的虚拟环境时会抛出如下异常：<a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 939, in call_subprocess</span><br><span class="line">    line = line.decode(encoding)</span><br><span class="line">UnicodeDecodeError: 'utf-8' codec can't decode byte 0xca in position 38: invalid continuation byte</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 2635, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 870, in main</span><br><span class="line">    symlink=options.symlink,</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 1173, in create_environment</span><br><span class="line">    install_wheel(to_install, py_executable, search_dirs, download=download)</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 1019, in install_wheel</span><br><span class="line">    _install_wheel_with_search_dir(download, project_names, py_executable, search_dirs)</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 1110, in _install_wheel_with_search_dir</span><br><span class="line">    call_subprocess(cmd, show_stdout=False, extra_env=env, stdin=script)</span><br><span class="line">  File "e:\python\lib\site-packages\virtualenv.py", line 941, in call_subprocess</span><br><span class="line">    line = line.decode(fs_encoding)</span><br><span class="line">UnicodeDecodeError: 'utf-8' codec can't decode byte 0xca in position 38: invalid continuation byte</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;经过一番研究，原来出现异常的原因是调用<code>decode()</code>方法的<code>errors</code>参数为默认值<code>&quot;strict&quot;</code>，即任何编码错误都会引发UnicodeDecodeError，将其更改为<code>&quot;ignore&quot;</code>即可忽略错误。具体修改如下：<br>&emsp;&emsp;根据异常信息，将Python安装目录下的<code>.\Lib\site-packages\virtualenv.py</code>的第939行修改为<code>line = line.decode(encoding, &quot;ignore&quot;)</code>，即增加一个<code>&quot;ignore&quot;</code>参数。<br>再次尝试创建虚拟环境，此时就不会抛出异常了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Running virtualenv with interpreter E:\Python\python.exe</span><br><span class="line">Already using interpreter E:\Python\python.exe</span><br><span class="line">Using base prefix 'E:\\Python'</span><br><span class="line">New python executable in D:\TensorFlow\venv\Scripts\python.exe</span><br><span class="line">Installing setuptools, pip, wheel...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时我们就拥有了一套独立的Python运行环境，不用担心污染主环境了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在通过pip安装TensorFlow时遇到了一个问题，当执行&lt;code&gt;virtualenv --system-site-packages -p python ./venv&lt;/code&gt;创建新的虚拟环境时会抛出如下异常：
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://blog.pcninja.cn/tags/Python/"/>
    
      <category term="virtualenv" scheme="https://blog.pcninja.cn/tags/virtualenv/"/>
    
      <category term="编码" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【备忘】 SS代理服务器配置及优化</title>
    <link href="https://blog.pcninja.cn/2019/07/configuration-and-optimization-of-ss-proxy-server/"/>
    <id>https://blog.pcninja.cn/2019/07/configuration-and-optimization-of-ss-proxy-server/</id>
    <published>2019-07-15T12:41:21.000Z</published>
    <updated>2019-07-15T13:36:14.392Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;由于Vultr日本节点大量被墙，所以被迫转投DigitalOcean，最便宜的是5刀一个月，但首充5刀后会送50刀，再加上Github教育礼包里包含的50刀优惠（需要验证教育邮箱、上传学生证照片），所以算下来几乎可以白嫖两年，岂不美滋滋。美中不足是DigitalOcean的系统快照占用的存储空间是要另付费的，所以每次换IP开新机就需要重新配置代理服务器，这里简单记录一下流程和命令，方便以后复制。<br><a id="more"></a></p><blockquote><p>以Ubuntu 18.04搭建SS服务为例，如果今后SS情势不好可能会换用V2Ray</p></blockquote><h2 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h2><p>项目地址：<a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks/tree/master</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从源更新软件列表</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装pip</span></span><br><span class="line">apt-get install python-pip</span><br><span class="line"><span class="meta">#</span><span class="bash"> pip安装SS</span></span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure></p><p>安装完成后可以建两个脚本<code>start.sh</code>、<code>stop.sh</code>方便控制服务开关（或编写json配置文件，反而麻烦）<br>start.sh：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -p 端口 -k 密码 -m aes-256-cfb --user nobody -d start</span><br></pre></td></tr></table></figure></p><p>stop.sh：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -d stop</span><br></pre></td></tr></table></figure></p><p>最后还要给这两个脚本赋予执行权限<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x start.sh stop.sh    # 或直接chmod 777</span><br></pre></td></tr></table></figure></p><p>开启服务之前可以做以下优化，提高带宽利用率</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>首先按照官方Wiki上的教程进行优化，地址：<a href="https://github.com/shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks</a><br>创建<code>/etc/sysctl.d/local.conf</code>并写入以下配置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> max open files</span></span><br><span class="line">fs.file-max = 51200</span><br><span class="line"><span class="meta">#</span><span class="bash"> max <span class="built_in">read</span> buffer</span></span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"><span class="meta">#</span><span class="bash"> max write buffer</span></span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"><span class="meta">#</span><span class="bash"> default <span class="built_in">read</span> buffer</span></span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"><span class="meta">#</span><span class="bash"> default write buffer</span></span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"><span class="meta">#</span><span class="bash"> max processor input queue</span></span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"><span class="meta">#</span><span class="bash"> max backlog</span></span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> resist SYN flood attacks</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> reuse timewait sockets when safe</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> turn off fast timewait sockets recycling</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> short FIN timeout</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"><span class="meta">#</span><span class="bash"> short keepalive time</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"><span class="meta">#</span><span class="bash"> outbound port range</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"><span class="meta">#</span><span class="bash"> max SYN backlog</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"><span class="meta">#</span><span class="bash"> max timewait sockets held by system simultaneously</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"><span class="meta">#</span><span class="bash"> turn on TCP Fast Open on both client and server side</span></span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP receive buffer</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP write buffer</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"><span class="meta">#</span><span class="bash"> turn on path MTU discovery</span></span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> high-latency network</span></span><br><span class="line">net.ipv4.tcp_congestion_control = hybla</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> low-latency network, use cubic instead</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> net.ipv4.tcp_congestion_control = cubic</span></span><br></pre></td></tr></table></figure></p><p>最后的<code>net.ipv4.tcp_congestion_control</code>选择<code>hybla</code>还是<code>cubic</code>取决于服务器延迟的高低<br>然后加载我们写好的配置文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl --system</span><br></pre></td></tr></table></figure></p><p>接下来是启用TCP BBR拥塞控制算法，可以用来取代ServerSpeeder<br>已经有人做好了傻瓜式脚本，我们只需要根据提示操作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure></p><p>使用<code>lsmod | grep bbr</code>查看系统模块，若返回<code>tcp_bbr</code>说明BBR已启动</p><p>这时我们就可以运行<code>start.sh</code>，开启代理服务，进行科学上网了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;由于Vultr日本节点大量被墙，所以被迫转投DigitalOcean，最便宜的是5刀一个月，但首充5刀后会送50刀，再加上Github教育礼包里包含的50刀优惠（需要验证教育邮箱、上传学生证照片），所以算下来几乎可以白嫖两年，岂不美滋滋。美中不足是DigitalOcean的系统快照占用的存储空间是要另付费的，所以每次换IP开新机就需要重新配置代理服务器，这里简单记录一下流程和命令，方便以后复制。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://blog.pcninja.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://blog.pcninja.cn/tags/Linux/"/>
    
      <category term="服务器" scheme="https://blog.pcninja.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="代理" scheme="https://blog.pcninja.cn/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>写在十八岁的最后一天</title>
    <link href="https://blog.pcninja.cn/2019/07/on-my-last-day-of-eighteen/"/>
    <id>https://blog.pcninja.cn/2019/07/on-my-last-day-of-eighteen/</id>
    <published>2019-07-07T13:09:47.000Z</published>
    <updated>2019-07-07T13:26:12.105Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;十八岁，过的可真快，转眼就到了最后一天，以至于我还没反应过来。这就好比，在看一场精彩绝伦的足球赛时，往往会觉得上半场怎么这么快就结束了。而我的十八岁，虽称不上精彩，但也足够充实，或者说，只是单纯的忙碌，忙碌到这一年里发生的许多事我都快忘却了，所以我才要在这儿记下那些快要忘却的事，也算是对自己的十八岁做个简要的小结吧。<br><a id="more"></a><br>&emsp;&emsp;如果用一个词来总结这一年的话，我想应该是五味杂陈吧，因为这一年里，我哭过，痛过，累过，当然，也笑过。在度过了一个安逸的暑假之后，我开启了大学之旅，第一学期可以说是平淡无奇的四个月——很快我就适应了大学里的生活节奏，接着就是在上课、作业、游戏中轮回，周而复始。除了基本的课业知识，没有任何长进，虽然成绩还不错，但我对那个学期是不满意的，因为我虚度了四个月的时光。<br>&emsp;&emsp;浪费就会受到惩罚，这是颠扑不破的真理。很快，惩罚就降临了。我别无选择，只得默默接受。接下来的寒假对我来说无疑是煎熬的，当然，也有痛定思痛、扪心自问。<br>&emsp;&emsp;在假期临近结束之际，我做出了让我自己为之骄傲的决定，我遵从了自己的内心，提交了转专业申请，向自己的热爱与理想迈出了一大步。这一次，我终于没再辜负你，也没再辜负自己，这就是我为之骄傲的原因。<br>&emsp;&emsp;第二学期，我体验到了从未有过的忙碌与充实，大大小小的事务等待着我去一一处理，一个个抉择与挑战摆在我面前。这个学期，我参加了ACM校赛，见识了那些高水平选手的风采，让我深刻体会到天外有天，人外有人。我正视到自己的差距，意识到此刻开始追赶并不是一个明智的选择，ACM竞赛也并非我所认为的计算机科学的最好体现。正所谓条条大路通罗马，我需要尽早找到自己真正感兴趣的方向，追寻我所憧憬的计算机科学。<br>&emsp;&emsp;这一年，也是我自信心大幅提升的一年。我向自己证明了我的能力：第一学期综合成绩排名18/808，转入计科实验班后排名3/55，进入火花空间创客社团技术组，担任过一次技术沙龙的主讲人，带领宿舍全员设计开发寻物微信小程序……这些成绩告诉我，我不必自卑，无论在哪，我都能够站稳脚跟、发挥自己的作用、实现自己的价值。<br>&emsp;&emsp;人际交往方面，我倒是没有什么变化：不大不小的朋友圈，几个挚友，一个念念不忘的人，没有树敌。偶尔会感到孤独，但孤独是人生的必修课，我想这样就挺好。<br>&emsp;&emsp;这学期有位老师的一段话引发了我的思考：“科学是和人们的生活不相干的东西，而造福人类的是技术”。一开始，我对这种说法嗤之以鼻，心想科学怎么会和人们无关呢，但仔细想想，这种说法其实不无道理，科学与技术相辅相成——科学是技术的前提，而技术是科学的实现，因此科学对生活的影响是间接的，技术是直接的。我认为科学之于技术好比世界观之于方法论：方法论真正左右我们的行为，而决定方法论的却是世界观。<br>&emsp;&emsp;对科学与技术的思考让我对未来感到有些迷茫。如果你在十年前问我未来的职业理想是什么，我也许会给出和大部分孩子一样的答案：科学家，当然，这是一个极其笼统的回答；如果你在三年前问我同样的问题，我会毫不犹豫的回答你：计算机科学家；但如果你现在再来问我，我会犹豫，因为也许技术从业者会为这个社会创造更大的价值。这样的迷茫可能会持续一段时间，在我找到答案之前，我需要不断培养自己的计算思维、扩充自己的技术栈，尽可能做到理论与实践并行。<br>&emsp;&emsp;还有三个小时，我的十八岁就要过去了，竟有些伤感。十八岁，有太多的始料未及，此后，再不会有八月瓢泼大雨里的那种感动，再不会有一月寒风凛冽中的那种悲痛。时间会冲淡一切，现在需要我做的，就是以更好的态度，迎接十九岁的时空旅行。<br>&emsp;&emsp;薯片忍者，生日快乐！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;十八岁，过的可真快，转眼就到了最后一天，以至于我还没反应过来。这就好比，在看一场精彩绝伦的足球赛时，往往会觉得上半场怎么这么快就结束了。而我的十八岁，虽称不上精彩，但也足够充实，或者说，只是单纯的忙碌，忙碌到这一年里发生的许多事我都快忘却了，所以我才要在这儿记下那些快要忘却的事，也算是对自己的十八岁做个简要的小结吧。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://blog.pcninja.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="https://blog.pcninja.cn/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="https://blog.pcninja.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="人生" scheme="https://blog.pcninja.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="情感" scheme="https://blog.pcninja.cn/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构考试——链表去重</title>
    <link href="https://blog.pcninja.cn/2019/06/linked-list-duplicate-removal/"/>
    <id>https://blog.pcninja.cn/2019/06/linked-list-duplicate-removal/</id>
    <published>2019-06-17T13:53:07.000Z</published>
    <updated>2019-06-17T14:02:21.531Z</updated>
    
    <content type="html"><![CDATA[<p><strong>链表去重</strong><br>时间限制: 400 ms<br>内存限制: 64 MB</p><p>给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。<br><a id="more"></a><br><strong>输入格式：</strong><br>输入在第一行给出 L 的第一个结点的地址和一个正整数 N（≤10^5，为结点总数）。一个结点的地址是非负的 5 位整数，空地址 NULL 用 -1 来表示。<br>随后 N 行，每行按以下格式描述一个结点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址 键值 下一个结点</span><br></pre></td></tr></table></figure></p><p>其中<code>地址</code>是该结点的地址，<code>键值</code>是绝对值不超过10^4的整数，下一个结点是下个结点的地址。</p><p><strong>输出格式：</strong><br>首先输出去重后的链表，然后输出被删除的链表。每个结点占一行，按输入的格式输出。</p><p><strong>输入样例:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00100 5</span><br><span class="line">99999 -7 87654</span><br><span class="line">23854 -15 00000</span><br><span class="line">87654 15 -1</span><br><span class="line">00000 -15 99999</span><br><span class="line">00100 21 23854</span><br></pre></td></tr></table></figure></p><p><strong>输出样例:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00100 21 23854</span><br><span class="line">23854 -15 99999</span><br><span class="line">99999 -7 -1</span><br><span class="line">00000 -15 87654</span><br><span class="line">87654 15 -1</span><br></pre></td></tr></table></figure></p><p><strong>代码</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; ram[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> exist[<span class="number">100005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start, n, addr, val, next;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;start, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;addr, &amp;val, &amp;next);</span><br><span class="line">        ram[addr].val = val;</span><br><span class="line">        ram[addr].next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[n], na = <span class="number">1</span>, b[n], nb = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>] = start;</span><br><span class="line">    exist[<span class="built_in">abs</span>(ram[start].val)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ram[start].next; i != <span class="number">-1</span>; i = ram[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!exist[<span class="built_in">abs</span>(ram[i].val)])</span><br><span class="line">        &#123;</span><br><span class="line">            exist[<span class="built_in">abs</span>(ram[i].val)]++;</span><br><span class="line">            a[na++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[nb++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, a[i], ram[a[i]].val);</span><br><span class="line">        <span class="keyword">if</span>(i == na<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, a[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, b[i], ram[b[i]].val);</span><br><span class="line">        <span class="keyword">if</span>(i == nb<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, b[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;链表去重&lt;/strong&gt;&lt;br&gt;时间限制: 400 ms&lt;br&gt;内存限制: 64 MB&lt;/p&gt;
&lt;p&gt;给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.pcninja.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="大学" scheme="https://blog.pcninja.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="作业" scheme="https://blog.pcninja.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="编程" scheme="https://blog.pcninja.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.pcninja.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://blog.pcninja.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://blog.pcninja.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Hash" scheme="https://blog.pcninja.cn/tags/Hash/"/>
    
  </entry>
  
</feed>
