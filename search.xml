<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构作业——地铁一日游]]></title>
    <url>%2F2019%2F04%2Fone-day-metro-tour%2F</url>
    <content type="text"><![CDATA[地铁一日游时间限制: 550 ms内存限制: 64 MB代码长度限制: 16 KB 森森喜欢坐地铁。这个假期，他终于来到了传说中的地铁之城——魔都，打算好好过一把坐地铁的瘾！魔都地铁的计价规则是：起步价 2 元，出发站与到达站的最短距离（即计费距离）每 K 公里增加 1 元车费。例如取 K = 10，动安寺站离魔都绿桥站为 40 公里，则车费为 2 + 4 = 6 元。为了获得最大的满足感，森森决定用以下的方式坐地铁：在某一站上车（不妨设为地铁站 A），则对于所有车费相同的到达站，森森只会在计费距离最远的站或线路末端站点出站，然后用森森美图 App 在站点外拍一张认证照，再按同样的方式前往下一个站点。坐着坐着，森森突然好奇起来：在给定出发站的情况下（在出发时森森也会拍一张照），他的整个旅程中能够留下哪些站点的认证照？地铁是铁路运输的一种形式，指在地下运行为主的城市轨道交通系统。一般来说，地铁由若干个站点组成，并有多条不同的线路双向行驶，可类比公交车，当两条或更多条线路经过同一个站点时，可进行换乘，更换自己所乘坐的线路。举例来说，魔都 1 号线和 2 号线都经过人民广场站，则乘坐 1 号线到达人民广场时就可以换乘到 2 号线前往 2 号线的各个站点。换乘不需出站（也拍不到认证照），因此森森乘坐地铁时换乘不受限制。输入格式：输入第一行是三个正整数 N、M 和 K，表示魔都地铁有 N 个车站 (1 ≤ N ≤ 200)，M 条线路 (1 ≤ M ≤ 1500)，最短距离每超过 K 公里 (1 ≤ K ≤ 106)，加 1 元车费。接下来 M 行，每行由以下格式组成：&lt;站点1&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点2&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点3&gt; … &lt;站点X-1&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点X&gt;其中站点是一个 1 到 N 的编号；两个站点编号之间的距离指两个站在该线路上的距离。两站之间距离是一个不大于 10^6 的正整数。一条线路上的站点互不相同。注意：两个站之间可能有多条直接连接的线路，且距离不一定相等。再接下来有一个正整数 Q (1 ≤ Q ≤ 200)，表示森森尝试从 Q 个站点出发。最后有 Q 行，每行一个正整数 Xi，表示森森尝试从编号为 Xi 的站点出发。 输出格式：对于森森每个尝试的站点，输出一行若干个整数，表示能够到达的站点编号。站点编号从小到大排序。 输入样例:123456786 2 61 6 2 4 3 1 45 6 2 6 642345 输出样例:12341 2 4 5 61 2 3 4 5 61 2 4 5 61 2 4 5 6 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;int main(void)&#123; int n, m, k, i, j, a; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); //Init D int D[n][n]; for(i = 0; i &lt; n; ++i) for(j = 0; j &lt; n; ++j) D[i][j] = (i == j ? 0 : -1); //Get D int s1, s2, len, terminal[m*2]; char ch; for(i = 0; i &lt; m; ++i) &#123; scanf("%d", &amp;s1); s1--; terminal[i*2] = s1; ch = getchar(); while(ch != '\n') &#123; scanf("%d %d", &amp;len, &amp;s2); s2--; if(D[s1][s2] == -1 || D[s1][s2] &gt; len) &#123; D[s1][s2] = len; D[s2][s1] = D[s1][s2]; &#125; s1 = s2; ch = getchar(); &#125; terminal[i*2 + 1] = s1; &#125; //Floyd for(a = 0; a &lt; n; ++a) for(i = 0; i &lt; n; ++i) for(j = 0; j &lt; n; ++j) if(D[i][a] != -1 &amp;&amp; D[a][j] != -1) if(D[i][j] == -1 || D[i][a] + D[a][j] &lt; D[i][j]) D[i][j] = D[i][a] + D[a][j]; //Preprocess int canArr[n][n]; for(i = 0; i &lt; n; ++i) for(j = 0; j &lt; n; ++j) canArr[i][j] = 0; for(i = 0; i &lt; n; ++i) &#123; for(j = 0; j &lt; m*2; ++j) if(D[i][terminal[j]] != -1) canArr[i][terminal[j]] = 1; for(j = 0; j &lt; n; ++j) &#123; if(j != i) &#123; if(D[i][j] == -1) continue; for(a = 0; a &lt; n; ++a) if(a != i &amp;&amp; a != j) if(D[i][a] != -1 &amp;&amp; D[i][a] / k == D[i][j] / k &amp;&amp; D[i][a] &gt; D[i][j]) break; if(a == n) canArr[i][j] = 1; &#125; &#125; &#125; //Solve Problem int q, start, arr[n], queue[n], head, tail, flag; scanf("%d", &amp;q); for(i = 0; i &lt; q; ++i) &#123; for(j = 0; j &lt; n; ++j) arr[j] = 0; scanf("%d", &amp;start); arr[--start] = 1; head = 0, tail = 0; queue[0] = start; while(head &lt;= tail) &#123; for(j = 0; j &lt; n; ++j) if(!arr[j] &amp;&amp; canArr[queue[head]][j]) &#123; queue[++tail] = j; arr[j] = 1; &#125; head++; &#125; flag = 0; for(j = 0; j &lt; n; ++j) if(arr[j]) &#123; if(flag) printf(" "); else flag = 1; printf("%d", j+1); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>作业</tag>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构作业——天梯地图]]></title>
    <url>%2F2019%2F04%2Fhigh-ladder-map%2F</url>
    <content type="text"><![CDATA[天梯地图时间限制: 300 ms内存限制: 64 MB代码长度限制: 16 KB 本题要求你实现一个天梯赛专属在线地图，队员输入自己学校所在地和赛场地点后，该地图应该推荐两条路线：一条是最快到达路线；一条是最短距离的路线。题目保证对任意的查询请求，地图上都至少存在一条可达路线。输入格式：输入在第一行给出两个正整数N（2 ≤ N ≤ 500）和M，分别为地图中所有标记地点的个数和连接地点的道路条数。随后M行，每行按如下格式给出一条道路的信息：1V1 V2 one-way length time 其中V1和V2是道路的两个端点的编号（从0到N-1）；如果该道路是从V1到V2的单行线，则one-way为1，否则为0；length是道路的长度；time是通过该路所需要的时间。最后给出一对起点和终点的编号。 输出格式：首先按下列格式输出最快到达的时间T和用节点编号表示的路线：1Time = T: 起点 =&gt; 节点1 =&gt; ... =&gt; 终点 然后在下一行按下列格式输出最短距离D和用节点编号表示的路线：1Distance = D: 起点 =&gt; 节点1 =&gt; ... =&gt; 终点 如果最快到达路线不唯一，则输出几条最快路线中最短的那条，题目保证这条路线是唯一的。而如果最短距离的路线不唯一，则输出途径节点数最少的那条，题目保证这条路线是唯一的。 如果这两条路线是完全一样的，则按下列格式输出：1Time = T; Distance = D: 起点 =&gt; 节点1 =&gt; ... =&gt; 终点 输入样例1：123456789101112131415161710 150 1 0 1 18 0 0 1 14 8 1 1 15 4 0 2 35 9 1 1 40 6 0 1 17 3 1 1 28 3 1 1 22 5 0 2 22 1 1 1 11 5 0 1 31 4 0 1 19 7 1 1 33 1 0 2 56 3 1 2 15 3 输出样例1：12Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3Distance = 3: 5 =&gt; 1 =&gt; 3 输入样例2：12345678910117 90 4 1 1 11 6 1 3 12 6 1 1 12 5 1 2 23 0 0 1 13 1 1 3 13 2 1 2 14 5 0 2 26 5 1 2 13 5 输出样例2：1Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Edge&#123; int Target; int Length; int Time; struct Edge *NextEdge;&#125;;struct Vertex&#123; struct Edge *Head; int Known; int Dist; int PathDist; int Time; int PathTime; int VertexNums;&#125;;void ReadGraph(struct Vertex *G, int n, int m)&#123; int begin, target, oneWay, length, time; struct Edge *p; for(int i = 0; i &lt; n; ++i) G[i].Head = NULL; for(int i = 0; i &lt; m; ++i) &#123; scanf("%d %d %d %d %d", &amp;begin, &amp;target, &amp;oneWay, &amp;length, &amp;time); p = G[begin].Head; G[begin].Head = (struct Edge *)malloc(sizeof(struct Edge)); G[begin].Head-&gt;Target = target; G[begin].Head-&gt;Length = length; G[begin].Head-&gt;Time = time; G[begin].Head-&gt;NextEdge = p; if(!oneWay) &#123; p = G[target].Head; G[target].Head = (struct Edge *)malloc(sizeof(struct Edge)); G[target].Head-&gt;Target = begin; G[target].Head-&gt;Length = length; G[target].Head-&gt;Time = time; G[target].Head-&gt;NextEdge = p; &#125; &#125;&#125;void Dijkstra(struct Vertex *G, int n, int begin)&#123; int v, vDist, vTime, vNums; for(int i = 0; i &lt; n; ++i) &#123; G[i].Known = 0; G[i].Dist = G[i].Time = G[i].PathDist = G[i].PathTime = G[i].VertexNums = -1; &#125; G[begin].Dist = G[begin].Time = G[begin].VertexNums = 0; while(1) &#123; v = vTime = -1; for(int i = 0; i &lt; n; ++i) if(!G[i].Known &amp;&amp; G[i].Time != -1) &#123; if(v == -1 || G[i].Time &lt; vTime) &#123; vTime = G[i].Time; vDist = G[i].Dist; v = i; &#125; else if(G[i].Time == vTime &amp;&amp; G[i].Dist &lt; vDist) &#123; vDist = G[i].Dist; v = i; &#125; &#125; if(v == -1) break; G[v].Known = 1; for(struct Edge *p = G[v].Head; p; p = p-&gt;NextEdge) &#123; if(!G[p-&gt;Target].Known) &#123; if(G[p-&gt;Target].Time == -1 || G[v].Time + p-&gt;Time &lt; G[p-&gt;Target].Time) &#123; G[p-&gt;Target].Time = G[v].Time + p-&gt;Time; G[p-&gt;Target].Dist = G[v].Dist + p-&gt;Length; G[p-&gt;Target].PathTime = v; &#125; else if((G[v].Time + p-&gt;Time == G[p-&gt;Target].Time) &amp;&amp; (G[v].Dist + p-&gt;Length &lt; G[p-&gt;Target].Dist)) &#123; G[p-&gt;Target].Dist = G[v].Dist + p-&gt;Length; G[p-&gt;Target].PathTime = v; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i) &#123; G[i].Known = 0; G[i].Dist = -1; &#125; G[begin].Dist = 0; while(1) &#123; v = vDist = -1; for(int i = 0; i &lt; n; ++i) if(!G[i].Known &amp;&amp; G[i].Dist != -1) &#123; if(v == -1 || G[i].Dist &lt; vDist) &#123; vDist = G[i].Dist; vNums = G[i].VertexNums; v = i; &#125; else if(G[i].Dist == vDist &amp;&amp; G[i].VertexNums &lt; vNums) &#123; vNums = G[i].VertexNums; v = i; &#125; &#125; if(v == -1) break; G[v].Known = 1; for(struct Edge *p = G[v].Head; p; p = p-&gt;NextEdge) &#123; if(!G[p-&gt;Target].Known) &#123; if(G[p-&gt;Target].Dist == -1 || G[v].Dist + p-&gt;Length &lt; G[p-&gt;Target].Dist) &#123; G[p-&gt;Target].Dist = G[v].Dist + p-&gt;Length; G[p-&gt;Target].VertexNums = G[v].VertexNums + 1; G[p-&gt;Target].PathDist = v; &#125; else if((G[v].Dist + p-&gt;Length == G[p-&gt;Target].Dist) &amp;&amp; (G[v].VertexNums + 1 &lt; G[p-&gt;Target].VertexNums)) &#123; G[p-&gt;Target].VertexNums = G[v].VertexNums + 1; G[p-&gt;Target].PathDist = v; &#125; &#125; &#125; &#125;&#125;void PrintPath(struct Vertex *G, int end, int type)&#123; if(type) &#123; if(G[end].PathDist != -1) &#123; PrintPath(G, G[end].PathDist, 1); printf(" =&gt; %d", end); &#125; &#125; else &#123; if(G[end].PathTime != -1) &#123; PrintPath(G, G[end].PathTime, 0); printf(" =&gt; %d", end); &#125; &#125;&#125;void Output(struct Vertex *G, int begin, int end)&#123; int i = end; while(i != begin) &#123; if(G[i].PathDist != G[i].PathTime) break; i = G[i].PathDist; &#125; if(i == begin) &#123; printf("Time = %d; Distance = %d: %d", G[end].Time, G[end].Dist, begin); PrintPath(G, end, 0); &#125; else &#123; printf("Time = %d: %d", G[end].Time, begin); PrintPath(G, end, 0); printf("\nDistance = %d: %d", G[end].Dist, begin); PrintPath(G, end, 1); &#125;&#125;int main(void)&#123; int n, m, begin, end; scanf("%d %d", &amp;n, &amp;m); struct Vertex G[n]; ReadGraph(G, n, m); scanf("%d %d", &amp;begin, &amp;end); Dijkstra(G, n, begin); Output(G, begin, end); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>作业</tag>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有点小累]]></title>
    <url>%2F2019%2F04%2Fi-am-tired%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;距离上次更新博客已经过去足足五个月了，尽管时常想起自己还有这么个博客，但总会因为种种原因而被搁置。难得今天有兴致记录一下生活，就大概写写这小半年发生的大小事吧。&emsp;&emsp;一九年初，正当人们沉浸在新年来临的喜悦之际，我遭受到了迄今为止最大的挫折——我丢了我最重要的东西，这是无疑是一次难以承受的挫折。巨大的冲击让我陷入恍惚与错乱，我想用万念俱灰来形容那时的我再合适不过了。就这样，我陷入了无尽的回忆之中，神魂颠倒地挨过了这个寒冬。&emsp;&emsp;大概历经两个多月，我才渐渐恢复意识，开始重新认识自己、认识世界、认识眼前的一草一木。我意识到不应再踯躅，也不需要不停地回忆。我们只要在恰当的时候，回首眺望似水年华，这便是回忆的全部作用。为了最初的理想，也为了另外一个更重要的原因，我踏上了新的征程。&emsp;&emsp;新学期，新的班级，新的同学，一切都不再熟悉。但是没时间让我熟悉这些，因为学业上的压力明显要高过以往。迫不得已，我把更多的时间分给课业。尽管跟别的同学比，我玩的时间绝对算是最多的之一，但是要知道在中学时期我从来没有花过这么多时间在学习上，所以无论是身体还是精神都需要适应适应。我发现，在实验班，需要的不仅是智力，还需要有足够的精力来处理各种报告、集会、比赛以及各种各样的琐事。今天之所以写博客来小小地抱怨一下就是因为光一个电子电路实验报告就占去了我溜溜三个多小时，这让我不太能接受。 &emsp;&emsp;但我其实并不是想抱怨什么，只是我有点累了。我相信，此时此刻，把自己的疲倦写下来，就是最好的缓解。&emsp;&emsp;明天，太阳照常升起，我知道那时我会充好能量，开始新的一天。所以现在，就让我结束这篇语无伦次的博文，然后，睡个好觉。&emsp;&emsp;祝我晚安，也祝你晚安。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>日记</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[申请Let's Encrypt免费SSL证书并在Node.js建立HTTPS服务]]></title>
    <url>%2F2018%2F11%2Fletsencrypt-certificates-and-https-in-nodejs%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;为了更安全地传输，我们往往需要建立HTTPS连接。我们可以利用OpenSSL创建自签名的证书，但创建自己的CA机构并不安全也不被各大浏览器承认。目前有不少免费SSL证书提供商，其中最流行的便是Let’s Encrypt（官网），下面是关于如何申请Let’s Encrypt免费SSL证书并用Node.js建立一个HTTPS服务器。 申请Let’s Encrypt免费SSL证书Let’s Encrypt官方推荐使用Certbot ACME客户端。它可以自动执行证书颁发和安装，无需停机且易于使用。 首先安装certbot通过SSH连接到你的VPS或云服务器，确保已经安装了Python及Git。本文以CentOS为例，其他发行版大同小异。 1$ sudo yum install certbot 获取证书首先停止你服务器上的服务，保证80端口没有被占用并且你的域名被正确解析到你的服务器，否则在证书获取过程中会出现错误。 1$ sudo certbot certonly --standalone -d diunar.tk -d www.diunar.tk #把diunar.tk换成你的域名 当看到“Congratulations”字样时，代表你已经成功申请到Let’s Encrypt的免费SSL证书，证书有效期是90天，后面会讲如何&nbsp;续命&nbsp;延期。证书文件被保存到了/etc/letsencrypt/live/你的域名/，其中的fullchain.pem和privkey.pem是我们接下来需要用到的完整证书链及私钥 如果你希望在Nginx或Apache等Web服务器上应用你的SSL请在Certbot的官网上查看方法。下面我们用Node.js编写服务器建立HTTPS服务 通过Node.js建立HTTPS服务 为了方便，我们使用Express框架，因此需要安装Express： 1$ npm install express 创建index.js： 1234567891011121314151617181920212223242526const express = require('express')const fs = require('fs')const http = require('http')const https = require('https')const app = express()const port = 80 //HTTP访问端口号，默认80，可更改为你希望的端口号const SSLport = 443 //HTTPS访问端口号，默认443，可更改为你希望的端口号const options = &#123; key: fs.readFileSync('/etc/letsencrypt/live/diunar.tk/privkey.pem'), //异步读取私钥文件 cert: fs.readFileSync('/etc/letsencrypt/live/diunar.tk/fullchain.pem'), //异步读取证书文件 requestCert: false, //是否请求客户端证书 rejectUnauthorized: false //是否拒绝无信任CA颁发的证书的客户端连接请求&#125;http.createServer(app).listen(port, () =&gt; console.log(`HTTP server is listening on port $&#123;port&#125;`)) //创建http服务监听https.createServer(options, app).listen(SSLport, () =&gt; console.log(`HTTPS server is listening on port $&#123;SSLport&#125;`)) //创建https服务监听app.get('/', function(req, res) &#123; if (req.protocol == 'https') &#123; res.send("This is HTTPS Server") &#125; else &#123; res.send("This is HTTP Server") &#125;&#125;) 如果不需要HTTP服务可以删除http.createServer(app)，只保留HTTPS服务 运行Node.js服务123$ node index.jsHTTP server is listening on port 80HTTPS server is listening on port 443 在浏览器分别通过http://和https://协议访问你的域名，看看有什么区别： 通过浏览器可以看到我们与服务器建立的是密文传输连接： 大功告成之后，别忘了每隔90天通过certbot renew命令进行证书的续订。你也可以设置自动续订，具体方法请见Certbot官网。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>SSL</tag>
        <tag>HTTPS</tag>
        <tag>网络</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDB后端与微信小程序前端建构最小端到端系统]]></title>
    <url>%2F2018%2F10%2Fminimum-end-to-end-system%2F</url>
    <content type="text"><![CDATA[服务端搭建 一、环境准备1.操作系统与网络本文以Arch Linux为例，在VirtualBox虚拟机下运行，通过SSH与宿主机连接。由于虚拟机通过NAT联网，要想访问在虚拟机中部署的Web服务需要进行端口转发： 打开VirtualBox管理器，进入Arch虚拟机的设置页，在网络选项卡中点击高级 点击端口转发，我们新建一个端口转发规则。协议为TCP；主机IP填写VirtualBox虚拟网卡的地址，在Windows宿主机通过ipconfig命令可查看，默认为192.168.56.1；子系统IP填写虚拟机IPv4地址，在Arch虚拟机中通过ip addr命令可查看（图中红框所示处）；子系统端口为我们即将部署的Node服务的监听端口；主机端口为转发到主机后的端口，我们应该避开常用或已被占用的端口（如21、22、25、80、443），为了方便我们可以转发到原端口，本文以3000端口为例 这样设置完毕后虚拟机的3000端口就可以通过192.168.56.1:3000访问了 2.Node.js由于该虚拟机此前已安装Node.js、MongoDB等，首先将其卸载再做演示：1$ pacman -Rsc nodejs mongodb #删除Node.js、MongoDB和所有依赖这两个软件包的程序 更多关于pacman（Arch官方软件包管理器）的用法请见这里通过pacman安装Node.js：1$ pacman -S nodejs npm #安装node及包管理器npm 或者从Node.js官网下载二进制文件：123$ wget https://nodejs.org/dist/v8.12.0/node-v8.12.0-linux-x64.tar.xz$ xz -d node-v8.12.0-linux-x64.tar.xz$ tar -xvf node-v8.12.0-linux-x64.tar 3.MongoDB 方法一： 123$ pacman -S mongodb #从官方软件仓库安装mongodb$ systemctl start mongodb.service #启动mongodb服务$ systemctl enable mongodb.service #设置开机启动服务 Arch Linux的默认dbpath是/var/lib/mongodb/，启动服务后可以通过mongo命令进入Mongo Shell 方法二： 123$ cd /home$ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.2.tgz #从官网下载二进制包$ tar -xzvf mongodb-linux-x86_64-4.0.2.tgz 为了快速使用mongodb命令，可以配置环境变量。编辑~/.profile或/etc/profile文件，将mongodb/bin路径加入即可：1$ sudo vim /etc/profile 在文件末尾添加一行：1export PATH=$PATH:/home/mongodb-linux-x86_64-4.0.2/bin 保存修改后，在终端运行以下命令使环境变量生效：1$ source /etc/profile 启动mongod：12$ mkdir /data/db #创建数据存放目录$ mongod --dbpath /data/db 此时mongod已经启动，我们可以在另一终端中通过mongo命令进入交互程序 二、部署服务1.建立应用并安装依赖首先建立一个工作目录：12$ mkdir wx$ cd wx 通过npm init初始化一个应用，此时会要求你输入应用的名称、版本、入口文件等信息，可以按Enter键选择默认值，最终npm会为你生成一个package.json文件1$ npm init 下面通过Node包管理器安装Express、Mongoose：1$ npm install express mongoose --save 安装成功后会出现+ express、+ mongoose等字样，这两个包及其所需依赖都被安装在/node_modules中并被写入package.json： 除了上述方法，我们也可以通过全局安装来达到一劳永逸的目的：1$ npm install express mongoose -g 2.建立HWMongo模块编辑hwmongo.js：1vim hwMongo.js 将数据库连接与定义Schema部分写进hwMongo.js，以便后续调用：1234567891011//hwmongo.jsvar mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test'); //与数据库建立连接var helloWorldSchema = mongoose.Schema(&#123; country: String, helloWorld: String,&#125;); //定义数据架构helloWorldSchemavar HWMongo = mongoose.model('HWs', helloWorldSchema);module.exports = HWMongo; //导出HWMongo 3.初始化数据编辑initData.js：1vim initData.js 将初始数据插入文档：1234567891011121314151617181920212223242526var HWMongo = require('./hwMongo');new HWMongo(&#123; country: 'China', helloWorld: '你好，世界!'&#125;).save();new HWMongo(&#123; country: 'US', helloWorld: 'Hello World!'&#125;).save();new HWMongo(&#123; country: 'Danmark', helloWorld: 'Hallo, Verden!'&#125;).save();new HWMongo(&#123; country: 'Germany', helloWorld: 'Hallo, Welt!'&#125;).save();new HWMongo(&#123; country: 'France', helloWorld: 'Bonjour, tout le monde'&#125;).save(); 运行程序：1node initData.js 如果出现“当前URL解析器被弃用”的警告，我们可以修改hwMongo.js的数据库连接部分（第3行），使用新的解析器：1mongoose.connect('mongodb://localhost/test', &#123;useNewUrlParser: true&#125;); //Line 3 数据初始化完成之后我们可以通过mongo进入Mongo Shell，在交互程序中通过use wx切换至数据库“wx”，通过show collections可以列出数据库中的全部集合，通过db.hws.find()可以进行查询：12345678910&gt; use wxswitched to db wx&gt; show collectionshws&gt; db.hws.find()&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b72&quot;), &quot;country&quot; : &quot;US&quot;, &quot;helloWorld&quot; : &quot;Hello World!&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b73&quot;), &quot;country&quot; : &quot;Danmark&quot;, &quot;helloWorld&quot; : &quot;Hallo, Verden!&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b74&quot;), &quot;country&quot; : &quot;Germany&quot;, &quot;helloWorld&quot; : &quot;Hallo, Welt!&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b75&quot;), &quot;country&quot; : &quot;France&quot;, &quot;helloWorld&quot; : &quot;Bonjour, tout le monde&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b71&quot;), &quot;country&quot; : &quot;China&quot;, &quot;helloWorld&quot; : &quot;你好，世界!&quot;, &quot;__v&quot; : 0 &#125; 4.建立HTTP服务器编辑入口文件index.js：1vim index.js 在index.js中编写简易HTTP服务器与查询服务：12345678910111213141516171819202122const express = require('express');const HWMongo = require('./hwMongo.js'); //调用模块const app = express();const port = 3000; //http服务器端口号app.get('/country', function(req,res) &#123; HWMongo.findOne(&#123;'country': req.query.country&#125;, function(err, doc) &#123; if (err) &#123; console.log("数据库出错"); &#125; else if (doc==null) &#123; res.send("输入信息有误，请重试"); console.log(req.query.country + ":" + doc); &#125; else &#123; res.send(doc.helloWorld); //应答报文 console.log(req.query.country + ":" +doc.helloWorld); &#125; &#125;);&#125;);app.listen(port, function() &#123; console.log('Server is running at http://localhost:3000/.');&#125;); HTTP服务器跑起来后宿主机所在局域网内的设备可以通过http://192.168.56.1:3000来访问：1node index.js 至此，服务端已搭建完成 前端小程序实现 一、开发工具在这里下载并安装微信web开发者工具 二、项目与项目配置文件新建一个空白项目，编辑项目配置文件project.config.json，为了调试方便，我们将urlCheck一项改为false:12345678&#123; ... "setting": &#123; "urlCheck": false, ... &#125;, ...&#125; 更多关于项目配置文件的描述请见这里 三、文件结构从微信小程序官方文档中我们可以知道小程序的文件组成结构，具体内容如下 小程序主体部分（项目根目录下）： 文件 必需 作用 app.js 是 小程序逻辑 app.json 是 小程序公共配置 app.wxss 否 小程序公共样式表 小程序页面： 文件类型 必需 作用 js 是 页面逻辑 wxml 是 页面结构 json 否 页面配置 wxss 否 页面样式表 因此我们在项目目录中新建app.js和app.json，并编辑app.json： 12345&#123; "pages": [ "pages/index/index" ]&#125; 此时开发工具会自动建立pages/index目录及其页面组成文件，至此只包含一个页面的最小项目的框架搭建完成，其文件结构如下：12345678.├── app.js├── app.json├── pages│ └── index│ ├── index.js│ └── index.wxml└── project.config.json 四、页面逻辑及生命周期每个页面的JS文件中通过Page(Object)函数来注册页面，它接受一个对象类型参数，指定页面的初始数据、生命周期回调、事件处理函数等。我在此列举几个主要、常用的对象参数（详见这里）： 属性 类型 说明 data 对象 页面第一次渲染使用的初始数据，JSON类型 onLoad 函数 页面加载时触发，一个页面只会调用一次 onShow 函数 页面显示/切入前台时触发 onReady 函数 页面初次渲染完成时触发，一个页面只会调用一次 onHide 函数 页面隐藏/切入后台时触发 其他 任意 开发者添加任意函数或数据 其中所有函数类型的参数均为生命周期回调函数我们编辑pages/index的页面逻辑文件index.js： 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //页面的初始数据 data: &#123; hidden: true, data_from_mongodb: "" &#125;, //开发者自定义函数 query: function() &#123; var index = Math.floor(Math.random() * 5) //产生0-4的随机数 var wxcountry = "" if (index == 0) &#123; wxcountry = "China" &#125; else if (index == 1) &#123; wxcountry = "US" &#125; else if (index == 2) &#123; wxcountry = "Danmark" &#125; else if (index == 3) &#123; wxcountry = "Germany" &#125; else if (index == 4) &#123; wxcountry = "France" &#125; var that = this wx.request(&#123; url: "http://192.168.56.1:3000/country", data: &#123; country: wxcountry &#125;, success: function(res) &#123; that.setData(&#123; hidden: false, data_from_mongodb: wxcountry + " : " + res.data &#125;) &#125;, &#125;) //从后端请求数据 &#125;,&#125;) 由于微信小程序支持ECMAScript 6（ES6）标准，因此JS代码可以省略语句末的分号;，并且微信官方所有示例程序均采用省略，因此我们也应该遵循微信小程序的编码规范，语句末省略分号; 五、编译与运行点击开发者工具工具栏中的编译按钮，即可在左侧的模拟器中看到运行效果： 至此，前端部分建构完成 将服务部署至VPS/云服务器 我们可以把我们建构好的服务部署至服务器以实现公网访问，我将该Node+Express+MongoDB组成的服务端部署在Vultr的VPS上（新加坡机房，用来搭梯子的），由于操作系统是CentOS，在部署过程中部分操作略有不同，在此不再赘述。部署后将微信小程序中pages/index/index.js的查询函数中的URL修改为VPS/云服务器的公网IP:端口号，实现了全网访问服务： 至此，最小端到端系统实验完成 总结 本实验使我巩固了Node.js、MongoDB、Linux运维、网络原理等多方面知识，并对微信小程序的开发有了一定了解，增强了我对新事物的探索能力。我将在继续深入钻研既学技术的同时努力接触新技术，让自己的技术栈更加充实]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Linux</tag>
        <tag>网络</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JavaScript实现网页自动刷新]]></title>
    <url>%2F2018%2F10%2Fweb-page-auto-refresh-by-JavaScript%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多时候我们需要让网页不断刷新来达到持续监视或刷访问次数等目的，我们可以通过简单的JS脚本来实现网页自动刷新的操作。123456789101112131415161718var timeout = prompt("设置刷新时间间隔[S]");var current = location.href;function reload() &#123; setTimeout('reload()', 1000 * timeout); var myFrame = "&lt;frameset cols=\'*\'&gt;&lt;frame src=\'" + current + "\' /&gt;&lt;/frameset&gt;"; with (document) &#123; write(myFrame); void(close()); &#125;&#125;if (timeout &gt; 0) &#123; setTimeout('reload()', 1000 * timeout);&#125; else &#123; location.replace(current);&#125; 我们可以打开浏览器提供的开发者工具（如Chrome为F12），进入控制台，复制以上代码来实现功能。为了更加简化操作步骤，我们可以将以下压缩后的JS代码保存至书签栏/收藏夹（Ctrl+D），这样即可快速调用：1javascript:&#123;function reload()&#123;setTimeout('reload()',1000*timeout);var myFrame="&lt;frameset cols='*'&gt;&lt;frame src='"+current+"' /&gt;&lt;/frameset&gt;";with(document)&#123;write(myFrame);void(close())&#125;&#125;var timeout=prompt("设置刷新时间间隔(s)");var current=location.href;if(timeout&gt;0)&#123;setTimeout('reload()',1000*timeout)&#125;else&#123;location.replace(current)&#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C/C++中主函数的声明及返回值问题]]></title>
    <url>%2F2018%2F09%2Fabout-main-function-declaration-and-returned-value%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在C/C++程序中有时会见到采用诸如void main()等方式来声明主函数，很多人在主函数返回值的问题上也略显随意。经过查阅多版本的C、C++标准文档与相关书籍，我将我的结论与认识总结于此。不可避免地，其中可能包含我错误的认识，欢迎大家指正。 main()函数的函数类型关于main()的原型，C89/99/11以及C++98/03/11/14等标准给出的说法略有出入，尤其在早期标准中差异更为显著。然而，共同的，在任何一个版本的标准中，均未承认void main()这种声明方式。首先可以得出结论：void main()为错误写法，所有编译器都没有理由支持该种写法。 在K&amp;R C与C89里，若函数没有显式声明返回类型，则默认是int，因此在早期C程序中经常出现这样的主函数：12345main()&#123; // 函数体 return 0;&#125; 这种写法在早期标准中是被认可的，main()等价于int main()。但是，C99标准不再支持函数的int类型的默认设置，因此该写法被废止，新的编译器不再允许此类main函数。 在C99/11标准中，明确定义了对于标准的main函数的两个原型：12int main(void) &#123; /* ... */ &#125;int main(int argc, char *argv[]) &#123; /* ... */ &#125; 为了增强说服力，我在《C Primer Plus》（第六版）（该书以1999 ISO/ANSI作为标准）中找到了这样一段话： &emsp;&emsp;如果浏览老版本的C代码，您将发现程序常常以：main()这种形式开始。C90标准勉强允许这种形式，但是C99标准不允许。因此即使您当前的编译器允许，也不要这么做。&emsp;&emsp;您还将看到另一种形式：void main()&emsp;&emsp;有些编译器允许这种形式，但是还没有任何标准考虑接受它。因而，编译器不必接受这种形式，并且许多编译器也不这样做。再者说，如果坚持使用标准形式，那么当您把程序从一个编译器移到另一个编译器时也不会有问题。 main()函数的形式参数此部分C与C++略有差异 C int main()和int main(void)在C语言中是有区别的：123int main() &#123; /* ... */ &#125;// 不等价于int main(void) &#123; /* ... */ &#125; 在C语言中参数列表为空(即不提供参数列表也不为void)，表示不提供参数数量和参数类型信息：1234567891011#include &lt;stdio.h&gt;void func() // 参数列表为空不代表不接受参数&#123; print("Hello, world\n");&#125;int main(void)&#123; func(1,2,3,4); // 调用func()，并传递了参数 return 0;&#125; 因此在C中，main函数的参数部分应该以以下两种方式描述：12int main(void) &#123; /* ... */ &#125;int main(int argc, char *argv[]) &#123; /* ... */ &#125; 不应该写：1int main() &#123; /* ... */ &#125; C++ 由于C和C++中对于函数参数列表的规则并不一致(C++中参数列表为空代表不接收任何参数)。所以C++中main的原型和ISO C也并不太一样。在C++中，下面两种写法是完全等价的。123int main() &#123; /* ... */ &#125;// 等价于int main(void) &#123; /* ... */ &#125; 以上两种形式均符合标准。 main()函数的返回值上文指出，main()应以int类型定义，故需要返回一个int类型的返回值到操作系统。在早期标准中，主函数中的return 0;是可以省略的，main()最后如果没有返回值，则会自动return 0;，但是记住，只有main函数是这样，其他函数不能省略return。自C99/C++98以来，主函数的返回值为强制，若漏掉了返回语句，大多数编译器会给出警告，但仍将编译程序。 return 0;：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数 return -1;：一般用在子函数结尾，按照程序开发的一般惯例，表示该函数失败 main()必须要有返回值的原因是：在C和C++中使用return-statement都是将return的值作为参数来调用exit/std::exit来终止程序。此外，返回值对于某些操作系统（包括DOS和UNIX）而言，具有实际的用途。以Windows为例，编译以下程序：12345/* test.c */int main(void)&#123; return 0;&#125; 在命令提示符下运行命令test &amp;&amp; dir，得到以下结果：123456789101112D:\code&gt;test &amp;&amp; dir D:\code 的目录2018/09/26 10:31 &lt;DIR&gt; .2018/09/26 10:31 &lt;DIR&gt; ..2018/09/26 10:29 35 test.c2018/09/26 10:30 41,664 test.exe 2 个文件 41,699 字节 2 个目录 605,409,882,112 可用字节D:\code&gt; test.exe正常结束后执行dir指令，输出了目录列表。若将第4行返回值由0改为-1:1return -1; 再次执行test &amp;&amp; dir命令：123D:\code&gt;test &amp;&amp; dirD:\code&gt; test.exe将-1返回给了操作系统，即程序异常结束，因此windows没有继续执行dir打印目录列表。总结一下，正常情况下main函数应以return 0;结束，不能随意更改返回值。 结语综上所述，一般情况下，C/C++程序的主函数都应该以如下方法编写：12345int main(void) // void在C++中可省，C不建议省&#123; // 函数体 return 0;&#125; 即使其他不标准的声明方法也许不会影响程序的正常编译、运行，但为了程序的可移植性与易维护性，我们应该养成良好的编码习惯，利人利己。 参考文献[1] Stephen Prata 编著，《C Primer Plus》，人民邮电出版社，2005年，§2.2 §9.2 §B.5.[2] Andrew Koenig 编著，《C陷阱与缺陷》，人民邮电出版社，2008年，§2.1 §7.1.[3] Stephen Prata 编著，《C++ Primer Plus》，人民邮电出版社，2012年，§2.1 §2.4.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训小结]]></title>
    <url>%2F2018%2F09%2Fsummary-of-military-training%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2018年9月2日，我与全新结识的同学们踏上了前往北京八达岭军训基地的汽车。天蒙蒙亮，我怀着既紧张又期待的心情开始了为期14天的军事训练。&emsp;&emsp;在军训过程中，我感受到了军旅生活的艰辛与严谨。生活中，同学们在承训教官的悉心指导与监督下坚持每天认真整理内务，培养了雷厉风行的优良作风。同学们士气高涨，“将士们，听党指挥，能打胜仗，作风优良”的歌声时常响彻整个基地；训练中，同学们挥汗如雨，在飞沙走石的训练场上留下了自己坚持的痕迹。教官们的严格要求使我们进一步深化了听从指挥、令行禁止的意识。&emsp;&emsp;此外，穿插在军训期间的演讲比赛、拔河比赛、合唱比赛等文体活动更是为同学们提供了展示自我、结识朋友的机会。同学们在竞争中学会团结、学会合作、学会理解，为今后的学习生活打下了坚实的基础。&emsp;&emsp;9月15日，伴随着《分列式进行曲》，我昂首走过检阅台，展示了刻苦训练的成果。这同时也标志着短暂的军训时光渐渐走向尾声。&emsp;&emsp;通过这次军训，我受益匪浅。我意识到了优良的作风、强健的体魄、坚强的意志是个人与团队进步的先决条件，我将把军训中养成的优良习惯延续到今后的学习生活中。军训不仅提升了我的国防意识，更让我深刻认识到和平的来之不易。铭记历史，缅怀先烈，珍爱和平，开创未来。我将牢牢记住并践行这十六个字，让祖国强大，让世界和平！]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生何其苦]]></title>
    <url>%2F2018%2F08%2Fthe-bitter-life%2F</url>
    <content type="text"><![CDATA[微博上看到的一段话，若有所思，也许若干年后再回首看到此文会别有一番感悟，故转载于此。 25岁，你找到了一份“高薪”工作爸妈开心，同学羡慕你对工作充满热情，全部心思扑在工作上 35岁你因为身体越来越差加班越来越少晋升的速度也越来越缓慢收入原地踏步，生活压力却越来越大 那天下班，媳妇告诉你孩子要上幼儿园了双语的一个月3000你皱了皱眉头，那边就已经不耐烦了“四单元的老王家孩子，一个月6000”“你已经这样了，你想让孩子也输？”你没说话，回屋绐媳妇转了6000块钱这笔钱，你原本打算绐自己过个生日，买个新电脑 38岁，孩子上了一年级老师说一年级最关键，打好基础很重要你笑着说，是是是，老师您多照顾 新生接待的老师看着你不明事理的脸给你指了一条明路“课外辅导班，一个月2200” 40岁的时候，孩子上了三年级老师说，三年级，最关键，承上启下很重要你笑着说：是是是，正打算再报个补习班 44岁，孩子上了初中有一天回到家，她对你说爸爸，我想学钢琴你没什么犹豫的你以为这些年，你已经习惯了 那句“爸爸现在买不起”你始终说不出口好在孩子比较懂事她说：爸爸没事，要不我先学陶笛也可以你看着这么懂事的孩子，却开心不起来 46岁，孩子上了一个不好不差的高中有一天你在开会，接到了老师的电话电话里说你的孩子在学校打架了叫你去一趟你唯唯诺诺的和那个比你还小5岁的领导请了个假 到学校又被老师训了一通无非台词就是那一句你们做家长的就知道工作，能不能陪陪孩子 你看着这个老师，有点可笑好像当时说：家长在外辛苦点多赚点钱让孩子多补补课的和他不是一个人 50岁，孩子上了大学很争气，是一个一本他学的专业你有点看不懂你只知道工作不一定好找而且学费还死贵你和他深夜想聊聊准备了半斤白酒，一碟花生米你说着那些曾经你最讨厌的话 还是要为以后工作着想挑个热门的专业活着比热爱重要 你们从交流变成了争吵你发现，你老了老到可能都打不过这个18岁的孩子你说不过他，只能说一句：我是你爸爸！孩子看着你，知道再怎么争辩都没用这场确立你最后威严的酒局不欢而散你听的不真切在孩子回自己屋的路上好像叨叨了一句“我不想活的像你一样” 怎么就哭了呢？50岁的人了一定是酒太辣了，对不对一定是酒太辣 55岁，孩子工作了，似乎有一点理解你了但你却反了过来，你说不要妥协 60岁，辛苦了一辈子，想出去走走身边的那个人过了30年你依旧分不清到底喜不喜欢你们开始规划旅游路线这么多年了你们还是存在分歧，还是在争吵某个瞬间，你觉得这样可能也挺好 一切都准备好了儿子说：爸妈，我工作太忙了可以帮我照顾一下孩子么你们退了机票，又回到了30年前]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>转载</tag>
        <tag>人生</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷信科学与科学迷信]]></title>
    <url>%2F2017%2F04%2Fsuperstitious-science-and-scientific-superstitions%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是我于2017年4月11日进行的简短演讲的演讲稿，文中简单阐述了我对科学以及迷信间关系的理解，在此记录，因为今天的故事是明天的回忆。 迷信科学与科学迷信 &emsp;&emsp;大家好，今天我想谈谈我对迷信科学与科学迷信的理解与看法。&emsp;&emsp;众所周知，科学与迷信是两个相互对立的实践方法。古往今来，人类思维的发展可大致分为三个阶段，即神学、玄学与科学，这是“汉语拼音之父”周有光对人类的认识阶段作出的划分。神学依靠天命，那时的人们相信是神指导着他们的生活、行为、思想以及命运，上帝是不容置疑的。魏晋时期老庄“玄远之学”的起源为迷信增添了推理的成分，《周易》便是玄学的典型代表，它脱离神学，但不可否认，它仍是形而上的。十六世纪，哥白尼的“日心说”，率领人类进入科学的认知阶段。&emsp;&emsp;科学是一个可解释的、有序的知识系统，在广义上还被认为是可靠的代名词；而迷信指盲目的相信、不理解的相信，它象征着愚昧与落后。二者完全对立，但又界限模糊。如今，人们的最大迷信叫做“科学”。生活中，人们大多对科学非常崇拜，往往对科学不假思索地认可。试想：一名村干部在向农民们推广化肥时，他会理直气壮地说：“这是科学！”尽管他可能不懂这其中的化学原理，但他也会底气十足。这恰恰说明科学在大众心中的形象是个神！把自己不懂的东西尊奉到一个至高无上的地位，这种态度正是迷信。&emsp;&emsp;在互联网时代，人们在享受便利的同时也不得不接受如潮水般涌来的资讯，其中鱼龙混杂，充斥着大大小小的谣言与骗局。在这些资讯中，最令人难辨真假的大都与科学有关，例如：转基因食物究竟对人体有无害处？碘盐究竟能不能预防辐射？维生素C能治疗感冒吗？这些信息离每个人的生活都非常近，因此即使科学界尚未对此盖棺定论，但只要打着“科学”的旗号，无论依据是否可靠，多数人都会信服，尤其是中老年人。我想，之所以科技类谣言编造成本低，是因为大多科学谣言的论据不为大众所熟悉，国民科学素养的低下导致他们丧失了判断能力，只能盲目地相信，这无异于迷信。&emsp;&emsp;科学只是前人经过实践探究得出的规律性结论，并非绝对意义的真理。哥白尼的“日心说”推翻了广为认可的“地心说”，而后人又指出了哥白尼观点中的瑕疵；开普勒发现了托勒密折射规律的错误但仍没能给出正确的规律，最终由斯涅耳找出了正确的折射定律；牛顿推翻了亚里士多德的观点，而后量子物理的发展又找出了经典力学的局限性。这些发现都引起了人类对宇宙认识的巨大思想变革。由此可见，我们不必迷信科学，要辩证地看待科学，提高自身科学素养，勇于抱着“大胆假设，小心求证”的心态挑战科学。&emsp;&emsp;反观迷信，只要是稍有些学识的人大都会说迷信是值得唾弃的，殊不知迷信无处不在，它也在潜移默化地改变着我们的生活。据调查，美国作为科学教育最为完善的国家之一，有三成以上的国民相信占星术，并乐意按照星座指南上的指示行事。中国的大街小巷上也不乏风水先生与算卦先生，尽管人们知道这是玄学也愿意以此为自己祈求好运。这样的例子在我们身边也不少见，例如社交媒体上，经常出现诸如“转发即可带来好运”之类的信息，这种事情在考试前尤为常见。不少人照做后真的灵验了，你可能会说这只是巧合。但事实上，这不完全是巧合，这种现象在心理学中叫做“心理暗示”，是人们日常生活中最常见的心理现象。这种祈求尽管不一定有根据，但由于主观上已肯定了它的存在，心理上便竭力趋向于这项内容，这便是信念的力量。如果我们能适当的、科学的运用这种心理暗示，那么迷信也不失为一种利于发展的方式。&emsp;&emsp;综合来看，即使是科学也可能被颠覆，而迷信也并非有百害而无一利。杜绝迷信科学，学会科学迷信，才是最佳发展之道。&emsp;&emsp;我的演讲到此结束，感谢各位的倾听！ 2017年4月9日]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>杂谈</tag>
        <tag>高中</tag>
        <tag>演讲</tag>
        <tag>玄学</tag>
        <tag>科学</tag>
        <tag>迷信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职业无高低]]></title>
    <url>%2F2017%2F02%2Fall-jobs-are-equal%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近日，清华女学霸石悦因选择做游戏主播为职业而走红网络，网友大都报以不支持的态度，原因是在大多数人的认知中，游戏主播是个低贱的行业，不学无术的人才会以此为出路。我想这种扭曲的观念的产生原因有二：一是网络直播作为新兴产业，还未能被大众认可，尤其是在中老年群体中，旧思想根深蒂固，无法接受新鲜事物；二是有许多人不能以端正的态度审视游戏主播这一职业，他们仅仅因为游戏主播大都学历偏低就以偏概全，贬低这种职业的社会地位，从门缝里看游戏主播，导致了这种扭曲的社会怪象。&emsp;&emsp;我认为，术业有专攻，无论在哪个行业之中都会有贵有贱，但职业本身并无高低贵贱之分。即使是大部分人看不起的清洁工人，也不乏有成功人士。因此，我认为石悦选择自己的爱好作为职业是对这一职业的贡献，不应受到贬低，更不应因自己清华出身就遭到谴责。&emsp;&emsp;职业无高低，贵贱在自身，社会需要以包容的态度接纳新观念、新行业。唯有这样，才能构成一个健全的社会。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>主播</tag>
        <tag>写作</tag>
        <tag>杂谈</tag>
        <tag>职业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux实现《黑客帝国》中的“字符雨”]]></title>
    <url>%2F2016%2F11%2Frealizes-character-rain-in-the-matrix%2F</url>
    <content type="text"><![CDATA[《黑客帝国》电影里满屏幕代码的“数字雨”，在 Linux 里面你也可以轻松实现这样的效果，你只需要一个命令：cmatrix。 需要先安装，因为 Ubuntu 没有预装： 12$ sudo apt-get update$ sudo apt-get install cmatrix 装好之后先不要急着执行，为了看到更好的效果，我们需要先修改终端的主题配色，修改为黑底绿字。 这时执行：$ cmatrix就可以看到效果了，按F11可全屏控制台，Ctrl+C可以终止程序。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的Banner生成工具]]></title>
    <url>%2F2016%2F11%2FBanner-generation-tools-under-Linux%2F</url>
    <content type="text"><![CDATA[一、banner——使用#生成banner使用apt-get安装：12$ sudo apt-get update$ sudo apt-get install sysvbanner 使用方法：1$ banner TestText 效果：1234567####### ####### # ###### #### ##### # ###### # # ##### # # # # # # # # # # ##### #### # # ##### ## # # # # # # # ## # # # # # # # # # # # # ###### #### # # ###### # # # 另一个命令：1$ printerbanner -w 50 A ‘-w’参数指定打印宽度，因为我们的环境在屏幕中显示比较小，必须要加上宽度限制。效果：123456789101112131415161718192021# # ########## ##### #### ## #### ## ##### ## ##### ## ##### ## ############ ## ############## ## ############## ############## # ################ ############################################### 二、figlet——使用一些普通字符生成banner使用apt-get安装：1$ sudo apt-get install figlet 使用方法：1$ figlet TestText 使用参数-f可以指定字体，如figlet -f slant EastCoke使用参数-ctf可以使banner居中并且与终端等宽输出到文件可以使用figlet -p &lt; /path/to/file 效果：12345 _____ _ _____ _ |_ _|__ ___| ||_ _|____ _| |_ | |/ _ \/ __| __|| |/ _ \ \/ / __| | | __/\__ \ |_ | | __/&gt; &lt;| |_ |_|\___||___/\__||_|\___/_/\_\\__| 三、toilet——使用一些复杂的彩色特殊字符生成banner使用apt-get安装：1$ sudo apt-get install toilet 使用方法：123$ toilet -f bigmono9 -F gay TestText$ toilet -f mono12 -F metal TestText 效果(截图)： 如果希望在每次打开终端的时候都会显示出banner，可以使用下面的命令：1echo &apos;toilet -f bigmono9 -F gay EastCoke&apos; &gt;&gt; ~/.bashrc]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[航天精神依然在]]></title>
    <url>%2F2016%2F11%2Fthe-spirit-of-space-is-still-there%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;1970年4月24日，中国第一颗人造地球卫星“东方红一号”成功发射，中国航天事业的序幕从此拉开。50多年来，中国航天事业从无到有、从小到大、从弱到强，人们记住了钱学森，记住了杨利伟，也记住了航天“三大”精神，即航天传统精神、“两弹一星”精神和载人航天精神。然而时至今日，中国航天事业已走向成熟，进入了平稳发展时期，没有了重大突破，没有了所谓“大新闻”，因此，航天精神慢慢不再被人提及，人们逐渐淡忘了这曾经催人奋进的灵魂精神。&emsp;&emsp;但是，尽管“东方红一号”早已从我们的眼前消失，但航天精神仍然能应用在各行各业的各个领域。“自强不息，顽强拼搏，团结协作，开拓创新”对于今天的人们仍是发展的动力源泉。2016年8月，中国成功把世界首颗量子科学实验卫星“墨子号”送入太空。此前，潘建伟和他的团队为了这次“全球首发”，做了十一年的分发实验。这十一年间，他们刻苦工作，发扬了“特别能吃苦、特别能战斗、特别能攻关、特别能奉献”的航天精神，为全世界的网络通信安全做出了重大贡献。他们的成功与航天精神是密不可分的。&emsp;&emsp;然而，今天也有不少人违背了航天精神，因此他们与成功背道而驰。如今，中国是一个程序员过剩的国家，然而中国的软件产业仍不能跻身世界前列。举个简单的例子，在几十年前，计算机进行某种计算需要20秒，若是程序员对算法、数据结构进行深度、广度优化，时间可以减半，即10秒完成运算，时间缩短了整整10秒，这种优化就十分有意义；但随着纳米级处理器的迅猛发展，如今的家用计算机仅需0.02秒即可完成原程序，此时若是进行同样的算法改造，可使时间缩为0.01秒，仅有0.01秒之差。不少程序员就忽视了这0.01秒，因为为了这0.01秒他们可能需要几天的时间来攻关、优化，这看似可以理解。然而这些看似聪明的人殊不知不积跬步无以至千里，不积小流无以成江海。一旦程序写大，效率问题就随之暴露，这就是中国人写不出优秀的软件、写不出自己的操作系统的原因。此外在Github等开源平台中，优秀的开源项目多是出自他国人之手，中国程序员中愿意把自己的心血奉献出来的却寥寥无几，因此他们得不到交流的机会，自身水平也就很难提高。通过以上两个实例不难看出，不少中国程序员“特别怕吃苦、特别怕战斗、特别怕攻关、特别怕奉献”，与航天精神相悖，因此中国软件产业难有长足发展。若是人们都能发扬航天精神，恐怕早已不是今天这幅景象。&emsp;&emsp;有的人“特别能吃苦、特别能战斗、特别能攻关、特别能奉献”，他们大都走向成功，有的人“特别怕吃苦、特别怕战斗、特别怕攻关、特别怕奉献”，他们难有成才者。我想航天精神在今天仍然发挥的作用已不言而喻。航天精神依然在，它早已不再局限于航天领域，它已经刻在每一个想要取得辉煌成就的人心中。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>爱国</tag>
        <tag>评析</tag>
        <tag>航天精神</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对公网、路由器、内网关系的理解]]></title>
    <url>%2F2016%2F10%2Fthe-understanding-of-the-relationship-between-WAN-routers-and-LAN%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;怎样才能让别人直接访问我的本地网站，这个问题困扰了我很久，原因在于本机IP为类似于192.168.1.xxx的内网IP，显然在公网（全域网）别人是访问不到这里的。今天我对这三者有了更加深刻、透彻的理解。&emsp;&emsp;最简单的，在同一局域网（如同一WIFI下）的设备可以通过这个本地IP（本文以192.168.1.106为例）访问本机。首先在本机上跑一个WEB服务器软件，这里使用的是Nginx，原因是轻小方便，当然Apache等Web服务器也是可以的。&emsp;&emsp;此时，用浏览器访问Localhost（即http://127.0.0.1）即可看到服务器的index.html。&emsp;&emsp;当然，在同一局域网内的其他设备也可以通过你的局域网IP（Windows下可以用ipconfig命令查看IPv4地址）访问此站。顺便一提IPv4指的就是有四个字段的IP地址（xx.xx.xx.xx），而现在逐渐流行的IPv6，顾名思义就是有六个字段的IP地址（xx.xx.xx.xx.xx.xx）。&emsp;&emsp;此时我们已经实现了让同一局域网的设备访问自己的Web服务器。但如何让不在局域网的设备访问呢？这就需要路由器的功能及其原理。&emsp;&emsp;在我们的家中，若是接入了互联网，便可以通过网线让自己的设备接入互联网。但如何让所有的设备都能接入网络呢？路由器的存在主要就是为了解决这个问题。&emsp;&emsp;在路由器的管理界面（地址通常是192.168.1.1或192.168.0.1），我们可以找到接入的公网IP地址，这也就是互联网服务提供商（ISP）分给我们的IP。&emsp;&emsp;当其他设备接入这个路由器后，路由器就会建立一个局域网，介入的设备便会被分得内网IP，如我的计算机的局域网IP就是192.168.1.106，它的作用域仅仅是在这个局域网内。此外，路由器本身也是一个系统，它的内网IP一般是192.168.1.1。画一个简图就是这样：&emsp;&emsp;因此，在一个局域网内的设备可以互访，但外部的访问请求只能发送到180.xxx.xxx.216，也就是路由器，但路由器本身并不是Web服务器，因此无法发送请求的数据。如果Web服务器是局域网内的一台设备，那么就需要通过路由器映射80端口（网页传输的默认端口）。具体步骤是：打开路由器管理界面，进入“转发规则”菜单（不同路由器可能不尽相同，但都大同小异），服务端口号填写80，也可以自己指定任意空闲端口，IP地址填写Web服务器的局域网IP（192.168.1.106），协议选择TCP，常用服务端口号选择HTTP。生效后任何接入互联网的设备就都可以通过你路由器的公网IP访问你的Web服务器了。&emsp;&emsp;总结一下，所谓“转发”就是路由器把外来请求下放到局域网中指定的Web服务器，简图如下：]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>网络</tag>
        <tag>Web服务器</tag>
        <tag>局域网</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种语言画国旗]]></title>
    <url>%2F2016%2F10%2Fdraw-the-national-flag-by-four-languages%2F</url>
    <content type="text"><![CDATA[国庆假期，闲来无事，用HTML、C、Java、Python四种语言画国旗 HTML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;html&gt;&lt;head&gt; &lt;script&gt; var col=new Array("red","brown"); var ticker=0; var step=0; function drawBackground()&#123; var g=document.getElementById("background").getContext("2d"); var grd=g.createLinearGradient(-560+ticker, 0, 1400+ticker,0); for (var i=0; i&lt;10; i++) grd.addColorStop(i/10,col[(i + step)%col.length]); ticker=ticker+10; if (ticker&gt;=196)&#123; ticker=0; step++; &#125; g.fillStyle=grd; g.fillRect(0,0,1600,700); &#125; function preperation()&#123; setInterval('drawBackground()',100); &#125; &lt;/script&gt; &lt;style type="text/css"&gt; #myCanvas&#123; z-index:2; position:absolute; left:0px; top:-5px; &#125; #background&#123; z-index:1; position:absolute; left:0px; top:0px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body onLoad="preperation()"&gt; &lt;canvas id="myCanvas" width="900" height="600" &gt; Your browser does not support the HTML5 canvas tag. &lt;/canvas&gt; &lt;canvas id="background" width="1600" height="700" &gt;&lt;/canvas&gt; &lt;script&gt; var x=new Array(0,12,54,18,28,0,-28,-18,-54,-12,0); //五角星样品坐标xx数组 var y=new Array(-53,-17,-17,1,45,19,45,1,-17,-17,-53); //五角星样品坐标y数组 var c=document.getElementById("myCanvas"); var ctx=c.getContext("2d"); //获得画笔 //样品数组x轴坐标 a , 和y轴坐标 b //指定位置[locationX,locationY] //真实五角星的大小，与样品五角星尺寸之比 f //五角星画完后，旋转的角度 rotation function star(a,b,locationX,locationY,f,rotation)&#123; ctx.save();//记录画图（画笔）的初始环境 ctx.translate(locationX,locationY); ctx.rotate(rotation*Math.PI/180.0); ctx.beginPath(); ctx.moveTo(Math.round(a[0]*f),Math.round(b[0]*f)); for (var i=1;i&lt;a.length;i++) ctx.lineTo(Math.round(a[i]*f),Math.round(b[i]*f)); ctx.closePath(); ctx.fillStyle="yellow"; ctx.fill(); ctx.restore();//还原画图（画笔）的初始环境 &#125; star(x,y,165,165,1.4,0);//画大五角星 star(x,y,301,65,0.5,30);//画小五角星 star(x,y,362,126,0.5,-30);//画小五角星 star(x,y,359,216,0.5,0);//画小五角星 star(x,y,301,273,0.5,30);//画小五角星 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;windows.h&gt;#include &lt;math.h&gt;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);void DrawFiveStarFlag(HDC hdc, int x, int y, int w);void DrawFivePointedStar(HDC hdc, int x, int y, int r, float d);/* Current app instance */HINSTANCE hInst;/* Make the class name into a global variable */TCHAR szClassName[] = TEXT("WindowsApp");int WINAPIWinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nFunsterStil)&#123; HWND hwnd; /* This is the handle for our window */ MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* Save this instance */ hInst = hThisInstance; /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows's default color as the background of the window */ wincl.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let's create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ TEXT("TestPie"), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ 0, /* where the window ends up on the screen */ CW_USEDEFAULT, /* The programs width */ 0, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nFunsterStil); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) &#123; /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); &#125; /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;&#125;/* This function is called by the Windows function DispatchMessage() */LRESULT CALLBACKWindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; PAINTSTRUCT ps; HDC hdc; switch (message) /* handle the messages */ &#123; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); /* TODO: Add any drawing code here... */ DrawFiveStarFlag(hdc, 50, 50, 300); EndPaint(hwnd, &amp;ps); break; case WM_DESTROY: PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; default: /* for messages that we don't deal with */ return DefWindowProc (hwnd, message, wParam, lParam); &#125; return 0;&#125;/* 画五角星 * 参数：hdc画图句柄，xy中心点坐标，r外圆半径，d偏斜角度（逆时针） */void DrawFivePointedStar(HDC hdc, int x, int y, int r, float d)&#123; float r0 = 0.381966*r; //内圆半径：r*sin(0.1*M_PI)/sin(0.7*M_PI) int i; POINT p[10]; //计算10个顶点的坐标（72度为实心五角星，144为空心五角星） for(i=0; i&lt;5; i++) &#123; p[2*i].x = x + r*cos((i*72-18+d)*M_PI/180); p[2*i].y = y + r*sin((i*72-18+d)*M_PI/180); p[2*i+1].x = x + r0*cos((i*72+18+d)*M_PI/180); p[2*i+1].y = y + r0*sin((i*72+18+d)*M_PI/180); &#125; //画五角星 Polygon(hdc, p, 10);&#125;/* 画五星红旗 * 参数：hdc画图句柄，xy旗左上角坐标，w旗宽 */void DrawFiveStarFlag(HDC hdc, int x, int y, int w)&#123; COLORREF RED = RGB(255, 0, 0), YELLOW = RGB(255, 255, 0); HPEN hPen1 = CreatePen(PS_SOLID, 1, RED), hPen2 = CreatePen(PS_SOLID, 1, YELLOW); HBRUSH hBrush1 = CreateSolidBrush(RED), hBrush2 = CreateSolidBrush(YELLOW); //画旗面 SelectObject(hdc, hPen1); SelectObject(hdc, hBrush1); Rectangle(hdc, x, y, x+w, y+2*w/3); //画5星 SelectObject(hdc, hPen2); SelectObject(hdc, hBrush2); DrawFivePointedStar(hdc, x+w/6, y+w/6, w/10, 0); //大星 DrawFivePointedStar(hdc, x+w/3, y+w/15, w/30, 18); //4个小星，倾斜角度都是估的 DrawFivePointedStar(hdc, x+2*w/5, y+2*w/15, w/30, 45); DrawFivePointedStar(hdc, x+2*w/5, y+7*w/30, w/30, 9); DrawFivePointedStar(hdc, x+w/3, y+3*w/10, w/30, 27); DeleteObject(hPen1); DeleteObject(hPen2); DeleteObject(hBrush1); DeleteObject(hBrush2);&#125; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.awt.RenderingHints;import java.awt.geom.AffineTransform;import java.awt.geom.GeneralPath; import javax.swing.JFrame; public class NationalFlag extends JFrame &#123; private int width = 288,height = width/3*2; private double maxR = 0.15, minR = 0.05; private double maxX = 0.50, maxY = 0.50; private double[] minX = &#123;0.75, 0.85, 0.85, 0.75&#125;; private double[] minY = &#123;0.35, 0.45, 0.60, 0.70&#125;; public NationalFlag() &#123; setTitle("国旗 - by PotatoChipsNinja"); setDefaultCloseOperation(EXIT_ON_CLOSE); &#125; @Override public void paint(java.awt.Graphics graphics) &#123; super.paint(graphics); java.awt.Graphics2D g = (java.awt.Graphics2D)graphics; g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); //棋面 g.setColor(java.awt.Color.red); g.fillRect(50, 50, width, height); g.setColor(java.awt.Color.yellow); //画大星星 double ox = height*maxX, oy = height*maxY; g.fill(createPentacle(ox,oy,height*maxR,-Math.PI/2)); //画小星星 for(int idx =0;idx &lt; 4;idx ++)&#123; double sx = minX[idx]*height, sy = minY[idx]*height; double theta = Math.atan2(oy-sy,ox-sx); g.fill(createPentacle(sx,sy,height*minR,theta)); &#125; &#125; /** * 创建一个五角星形状. 该五角星的中心坐标为(sx,sy),中心到顶点的距离为radius,其中某个顶点与中心的连线的偏移角度为theta(弧度) * * @return pentacle 一个☆ */ public static java.awt.Shape createPentacle(double sx, double sy, double radius,double theta) &#123; final double arc = Math.PI / 5; final double rad = Math.sin(Math.PI / 10) / Math.sin(3 * Math.PI / 10); GeneralPath path = new GeneralPath(); path.moveTo(1, 0); for (int idx = 0; idx &lt; 5; idx++) &#123; path.lineTo(rad * Math.cos((1 + 2 * idx) * arc),rad * Math.sin((1 + 2 * idx) * arc)); path.lineTo(Math.cos(2 * (idx + 1) * arc),Math.sin(2 * (idx + 1) * arc)); &#125; path.closePath(); AffineTransform atf = AffineTransform.getScaleInstance(radius, radius); atf.translate(sx / radius, sy / radius); atf.rotate(theta); return atf.createTransformedShape(path); &#125; public static void main(String[] args) &#123; NationalFlag flag = new NationalFlag(); flag.setBounds(100, 100, 400, 400); flag.setVisible(true); &#125;&#125; Python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding=utf-8import turtleimport math def draw_polygon(aTurtle, size=50, n=3): ''' 绘制正多边形 args: aTurtle: turtle对象实例 size: int类型，正多边形的边长 n: int类型，是几边形 ''' for i in xrange(n): aTurtle.forward(size) aTurtle.left(360.0/n) def draw_n_angle(aTurtle, size=50, num=5, color=None): ''' 绘制正n角形，默认为黄色 args: aTurtle: turtle对象实例 size: int类型，正多角形的边长 n: int类型，是几角形 color: str， 图形颜色，默认不填色 ''' if color: aTurtle.begin_fill() aTurtle.fillcolor(color) for i in xrange(num): aTurtle.forward(size) aTurtle.left(360.0/num) aTurtle.forward(size) aTurtle.right(2*360.0/num) if color: aTurtle.end_fill() def draw_5_angle(aTurtle=None, start_pos=(0,0), end_pos=(0,10), radius=100, color=None): ''' 根据起始位置、结束位置和外接圆半径画五角星 args: aTurtle: turtle对象实例 start_pos: int的二元tuple，要画的五角星的外接圆圆心 end_pos: int的二元tuple，圆心指向的位置坐标点 radius: 五角星外接圆半径 color: str， 图形颜色，默认不填色 ''' aTurtle = aTurtle or turtle.Turtle() size = radius * math.sin(math.pi/5)/math.sin(math.pi*2/5) aTurtle.left(math.degrees(math.atan2(end_pos[1]-start_pos[1], end_pos[0]-start_pos[0]))) aTurtle.penup() aTurtle.goto(start_pos) aTurtle.fd(radius) aTurtle.pendown() aTurtle.right(math.degrees(math.pi*9/10)) draw_n_angle(aTurtle, size, 5, color) def draw_5_star_flag(times=20.0): ''' 绘制五星红旗 args: times: 五星红旗的规格为30*20， times为倍数，默认大小为10倍， 即300*200 ''' width, height = 30*times, 20*times # 初始化屏幕和海龟 window = turtle.Screen() aTurtle = turtle.Turtle() aTurtle.hideturtle() aTurtle.speed(10) # 画红旗 aTurtle.penup() aTurtle.goto(-width/2, height/2) aTurtle.pendown() aTurtle.begin_fill() aTurtle.fillcolor('red') aTurtle.fd(width) aTurtle.right(90) aTurtle.fd(height) aTurtle.right(90) aTurtle.fd(width) aTurtle.right(90) aTurtle.fd(height) aTurtle.right(90) aTurtle.end_fill() # 画大星星 draw_5_angle(aTurtle, start_pos=(-10*times, 5*times), end_pos=(-10*times, 8*times), radius=3*times, color='yellow') # 画四个小星星 stars_start_pos = [(-5, 8), (-3, 6), (-3, 3), (-5, 1)] for pos in stars_start_pos: draw_5_angle(aTurtle, start_pos=(pos[0]*times, pos[1]*times), end_pos=(-10*times, 5*times), radius=1*times, color='yellow') # 点击关闭窗口 window.exitonclick() if __name__ == '__main__': draw_5_star_flag()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>HTML</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>国旗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月盈则亏，水满则溢——读《红楼梦》有感]]></title>
    <url>%2F2016%2F08%2Fsense-of-reading-A-Dream-in-Red-Mansions%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在中国古典四大名著之一《三国演义》中开篇便有这样一句话：“话说天下大势，分久必合，合久必分。”这是指人或事物变化无常，分合无定。此句也用来表示人物或事情的发展分分合合拥有一定的必然性，是事物发展的规律和必然注定。我想这也是同为四大名著之一——《红楼梦》的作者想要告诉我们的。&emsp;&emsp;《红楼梦》全文都是围绕贾、史、王、薛四大家族的兴衰展开的。比如最后贾府的衰败，表面看上去是多种因素共同导致的：首先，贾府在当时的社会赫赫有名、盛极一时，必然会树敌众多，遭人嫉妒，有很大隐患；此外，长辈们对后代的教育不得力，使得子孙游手好闲，不思进取；其次，他们当时嚣张、专横、跋扈的作风得罪了不少人，也与权臣结怨；最后，也是最重要的是当时封建家族为利益联姻，大家运命相连，一荣皆荣，一损俱损，因此薛、王、史三家的衰落直接导致了贾府的崩盘。&emsp;&emsp;但是，列出这些所有的原因，可以全部归结于一个道理：盛极必衰。&emsp;&emsp;在现代汉语中，有很多表达类似盛极必衰这样的思想的词语，比如：物极必反、乐极生悲等等。早在春秋时期，儒家学派就已经意识到这个问题了，因此儒家推崇中庸思想。而《红楼梦》中这四大家族却都忽视了这个问题，这些封建贵族为了权势与钱财，不惜一切。表面温情脉脉，实际充满了勾心斗角和种种激烈的矛盾和斗争。他们这样做，只能换取一时的繁盛，换不来一世的安宁。&emsp;&emsp;《红楼梦》中最深刻的哲学思想，不是正义与邪恶的较量，也不是欲与理的纠缠，而是月盈则亏，水满则溢。在小说第一回中就有“瞬息间则又乐极悲生，人非物换，究竟是到头一梦，万境归空”，曹雪芹暗示了运势会因时间而轮回的道理。&emsp;&emsp;这个道理在我们的日常生活中同样适用。我们都有过这样的经历：有时越想办成一件事就越难成功，反而会在不经意间“无心插柳柳成荫”。在没有头绪的时候，与其绞尽脑汁，倒不如放轻松，休息片刻也许能够剑走偏锋、出奇制胜。无论如何，都不要采取极端的手段，否则就像四大家族那样，即便取得了短暂的成功，也不可能是长久之计。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>红楼梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟随时代的脚步——读《唐•吉诃德》有感]]></title>
    <url>%2F2016%2F08%2Fsense-of-reading-Don-Quixote%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;读了《唐·吉诃德》这部反骑士小说，我对理想与现实的区别有所感悟，但此书给我最大的启示是：要紧跟时代的脚步。&emsp;&emsp;很多人说唐·吉诃德没能实现理想是因为他的理想和现实之间存在矛盾。而我认为唐·吉诃德之所以失败，并不是因为他思想的错误，而是由于时代的变迁。鲁迅先生在把此书引入中国时就曾有过解读：“以此书为刺，揭示人以旧思想之难行于新时代也”。&emsp;&emsp;这部小说终结了骑士文学，书中主人公阿隆索·吉哈诺一切荒诞的行为看似匪夷所思，但如果在骑士没有绝迹的年代，他的行为就不会令人感到奇怪。因此，我们不能说唐·吉诃德的做法是错误的，只能说这并不为当今时代所接受。&emsp;&emsp;人类永远不会停止发展的脚步，优胜劣汰是大自然永恒的法则。仔细想想骑士为何会被淘汰，是因为人们发明了枪炮，自然就不会有人再去当骑士。而主人公看了无数骑士小说并深受其感染，他把已被时代淘汰的事物当作自己的理想，这在一开始就注定了他的失败。&emsp;&emsp;但这并不意味着旧事物、旧思想不重要。若没有地基哪会有参天大楼？从原始人类开始，人们一代一代地繁衍，每一代人都是站在前一代搭建好的平台上继续搭建，这使得人类文明发展到了如今的水平。既然如此，我们只需在前人努力的基础上继续发展，为何还要记录已经被淘汰的历史呢？这就好比一个公式，你使用时只需记住结论，但了解其推倒过程会让你有更深刻的认识。我想我们铭记历史是为了今后更好地发展，不要再走重复的路。&emsp;&emsp;理想能激励我们向前，但理想的确立要站在现实的基础之上，若与现实背道而驰，那充其量算是梦想，永远不可能实现。比如书中的唐·吉诃德，他的理想建立在已被淘汰的时代，而时代容不得倒退，他的理想就不可能在当时他所处的时代实现。当然把理想建立得离现实太过遥远也是荒诞的。仰望星空，脚踏实地，理想要建立在现实之上，不能总想一步登天，也不要走重复的路，我想这是作者塞万提斯想借讽刺唐·吉诃德警示人们的。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>唐·吉诃德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活不能等待别人来安排——读《平凡的世界》有感]]></title>
    <url>%2F2016%2F08%2Fsense-of-reading-the-Ordinary-World%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;读了这部讴歌劳动者的伟大作品《平凡的世界》，我感触颇多。起初，我不明白此书为何名叫“平凡的世界”，通篇读完后，我觉得真正平凡的人一定不平凡。&emsp;&emsp;何为平凡？我认为平凡不仅仅是无特色或无区别，更是一种为人处世的良好心态，这与儒家的中庸思想不谋而合。主人公孙少安、孙少平尽管生活历尽艰辛、苦苦挣扎，但他们从未言弃，积极与命运作斗争,追求自己的幸福。他们自强不息的精神带给苦难中的劳动者希望与动力，我想这也是路遥先生作此小说的目的。&emsp;&emsp;不同于其他现实主义小说作家，路遥的《平凡的世界》主旨并不在突出表现劳动者的苦难或是抨击社会的压抑，而是把这种苦难转化为继续努力的精神食粮，给人以希望。我认为，在现实生活中，我们也应该如此，因为活着不是为了苦恼生活的不如意，而是要努力活得更好。“在这个世界上，不是所有合理的和美好的都能按照自己的愿望存在或实现。”正因如此，才有了中华民族千百年来“自强不息，厚德载物”的美德。&emsp;&emsp;小说中在讲述劳动者生产生活的艰辛之余，还有不少美好的情感令人动容，给人温暖。这里既有邻里之情、同学之情、同事之情，还有美好又令人惋惜的爱情。作者之所以加入这些情感故事，为的是弘扬人性之光，带给劳动人民温暖，《平凡的世界》给无数劳动人民心灵上的慰藉。&emsp;&emsp;处在不同时代的人都有不同的命运，也许我们无法切身感受到那个年代劳动人民的艰辛，但从《平凡的世界》中，我发现了身边的幸福，平凡也是幸福的，但要想平凡就一定要有不平凡的理想与抱负，即使最平凡的人也要为他生活的那个世界而奋斗。有一句话说得好：“命是弱者的借口，运是强者的谦辞。”尽管我们不能完全左右自身的命运，但“生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，但可以慰藉的是，你总不枉在这世上活了一场。有了这样的认识，你就会珍重生活，而不会玩世不恭；同时，也会给人自身注入一种强大的内在力量。”]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>平凡的世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[薯片忍者的Wiki上线了！]]></title>
    <url>%2F2016%2F08%2Fmy-wiki-launched%2F</url>
    <content type="text"><![CDATA[2016年8月2日，我的个人知识网络系统——“薯片忍者的Wiki”正式上线，地址为http://wiki.potatochipsninja.tk/，希望大家光临。 此站采用开源的wiki引擎程序DokuWiki搭建，站内全部内容除另有声明外，均在署名-非商业性使用-相同方式共享 4.0 国际协议下发布。]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>公告</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大家好！这里是我的博客]]></title>
    <url>%2F2016%2F08%2Fhere-is-my-blog%2F</url>
    <content type="text"><![CDATA[我是薯片忍者，今天是2016年8月1日，我建立了我的个人博客。 我的博客地址：http://blog.potatochipsninja.tk（暂停使用） https://pcninja.cn 我的网站地址：http://www.potatochipsninja.tk（暂停使用）以上地址如有变动，我将第一时间在此公布。 您也可以关注我的新浪微博或Twitter获取其他信息。]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>公告</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南方之学，得其菁华——江苏之行有感]]></title>
    <url>%2F2016%2F06%2Ffeeling-after-the-trip-to-Jiangsu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2016年6月11日，我与同学们在星期六的黄昏踏上了难忘的京外社会实践活动之旅。此次实践活动中，我们的目的地是南方城市江苏省，等待我们的是为期一周的京外学习生活。&emsp;&emsp;当天晚九时许，我们登上了Z29次列车，正式开启了此次江苏之行。当晚，在火车上的自习让我感到了与在家中不一样的学习氛围与感受。次日早晨，我们抵达扬州，随即在雨中漫步瘦西湖。在瘦西湖，我有了对江南气候与文化的初步认识。我想正是这不期而遇的大雨，让这瘦西湖变得更有韵味，富有朦胧意境之美。午饭过后，我们集体参观了扬州双博馆，即扬州博物馆和扬州中国雕版印刷博物馆。馆内设有广陵潮—扬州城市故事厅、扬州八怪书画厅、馆藏明清书画厅、国宝厅、扬州古代雕刻厅、中国雕版印刷展厅、扬州雕版印刷展厅和一个临展厅计八个展厅。在这里，我们领略了扬州历史文化的悠久与中华雕版印刷的奇妙。当天下午，我们乘车抵达并入驻了最具中国文化情怀的学校——江苏省南菁高级中学，一进大门我就被校园的美丽所震撼。这里地处无锡市江阴市的市郊，文化气息浓厚，因此是学习的好地方。晚上我们在南菁高中用餐并进行了晚自习后结束了这忙碌而又充实的一天。&emsp;&emsp;13日早，我们伴着校园内响起的《命运》交响曲迎来了崭新的一天。早餐过后，我们随南菁高中的同学们一同参加了升旗仪式，感受到了南菁的校园文化。当天上午，我们在学政厅参加了随班听课与同课异构活动，这一次我切身感受到了身处中国高考最难省的江苏省的学生的学习压力，他们的课堂不仅带给我四节课的知识，更重要的是让我明白了自己的幸福，因此我们更应该努力学习。中午，在正学亭前组织了北京十二中与南菁高级中学学生联谊会，歌舞、相声让观众的掌声不断。午后，我们参观了校园。在这所距今已有133余年历史的校园中，造就了无数各领域的精英，他们的校训是“忠恕勤俭”，值得每个人学习。下午的辩论赛与篮球赛颇为精彩，输赢并不重要，重要的是两校的同学都辩出了风采、打出了激情。晚饭后，我们参观了坐落于校园内的沈鹏艺术馆。沈鹏先生作为著名的书法家，尽管一生取得无数辉煌成就，但不忘初心，致力于慈善、教育等事业，并坚持把沈鹏艺术馆建在自己的母校——南菁高中，这种精神让我动容，值得我们学习。&emsp;&emsp;接下来的三天中，我们先后参观了太湖边农庄、鼋头渚景区、惠山古镇、拙政园、枫桥夜泊、扬州博物馆、中山陵、侵华日军南京大屠杀遇难同胞纪念馆、夫子庙。在这些地方，我学会了知识、懂得了欣赏，让这次游学变得更有意义。&emsp;&emsp;16日晚，我们告别了南京，告别了江苏、告别了这美丽的地方。夜色中的江南是那么美丽，我舍不得离开，但不得不离开。随着T66次列车的开动，我们踏上了回家的旅途，回家是美好的，更何况我们是带着这么多美好的回忆满载而归。&emsp;&emsp;次日早10时许，火车停在了北京站，下车后，干燥但又熟悉的空气包围了我，我感到那么亲切。11时，我们抵达了我的学校北京十二中，在烈日下，我们做了简单的分别，这也标志这此次京外社会实践活动的结束，每个人都需要一段时间的休整，待收好行囊、整装待发之际，迎来新的征程与挑战。&emsp;&emsp;这次社会实践活动我收获了许多，扬州双博让我看到中华文化的博大精深，南菁高中带给我文化底蕴的冲击，枫桥夜泊让我置身诗画之中，南京大屠杀遇难同胞纪念馆让我铭记历史，为每个人敲响了爱国的警钟……仰望星空，脚踏实地，这些收获无不激励着我们前行。尽管旅途结束了，但希望与星火不灭，因为我们的征途是星辰大海，我们志存高远！&emsp;&emsp;愿北京市第十二中学与江苏省南菁高级中学的友谊长存！2016年6月18日]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>高中</tag>
        <tag>游记</tag>
        <tag>回忆</tag>
        <tag>江苏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《红楼梦》第四回有感]]></title>
    <url>%2F2016%2F04%2Fsense-of-reading-A-Dream-in-Red-Mansions-chapter-four%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;《红楼梦》第四回中，表面上只是写了几个人的故事，但在之中“早为下半部伏根”，它为后文写四大家族的兴衰做足了铺垫。四大家族缘何衰败，在第四回中就能找到答案。&emsp;&emsp;贾雨村做了官，上任后就有了一桩人命官司，开始贾雨村还准备秉公执法，捉拿杀人凶手，但见了“护官符”他就徇私枉法，胡乱判案，让薛蟠逍遥法外。这护官符中这样写道：“贾不假，白玉为堂金作马。阿房宫，三百里，住不下金陵一个史。东海缺少白玉床，龙王来请金陵王。丰年好大雪，珍珠如土金如铁。”，其中“雪”字就暗指“薛”，贾雨村一见此符就照做，说明四大家族是个“命运共同体”，他们相互勾结，狼狈为奸，因此“一荣俱荣，一损皆损”，贾雨村不想因此为自己招惹是非，便做出此事。从中不难看出贾雨村内心深不可测，在官场下，他虚情假意；而在官场上，他又小心谨慎，装腔作势，阴险狡诈。贾雨村面对普通百姓就态度强硬，面对有关系的人物便阿谀奉承；他恃强凌弱，见风使舵，为了自己的仕途与利益不顾正义，徇私枉法，是一个小人。贾雨村的这种行为迟早要受到法律的制裁，因此四大家族的衰败是必然的结果。&emsp;&emsp;从“护官符”一事就可见当时社会中高层贵族对底层群众的血汗与生命的剥削，揭露了封建政治的腐败和整个社会的黑暗与残酷，也为后面写因“事败”而“一损皆损”做铺垫，为四大家族的衰败“伏根”。&emsp;&emsp;第四回中还出现了一个角色——薛蟠。他因幼年受到溺爱，导致性情奢侈，言语傲慢，只顾游山玩水，不学无术，他蛮横暴力，一直放纵自己，过着安逸、富贵的生活，最终落得一无是处。这是缺乏教养的表现，更是长辈对他过度溺爱的结果，从中体现出四大家族对后代的管教不严，不成体统，贾宝玉就是个例子，因此我认为后代骄奢淫逸、不学无术也是四大家族最终落寞的一大原因。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>红楼梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔问题解法探究]]></title>
    <url>%2F2016%2F03%2Fexplore-the-solution-of-Hanoi%2F</url>
    <content type="text"><![CDATA[摘要：汉诺塔问题如何解决？有何规律与方法？通过发现、研究、总结规律，探索出解决n个盘子汉诺塔问题的方法。关键词：汉诺塔、递归第一部分、问题的提出&emsp;&emsp;汉诺（Hanoi）塔问题是源于法国数学家爱德华·卢卡斯编写的一个印度古老传说的益智玩具。其规则是：现有三根柱，即A柱、B柱与C柱，在A柱上从上往下按照从小到大的顺序摞着64片圆盘，要求在大盘不能在小盘之上、一次只能移动一个圆盘的前提下，把圆盘按大小顺序完全移动至C柱（如图1所示）。&emsp;&emsp;要想完成这个游戏，需要按怎样的步骤移动？至少需要多少步才能完成？怎样移动步数最少？一个个问题困扰着我，于是我对汉诺塔问题展开了探究。 第二部分、问题的探究&emsp;&emsp;要想解决原题目中64个圆盘的汉诺塔问题，不妨先从简单的汉诺塔问题入手，再从特殊到一般，总结出n个盘子的规律。&emsp;&emsp;经过一段时间的尝试，我发现1个盘子的汉诺塔问题只需一步即可解决，即A–&gt;C；2个盘子的汉诺塔问题最少需要三步来解决，即A–&gt;B，A–&gt;C，B–&gt;C；3个盘子的汉诺塔问题最少需要七步来解决，即A–&gt;C，A–&gt;B，C–&gt;B，A–&gt;C，B–&gt;A，B–&gt;C，A–&gt;C。这三种简单情况之需经过简单的尝试即可解决，但从4个盘子开始，问题变得越来越复杂，经过屡次尝试我才找到了最少步数的解决方法：A–&gt;C，A–&gt;B，C–&gt;B，A–&gt;C，B–&gt;A，B–&gt;C，A–&gt;C，共15步。&emsp;&emsp;通过上面的四次尝试，我对于盘子数（n）与最少步数（S）列出下表： n/个 1 2 3 4 … S/步 1 3 7 15 … &emsp;&emsp;根据表中数据，我做出大胆猜测：最少步数（S）与盘子数（n）成正相关，且S=2^n-1。&emsp;&emsp;为了验证以上猜想的正确性，我开始寻找n=2、3、4时移动步骤的共性。若从原始条件出发没有头绪，不妨试试从结果出发。因为目的是把所有盘子移动到C柱，而又必须遵循大在下小在上的原则，那么就必须先把最大的盘子移动到C柱，再把次大的盘子移动到C柱，再把第三大的盘子移动到C柱，循环往复，直到最小的盘子也“抵达”C柱。&emsp;&emsp;这个方法就好比大货车与小轿车发生车祸，轿车被压在货车下，一名行人被压在轿车之下。要想先救出被压在车底的人，就必须先把车一并抬起，移动到他处，再把人救出。&emsp;&emsp;经过思考，我发现，不论2个、3个还是4个盘子，都是先想办法把A柱上除最后一个盘子以外的所有盘子移动到B柱上（如图2所示），这样就得以把A柱上剩下的最大的盘子移动至C柱（如图3所示）；这时B柱上套着除最大盘外所有的盘子，B柱就好比一开始的A柱，A柱就变为空柱；把B柱上除最后一个盘子以外的所有盘子移动到A柱上（如图4所示），这样就得以把B柱上剩下的次大的盘子移动至C柱（如图5所示）……&emsp;&emsp;实践是检验真理的唯一标准，借助这个思路，我成功地解决了5个盘子的汉诺塔问题，步骤为：A–&gt;C，A–&gt;B，C–&gt;B，A–&gt;C，B–&gt;A，B–&gt;C，A–&gt;C，A–&gt;B，C–&gt;B，C–&gt;A，B–&gt;A，C–&gt;B，A–&gt;C，A–&gt;B，C–&gt;B，A–&gt;C，B–&gt;A，B–&gt;C，A–&gt;C，B–&gt;A，C–&gt;B，C–&gt;A，B–&gt;A，B–&gt;C，A–&gt;C，A–&gt;B，C–&gt;B，A–&gt;C，B–&gt;A，B–&gt;C，A–&gt;C，共计31步，这也成功地验证了我对于步数与盘子数之间关系：S=2^n-1的猜想。&emsp;&emsp;综上所述，我总结出了解决n个盘子的汉诺塔问题的移动步骤：(a1)把A柱上上面的n-1个盘子移动至B柱；(a2)把A柱上剩下的一个盘子移动至C柱；(a3)把B柱上的n-1个盘子移动至C柱。&emsp;&emsp;在这之中a2步是很好实现的，而a1步与a3步却不能直接实现。若想实现第a1步，就需要进行以下三个步骤：(b1)把A柱上上面的n-2个盘子移动至C柱；(b2)把A柱上上面的一个盘子移动至B柱；(b3)把C柱上的n-2个盘子移动至B柱。&emsp;&emsp;这三步本质上和a1、a2、a3三步是相同的，只不过要移动的盘子少了一个，而目的地也从C柱变成了B柱。若想实现第b1步，就还需要进行三个步骤……&emsp;&emsp;这种逆推的思想使得问题变为了一个个循环的过程，每一次过程都比原过程的盘子数少一个，循环往复，直到新过程中的盘子数变为1为止。这便是一个典型的递归方法。&emsp;&emsp;借助C语言允许在函数中直接调用此函数本身的特性，我用C语言实现了汉诺塔问题的递归调用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Hanoi.c#include &lt;stdio.h&gt;int step = 0;void hanoi (int d, char first, char second, char third);void out (char from, char to); //输出int main(void)&#123; int disk; //盘子数 char ch; printf("Please input the number of diskes:"); scanf("%d", &amp;disk); printf("\n\nThis is the step to move %d diskes:\n", disk); hanoi (disk, 'A', 'B', 'C'); printf("\nThis is all of %d steps.\n", step); while ((ch = getchar()) != '\n') //按任意键继续 continue; getchar(); return 0;&#125;void hanoi (int n, char first, char second, char third)&#123; if (n == 1) &#123; out (first, third); step++; &#125; else &#123; hanoi (n - 1, first, third, second); out (first, third); step++; hanoi (n - 1, second, first, third); &#125;&#125;void out (char from, char to)&#123; printf("%c ---&gt; %c\n", from, to);&#125; &emsp;&emsp;程序实现了对用户指定盘子数n的移动步骤与总步数的输出，在MinGW编译环境下编译，运行效果如图6（输入3）。&emsp;&emsp;至此，关于汉诺塔问题的探究便告一段落。 第三部分、结论与启示&emsp;&emsp;从最初的尝试，到大胆猜想，再到获得思路，最后成功把理论应用至实践，用计算机实现了对于n个盘子汉诺塔问题步骤的输出。整个探究过程帮助我透彻地理解了汉诺塔等递归问题的本质。其实递归问题不仅仅只有汉诺塔问题，例如“有5个人，问第5个人多少岁，他说比第4个人大两岁；问第4个人多少岁，他说比第3个人大两岁；问第3个人多少岁，他说比第2个人大两岁；问第2个人多少岁，他说比第1个人大两岁；最后问第1个人多少岁，他说是十岁。求第5个人多少岁。”这个问题就可以用递归方法来解决：第n个人的年龄用式子表达就是age(n)=age(n-1)+2(n&gt;1), 10(n=1) 。&emsp;&emsp;综合整篇文章，得出了S=2^n-1的结论以及n个盘子的解法，更重要的是成功应用了递归的思想，我从中体验到了一种数学的和谐之美，我们要发现生活中的数学之美，感受数学的魅力。 参考文献：[1]谭浩强编著，《C程序设计》，清华大学出版社，1991年，§7.6 函数的递归调用.]]></content>
      <categories>
        <category>学科</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>探究</tag>
        <tag>数学</tag>
        <tag>汉诺塔</tag>
        <tag>论文</tag>
        <tag>高中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从诗歌看民主斗士闻一多的爱国情怀]]></title>
    <url>%2F2015%2F10%2Ftalking-about-the-patriotism-of-WenYiduo-from-poetry%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;说到民主斗士，每个人都会不约而同地想起中国现代伟大的爱国主义者——闻一多。闻一多本名闻家骅，字有三，他既是一名坚定的民主斗士，也是新月派的代表诗人和学者。他一生为中华民族的革命事业做着贡献，最终在云南昆明被国民党特务暗杀。&emsp;&emsp;我第一次了解闻一多先生是通过课文《最后一次讲演》，它记述了闻一多在昆明最后一次为李公朴、为民主而战斗，当时这篇课文对我有了很深的触动，我非常欣赏闻一多在自身危难的情况下仍能临危不惧、伸张正义的英雄气概。如今，读了闻一多所作的《死水》与《澳门》，我对他有了全新的认识。&emsp;&emsp;伟大的爱国主义诗人闻一多于1928年出版了《死水》，揭示了中国当时社会的黑暗一面。&emsp;&emsp;这首诗全诗都在描绘一潭肮脏、恶臭的死水，“这是一沟绝望的死水，清风吹不起半点漪沦”，作者开篇就用了“绝望”二字，把革命的新鲜力量比作清风，可这对于这绝望的死水却熟视无睹。全文三次写道“这是一沟绝望的死水”并通过“破铜烂铁、残羹剩饭、绿酒、白沫”等反面、贬义的意象来表明中国当时政治、社会局面混乱、破败不堪并逐渐走向绝望。作者大胆地指出问题，批评、抨击了政坛对此视而不见、不管不顾，正面直截了当地指出政府官员玩忽职守、迂腐不作为的严峻问题，体现了闻一多在文学作品中体现的浓厚的政治色彩，以及它英勇无畏的爱国主义情怀，我从中看出了闻一多在最后一次讲演中体现出的无畏与坚毅。&emsp;&emsp;但是我想作者讽刺社会以丑为美的目的一定不是他真的绝望了，而是想以此来唤醒被禁锢的人民，隐晦曲折地表明他既愤慨又想让情况好转，这也体现了闻一多为国着想、坚定的爱国精神。&emsp;&emsp;《澳门》是闻一多留美期间创作的《七子之歌》其中的一篇，诗歌原文引言：邶有七子之母不安其室。七子自怨自艾，冀以回其母心。这交代了闻一多的写作目的是替离开祖国养育的这七块地孤独而无处诉苦的哀痛情感。诗歌中作者以澳门的视角歌颂、激励着全国人民，把中国比做母亲，把澳门比作中国的乳儿，更加亲切也更有感染力，从内心深处的灵魂呼唤着自己想要回归到母亲怀抱的强烈愿望，体现出了闻一多深深的爱国情怀。&emsp;&emsp;无论是对《死水》的痛恨，还是对《澳门》的呼唤，无不体现了民主斗士闻一多时刻为国着想、坚毅无所畏惧的伟大爱国精神。成为中国文学与政治交融的一道亮丽的风景线。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>爱国</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>闻一多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铭记历史，开创未来——游冉庄、白洋淀有感]]></title>
    <url>%2F2015%2F09%2Ffeeling-after-visiting-RanZhuang-and-Baiyang-Lake%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2015年9月，我们隆重纪念中国人民抗日战争暨世界反法西斯战争胜利70周年，为的是让每一位公民都担起维护世界和平的重担。&emsp;&emsp;为加强爱国主义教育，我们于9月20日驱车三小时赴河北省境内的冉庄和白洋淀进行为期两天的抗战教育社会实践活动。&emsp;&emsp;我们抵达冉庄后首先参观了于1959年建馆开放的冉庄地道战纪念馆，在这里保存了许多抗日时期珍贵的革命文物、影像资料与文献，纪念馆通过科技手段复原了地道战的情景，使游客可以更加直观、清晰地了解地道战。参观过后，我们便亲身实践钻了一回地道，这里的地道一般宽0.7至0.8米，高约1至1.5米，上距地面2米多，并且地道四通八达以供当时的村民避难，不过目前只开放了部分地道。在地道中的空间十分狭小，只能通过一个人，就像陶渊明笔下的桃花源口“初极狭，才通人”，并且这里的高度也仅仅不到两米，通过时必须弯着腰，在中部的空气也比较稀薄，所以虽然只走了一小段，同学们就累得腰酸背痛、满头大汗，由此也能看出当时的抗日游击队在地道中穿梭是多么辛苦。&emsp;&emsp;用过午餐后，我们驱车前往白洋淀，历经近三个小时的车程，我们抵达并安排了食宿。在晚上的篝火晚会上，同学们尽情施展自己的才艺，用歌声表达着对革命先烈的深深敬意。&emsp;&emsp;次日上午，我们随队乘船至华北明珠白洋淀的文化苑内，游览了建于革命老区的抗日胜地嘎子村。&emsp;&emsp;嘎子村，顾名思义就是小兵张嘎所居住的一座水村，这里三面环水，村边景色宜人，芦苇青翠，水清鸟鸣，荷花飘香，水光天色。但是这里不仅风景秀美，还承载着一段不可磨灭的抗日记忆。&emsp;&emsp;我们在这里集体观看了小兵张嘎的系列情景剧，这部情景剧以诙谐幽默的喜剧形式展现了张嘎当时面对日寇毫不畏惧、足智多谋的英雄本色。&emsp;&emsp;欣赏了白洋淀的壮美风景过后，我们在嘎子饭铺用了此次“红色之旅”的最后一餐，随后便返回了学校。&emsp;&emsp;在纪念中国人民抗日战争胜利70周年之际，此次冉庄、白洋淀之旅使我们感受到了强烈的民族自豪感，也为我们努力学习、捍卫祖国和平提供了强大动力，这真是一次值得回味的游览。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>抗战</tag>
        <tag>爱国</tag>
        <tag>红色</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东临戴河有遗篇——从《浪淘沙•北戴河》看毛泽东的壮美英雄气概]]></title>
    <url>%2F2015%2F09%2Freview-MaoZedong-s-heroic-spirit%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;毛泽东作为著名的政治家、思想家和革命家，他不但在新中国的建立中体现了他豪迈的英雄气概，在文学创作方面毛泽东同样有所作为，如《沁园春·长沙》、《长征》、《忆秦娥·娄山关》，无不体现了毛泽东诗词大气磅礴的写作风格。&emsp;&emsp;在其众多作品中，毛泽东与1954年在秦皇岛所作的《浪淘沙·北戴河》一词给我的印象最为深刻。毛泽东诗词大多采用借景抒情的方式来衬托自己当时的情感，而《浪淘沙·北戴河》的出众之处就在于他不但把北戴河初秋时萧瑟的景色描写得惟妙惟肖，还巧妙地展现了毛泽东无尽的感慨和博大的胸怀。&emsp;&emsp;上阕第一句“大雨落幽燕，白浪滔天，秦皇岛外打鱼船”主要描写了北戴河上的波涛景象，此时是天气恶劣时的北戴河，“幽燕”、“滔天”体现了雨大浪高，写出了水的大气磅礴之势，与儒家的“柔弱之水”有巨大差异。儒家的水是柔弱的，而毛泽东的水是凶猛的，从这里也能看出毛泽东诗词中体现出其人的狂放之气。“一片汪洋都不见，知向谁边？”描写了波涛汹涌的大海上，一片汪洋的海面上除了隐约能见到的渔船别无他物，这完全不同于江南水乡小桥流水、小舟在平静的水面上穿梭的悠哉，而是险要、骇人的巨浪，体现了毛泽东当时雄壮的气魄与阔达的胸襟。&emsp;&emsp;而到了下阙又立刻穿越了时间和空间，越过千年忆往事，回到了曹操的《观沧海》，在这一首气势恢宏的作品中，曹操同是在萧瑟中抒发自己内心的雄心壮志与宏大抱负，仿佛星河中的无数繁星都由自己眼前的大水所吞吐。而此时站在北戴河前的毛泽东有着与曹操相同的胸怀与眼光，只不过“若出其中”的这其中由沧海换成了北戴河罢了。&emsp;&emsp;然而“萧瑟秋风今又是，换了人间”表明一切又都重新开始了，抒发了毛泽东对现世的感慨，本词也以此结尾，意味着深邃的历史已经过去，美好的新人间已经到来，毛泽东用壮美的景色写出了他壮美的英雄气概。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>毛泽东</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观“纪念中国人民抗日战争暨世界反法西斯战争胜利70周年活动”阅兵式有感]]></title>
    <url>%2F2015%2F09%2Fafter-watching-the-70th-anniversary-parade%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;1945年，中国结束了近十年的抗日战争，也宣告了世界反法西斯战争的最终胜利，中国以几千万人民牺牲的代价换取了世界的和平。&emsp;&emsp;2015年，时隔70年，我们隆重举行抗战胜利纪念活动，这不仅仅是纪念，更是对现世人民的警示。9月3日，是我国设立的抗日战争胜利纪念日，在这一天进行阅兵式，有着历史纪念意义，标志着维持了70年世界的宁静。&emsp;&emsp;2015年9月3日上午九时许，习主席在端门前隆重接见参与世界反法西斯战争的各国领导人或代表，并登上天安门。“将士们，听党指挥，能打胜仗，作风优良，不惧强敌，敢较量，为祖国决胜疆场”的歌声响彻整条长安街。上午十时，阅兵正式开始，鸣礼炮70响，不但象征了70年前的胜利，还表达了对抗日先烈的深深缅怀。与此同时，国旗护卫队穿过抗日英雄纪念碑，走到旗杆下，军乐团奏响了《义勇军进行曲》，五星红旗冉冉升起，飘扬在空中，那鲜艳的红色，是用烈士的鲜血染成的！&emsp;&emsp;习主席乘坐的轿车缓缓驶过每一个受阅方阵，看着将士们嘶声力竭地喊着“为人民服务！”，我深深感受到对祖国的自豪之情。分列式开始了，护旗方阵悬挂着中华人民共和国国旗和中国人民解放军军旗沿长安街飞过天安门城楼。伴随着《分列式进行曲》，一个个英模方队正步走过天安门，他们整齐划一的步伐、响彻天空的口号，无不体现了我国军人的良好素质与优秀作风。当抗日老兵们坐着车经过天安门，手敬军礼，眼含热泪地注视着主席时，我也不禁落下了眼泪。他们是抗日英雄，他们铸就了新中国，如果没有他们，与法西斯的斗争不可能在1945年结束。&emsp;&emsp;后勤保障方阵和白求恩医疗方阵也走过了天安门，他们无时不刻关爱着每一名军人，保障了军人的生活物资、武器装备与生命安全。他们是一支合格军队必备的后方支柱。&emsp;&emsp;紧随其后的是地面装备方阵，巨大彪悍的坦克、装甲车、突击车和反恐武警车辆整齐地驶过了观众席，这体现了我国强大的陆军实力与打击恐怖分子的能力。导弹方阵向世界人民展示了我国研发的导弹实力，近程、中程、远程导弹应有尽有，证明我军对全球的精确打击能力，震慑着想要破坏世界和平蠢蠢欲动的敌人。“核常兼备”导弹车，不但可以发射常规导弹，还有能力发射核导弹，这在极端情况下非常实用，也展示了我国军队武器研发团队的科技实力。&emsp;&emsp;最后亮相的是战斗机和直升机方阵，他们在空中还能飞的如此整齐让人惊叹，我感受到了我国空军部队的强大。空军飞行员驾驶者战机掠过五湖四海，捍卫着中华大地，带领中国军队飞向新的高度！&emsp;&emsp;铭记历史，缅怀先烈，珍爱和平，开创未来。让我们牢牢记住并践行这十六个字，让祖国强大，让世界和平！&emsp;&emsp;和平必胜！正义必胜！]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>和平</tag>
        <tag>抗战</tag>
        <tag>爱国</tag>
        <tag>红色</tag>
        <tag>观后感</tag>
      </tags>
  </entry>
</search>
