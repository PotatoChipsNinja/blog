<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[为什么 memset() 只能将 int 数组初始化为 0 或 -1]]></title>
    <url>%2F2020%2F04%2Fwhy-memset-can-only-initialize-int-array-to-0-or-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;C/C++ 标准库提供了很多常用的工具函数，比如在 &lt;string.h&gt; 中的 memset() 函数就常常被用来初始化数组，但它在初始化 int 等类型数组的时候只能初始化为 0 或 -1，如果识图用 memset() 将数组初始化为 1，就会发现每个元素都变成了 16843009。&emsp;&emsp;造成这种情况的原因很简单，因为 memset() 的作用是将内存块填充为指定的字符，这也是为什么它包含在 string.h 里的原因。因此，memset() 对内存进行赋值是以字节为单位的。&emsp;&emsp;比如我们调用 memset() 将 int 数组初始化为 1，那么数组的每个字节（不是元素）都会被设置为 00000001，而 int 占 4 个字节，故每个元素的值就是 00000001 00000001 00000001 00000001，该二进制值就是十进制的 16843009，所以 memset() 函数不能把整型数组初始化为 1。&emsp;&emsp;对于长度大于 1 个字节的变量，只能通过 memset() 设置为各字节相同的值，比如 0（全零）或 -1（全1），不能赋各字节不同的值。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 48. 旋转图像]]></title>
    <url>%2F2020%2F04%2Frotate-image%2F</url>
    <content type="text"><![CDATA[给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。 说明:你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。示例 1:12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 题解:每转一个元素，就要把目的地当前的元素也转到目标位置，以此类推，一共要转4个元素。例如，要想转动 m[i][j]，那么对应的四个元素要按照 m[i][j] -&gt; m[j][N-i-1] -&gt; m[N-i-1][N-j-1] -&gt; m[N-j-1][i] 的方式转动。所以，我们只需要转矩阵的左上角的元素，让其他地方的元素跟着转。 代码:123456789101112131415void rotate(int** matrix, int matrixSize, int* matrixColSize)&#123; int i, j, k; for(i = 0; i &lt; matrixSize/2; ++i) for(j = 0; j &lt; (matrixSize+1)/2; ++j) &#123; // 旋转对应位置上的4个数： // m[i][j] -&gt; m[j][N-i-1] -&gt; m[N-i-1][N-j-1] -&gt; m[N-j-1][i] k = matrix[matrixSize-j-1][i]; matrix[matrixSize-j-1][i] = matrix[matrixSize-i-1][matrixSize-j-1]; matrix[matrixSize-i-1][matrixSize-j-1] = matrix[j][matrixSize-i-1]; matrix[j][matrixSize-i-1] = matrix[i][j]; matrix[i][j] = k; &#125;&#125; 时间复杂度 O(n2)，空间复杂度 O(1)。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>原地算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 42. 接雨水]]></title>
    <url>%2F2020%2F04%2Ftrapping-rain-water%2F</url>
    <content type="text"><![CDATA[给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 题解:&emsp;&emsp;每个位置上能存多少水取决于它左右两侧的最高峰较低的那一峰的高度，比如图中第六个位置上，它左侧最高为2格，右侧最高为3格，所以这一列的水位能到2格的高度。&emsp;&emsp;所以我们的算法就是：首先从左往右扫一趟数组，算出每个位置上左侧的最高峰；再从右往左扫一趟数组，算出每个位置上右侧的最高峰。最后遍历一遍求出每个位置上的积水量。 代码:123456789101112131415161718192021222324#define min(x,y) ((x)&lt;(y)?(x):(y))#define max(x,y) ((x)&gt;(y)?(x):(y))int trap(int *height, int heightSize)&#123; if(!heightSize) return 0; int ans = 0, temp, i; int leftTop[heightSize], rightTop[heightSize]; /* 计算leftTop和rightTop */ for(i = 1, leftTop[0] = 0; i &lt; heightSize; ++i) leftTop[i] = max(leftTop[i-1], height[i-1]); for(i = heightSize-2, rightTop[heightSize-1] = 0; i &gt;= 0; --i) rightTop[i] = max(rightTop[i+1], height[i+1]); for(i = 0; i &lt; heightSize; ++i) &#123; temp = min(leftTop[i], rightTop[i]) - height[i]; if(temp &gt; 0) ans += temp; &#125; return ans;&#125; &emsp;&emsp;这种解法遍历了三趟数组，所以时间复杂度为 O(n)。用到了 leftTop 和 rightTop 两个数组，所以空间复杂度也是 O(n)。 &emsp;&emsp;官方题解提供了一种更优秀的解法，可以只遍历一次数组，且空间复杂度为 O(1)：&emsp;&emsp;双指针法，一个指针从左往右移动，另一个从右往左移动。维护两个变量 left_max 和 right_max ，分别存储左右两边目前为止遇到的最高峰。&emsp;&emsp;一开始，两个指针分别指向最左侧和最右侧的元素。如果左侧指针的高度比右侧矮，左侧指针就右移一格，否则就右侧指针左移。换句话说，就是始终保持对侧是不矮于本侧的。这样一来，水能存多高就只取决于本侧的最大高度了。代码如下：1234567891011121314151617int trap(vector&lt;int&gt;&amp; height)&#123; int left = 0, right = height.size() - 1; int ans = 0; int left_max = 0, right_max = 0; while (left &lt; right) &#123; if (height[left] &lt; height[right]) &#123; height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]); ++left; &#125; else &#123; height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]); --right; &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1162. 地图分析]]></title>
    <url>%2F2020%2F03%2Fas-far-from-land-as-possible%2F</url>
    <content type="text"><![CDATA[你现在手里有一份大小为 N x N 的地图（网格）grid，上面的每个区域（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。我们这里说的距离是「曼哈顿距离」：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。如果我们的地图上只有陆地或者海洋，请返回 -1。示例 1:123456输入：[[1,0,1], [0,0,0], [1,0,1]]输出：2解释：海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 示例 2:123456输入：[[1,0,0], [0,0,0], [0,0,0]]输出：4解释：海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。 题解:多源BFS。先把所有 1（陆地）入队，每次循环把队首上下左右四个方向的海洋入队。为了防止重复搜索，把搜到的海洋标记为 1。最后一个出队的一定是离陆地最远的。 代码:123456789101112131415161718192021222324252627282930313233343536373839int maxDistance(int **grid, int gridSize, int *gridColSize)&#123; int queue[10000][3]; int front = 0, rear = 0; int i, j, x, y; int direction[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for(i = 0; i &lt; gridSize; ++i) for(j = 0; j &lt; gridSize; ++j) if(grid[i][j]) &#123; queue[rear][0] = i; queue[rear][1] = j; queue[rear][2] = 0; rear++; &#125; if(!rear || rear == gridSize*gridSize) return -1; while(rear &gt; front) &#123; for(i = 0; i &lt; 4; ++i) &#123; x = queue[front][0] + direction[i][0]; y = queue[front][1] + direction[i][1]; if(x &gt;= 0 &amp;&amp; x &lt; gridSize &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; gridSize &amp;&amp; !grid[x][y]) &#123; grid[x][y] = 1; queue[rear][0] = x; queue[rear][1] = y; queue[rear][2] = queue[front][2]+1; rear++; &#125; &#125; front++; &#125; return queue[front-1][2];&#125; 这种解法的时间复杂度和空间复杂度显然都是 O(n2)。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 365. 水壶问题]]></title>
    <url>%2F2020%2F03%2Fwater-and-jug-problem%2F</url>
    <content type="text"><![CDATA[有两个容量分别为 x 升 和 y 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z 升的水？如果可以，最后必须用以上水壶中的一或两个来盛放取得的 z 升水。允许做以下操作： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1:（出自电影《虎胆龙威》）12输入: x = 3, y = 5, z = 4输出: True 操作方法：先把A壶加满，倒入B壶，再把A壶加满，倒入B壶，此时A、B各有1升和5升水。倒光B壶，把A壶中的1升水倒入B壶，加满A壶，倒入B壶，此时B壶即有4升水。 示例 2:12输入: x = 2, y = 6, z = 5输出: False 题解:&emsp;&emsp;如果从纯算法角度来考虑该问题，那么 DFS 或者 BFS 都可以。以 (A壶水量, B壶水量) 作为状态去搜索。每个状态需要搜下面这 6 种情况： 装满A壶 装满B壶 清空A壶 清空B壶 从A壶向B壶倒水，直到装满或者倒空 从B壶向A壶倒水，直到装满或者倒空 &emsp;&emsp;为了防止无限递归，需要建立一个 HashSet 来存储已经搜索过的状态，保证每个状态最多只被搜到一次。由于搜索深度很深，递归实现容易爆栈，所以可以用栈（队列）实现 DFS（BFS）。&emsp;&emsp;无论 DFS 还是 BFS，因为最多有 $(x+1)(y+1)$ 种状态，所以时间复杂度和空间复杂度都是 $O(xy)$。反正我写的 DFS 在 LeetCode 上 TLE 了😩 &emsp;&emsp;然而此题有个绝妙的数学解法，可秒杀 DFS/BFS：&emsp;&emsp;我们首先需要明确，在初始状态下，两个水壶中水的总量是 0，之后，不管我们做六种操作的哪一种，都只会使水的总量 增加x 或 增加y 或 减少x 或 减少y。注意，两个水壶不会同时半满，所以如果我们把半满的水壶倒空或接满，虽然水的总量的变化量不是 x 或 y，但是这么操作之后就又回到了 一个空一个满 或 两个空 或 两个满 的状态，所以把半满的水壶倒空或接满这类操作是无意义的。&emsp;&emsp;所以，水的总量的变化量一定是 x 或 y，由此我们可以得知水的总量永远等于 $ax+by$，其中$a,b\in Z$。这样一来，获取 z 升水的充要条件就是 $z\leq x+y$ 并且方程 $ax+by=z$ 有整数解。&emsp;&emsp;由贝祖定理（或称裴蜀定理）可知，$ax+by=z$ 有解当且仅当 $z$ 是 $x, y$ 的最大公约数的倍数。所以此题数学解法的代码如下： 代码:1234567891011121314int gcd(int a, int b) // 求最大公约数&#123; return b ? gcd(b, a%b) : a;&#125;bool canMeasureWater(int x, int y, int z)&#123; if(z &gt; x + y) return false; else if(x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0) return true; else return z % gcd(x, y) == 0;&#125; &emsp;&emsp;这种解法的时间复杂度等于辗转相除法求最大公约数的时间复杂度，即 $O(\log(\min \lbrace x, y\rbrace ))$，空间复杂度为 $O(1)$。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>贝祖定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 695. 岛屿的最大面积]]></title>
    <url>%2F2020%2F03%2Fmax-area-of-island%2F</url>
    <content type="text"><![CDATA[给定一个包含了一些 0 和 1 的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0)示例 1:12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是 11，因为岛屿只能包含水平或垂直的四个方向的 1。 示例 2:1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵 grid 的长度和宽度都不超过 50。 题解:遍历二维数组，遇到 1 的时候就 DFS 深搜找出这个岛屿的面积，同时把经过的 1 都置为 0，避免重复搜索。 代码:123456789101112131415161718192021222324252627282930int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int dfs(int** grid, int m, int n, int i, int j)&#123; int ans = 1; grid[i][j] = 0; if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j]) ans += dfs(grid, m, n, i-1, j); if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1]) ans += dfs(grid, m, n, i, j-1); if(i+1 &lt; m &amp;&amp; grid[i+1][j]) ans += dfs(grid, m, n, i+1, j); if(j+1 &lt; n &amp;&amp; grid[i][j+1]) ans += dfs(grid, m, n, i, j+1); return ans;&#125;// 注意下面 gridSize 是行数，*gridColSize 是列数（不知道 LeetCode 为什么这么给参数）int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize)&#123; int maxArea = 0; for(int i = 0; i &lt; gridSize; ++i) for(int j = 0; j &lt; *gridColSize; ++j) if(grid[i][j]) maxArea = max(maxArea, dfs(grid, gridSize, *gridColSize, i, j)); return maxArea;&#125; P.S.今天才发现 LeetCode 的「每日 1 题」打卡刷题活动，其实从三月一号就开始了。今天第一天做就碰上这道水题，神人品😁。提交上去之后得到的结果是这样的： 真是惊了，是因为用 C 写的人比较少吗😮]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy 学习笔记]]></title>
    <url>%2F2020%2F02%2FNumPy-learning-notes%2F</url>
    <content type="text"><![CDATA[本文为 Jupyter Notebook 笔记转 Markdown，原 .ipynb 文件可点击此处下载 关于 Python 和 NumPy 的使用可以参考斯坦福大学CS231n的教程：https://cs231n.github.io/python-numpy-tutorial/。 Numpy 是 Python 中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。 要想使用 NumPy，我们首先需要引入numpy包： 1import numpy as np 数组NumPy 数组是所有相同类型的值的网格，并由非负整数元组索引。维数是数组的秩；数组的形状是一个整数元组，给出沿每个维度的数组大小。 我们可以通过嵌套的 Python 列表初始化 NumPy 数组，并使用方括号访问元素： 123456a = np.array([1, 2, 3]) # 创建一个秩为1的数组print(type(a))print(a.shape)print(a[0], a[1], a[2])a[0] = 5 # 改变数组中的一个元素print(a) &lt;class &#39;numpy.ndarray&#39;&gt; (3,) 1 2 3 [5 2 3] 1234b = np.array([[1,2,3], [4,5,6]]) # 创建一个秩为2的数组print(b)print(b.shape)print(b[0, 0], b[0, 1], b[1, 0]) [[1 2 3] [4 5 6]] (2, 3) 1 2 4 NumPy 也提供许多创建数组的函数： 12a = np.zeros((2, 2)) # 创建一个全零数组print(a) [[0. 0.] [0. 0.]] 12b = np.ones((1, 2)) # 创建一个全1数组print(b) [[1. 1.]] 12c = np.full((2, 2), 7) # 创建一个常量数组print(c) [[7 7] [7 7]] 12d = np.eye(2) # 创建一个2x2的单位矩阵print(d) [[1. 0.] [0. 1.]] 12e = np.random.random((2, 2)) # 创建一个填充随机数的数组print(e) [[0.23316062 0.89221292] [0.15442143 0.18416244]] 更多创建数组的方法请见官方文档。 数组索引NumPy 提供了几种索引数组的方式。 切片：类似于 Python 的列表，NumPy 数组可以被切片。由于数组可能是多维的，因此必须为数组的每个维度指定一个切片： 123456789# 创建这样一个秩为2、形状为(3, 4)的数组# [[ 1 2 3 4]# [ 5 6 7 8]# [ 9 10 11 12]]a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])# 使用切片来提取由前2行，列号为1、2组成的子数组b = a[:2, 1:3]print(b) [[2 3] [6 7]] 数组的一个切片是对于同一数据的一个视图，因此修改它将修改原数组： 123print(a[0, 1])b[0, 0] = 77 # b[0, 0]与a[0, 1]是同一条数据print(a[0, 1]) 2 77 你也可以将整数索引与切片索引混合使用。但是，这样做将产生比原始数组的秩低的数组： 123# 创建这样一个秩为2、形状为(3, 4)的数组a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])print(a) [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] 两种访问数组中间行数据的方式。将整数索引与切片混合使用会产生一个较低秩的数组，而仅使用切片会产生一个与原始数组等秩的数组： 123456row_r1 = a[1, :] # a的第二行的秩为1的视图row_r2 = a[1:2, :] # a的第二行的秩为2的视图row_r3 = a[[1], :] # a的第二行的秩为2的视图print(row_r1, row_r1.shape)print(row_r2, row_r2.shape)print(row_r3, row_r3.shape) [5 6 7 8] (4,) [[5 6 7 8]] (1, 4) [[5 6 7 8]] (1, 4) 在访问数组的列时，我们可以进行相同的区分： 1234col_r1 = a[:, 1]col_r2 = a[:, 1:2]print(col_r1, col_r1.shape)print(col_r2, col_r2.shape) [ 2 6 10] (3,) [[ 2] [ 6] [10]] (3, 1) 整数数组索引：当使用切片对 NumPy 数组进行索引时，生成的数组视图将始终是原始数组的子数组。相反，整数数组索引允许你使用另一个数组中的数据构造任意数组： 12345678a = np.array([[1,2], [3, 4], [5, 6]])# 整数数组索引的一个例子# 返回的数组将是(3,)形状的print(a[[0, 1, 2], [0, 1, 0]])# 上面的整数数组索引的例子与这个等价：print(np.array([a[0, 0], a[1, 1], a[2, 0]])) [1 4 5] [1 4 5] 使用整数数组索引时，可以重复使用源数组中的相同元素： 1234print(a[[0, 0], [1, 1]])# 等价于：print(np.array([a[0, 1], a[0, 1]])) [2 2] [2 2] 整数数组索引的一个有用技巧是从矩阵的每一行中选择或更改一个元素： 12345678910111213# 创建一个新数组，从中选择元素a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])print(a)# 创建索引数组b = np.array([0, 2, 0, 1])# 使用b中的索引从a的每行中选择一个元素print(a[np.arange(4), b])# 使用b中的索引对a的每行中的一个元素进行改变a[np.arange(4), b] += 10print(a) [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] [ 1 6 7 11] [[11 2 3] [ 4 5 16] [17 8 9] [10 21 12]] 布尔数组索引：布尔数组索引使您可以挑选出数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素： 1234567a = np.array([[1,2], [3, 4], [5, 6]])bool_idx = (a &gt; 2) # 找出大于2的元素； # 这将返回一个与a形状相同的numpy布尔数组， # 其中bool_idx的每个位置代表a中对应元素是否大于2。print(bool_idx) [[False False] [ True True] [ True True]] 123456# 我们使用布尔数组索引来构建一个秩为1的数组，# 该数组由bool_idx中值为True的对应元素组成print(a[bool_idx])# 我们可以用一个简洁的语句完成上述操作：print(a[a &gt; 2]) [3 4 5 6] [3 4 5 6] 更多关于 NumPy 数组索引的信息请见官方文档。 数据类型每个 NumPy 数组都是相同类型的元素的网格。NumPy 提供了大量可用于构造数组的数据类型。在创建数组时，NumPy 会尝试猜测一个数据类型，但是构造数组的函数通常还包含一个可选参数来明确指定数据类型： 12345678x = np.array([1, 2]) # 让NumPy选择数据类型print(x.dtype)x = np.array([1.0, 2.0]) # 让NumPy选择数据类型print(x.dtype)x = np.array([1, 2], dtype=np.int64) # 强制数据类型print(x.dtype) int32 float64 int64 更多关于 NumPy 数据类型的信息请见官方文档。 数组运算基本数学函数在数组上逐元素进行操作，并且可用作运算符重载和 NumPy 模块中的函数： 123456x = np.array([[1,2],[3,4]], dtype=np.float64)y = np.array([[5,6],[7,8]], dtype=np.float64)# 逐元素求和；都产生数组print(x + y)print(np.add(x, y)) [[ 6. 8.] [10. 12.]] [[ 6. 8.] [10. 12.]] 123# 逐元素求差；都产生数组print(x - y)print(np.subtract(x, y)) [[-4. -4.] [-4. -4.]] [[-4. -4.] [-4. -4.]] 123# 逐元素相乘；都产生数组print(x * y)print(np.multiply(x, y)) [[ 5. 12.] [21. 32.]] [[ 5. 12.] [21. 32.]] 123# 逐元素相除；都产生数组print(x / y)print(np.divide(x, y)) [[0.2 0.33333333] [0.42857143 0.5 ]] [[0.2 0.33333333] [0.42857143 0.5 ]] 12# 逐元素求平方根；产生数组print(np.sqrt(x)) [[1. 1.41421356] [1.73205081 2. ]] 注意，*是逐元素相乘，不是矩阵乘法。取而代之，用dot函数计算向量的内积、向量与矩阵的乘积以及矩阵与矩阵的乘积。 123456789x = np.array([[1,2],[3,4]])y = np.array([[5,6],[7,8]])v = np.array([9,10])w = np.array([11, 12])# 向量的内积；都是219print(v.dot(w))print(np.dot(v, w)) 219 219 123# 矩阵/向量乘积；都产生秩为1的数组[29 67]print(x.dot(v))print(np.dot(x, v)) [29 67] [29 67] 12345# 矩阵/矩阵乘积；都产生秩为2的数组# [[19 22]# [43 50]]print(x.dot(y))print(np.dot(x, y)) [[19 22] [43 50]] [[19 22] [43 50]] NumPy 提供了许多有用的函数来对数组执行计算。最有用的之一是sum： 12345x = np.array([[1,2],[3,4]])print(np.sum(x)) # 计算所有元素之和print(np.sum(x, axis=0)) # 计算每一列之和print(np.sum(x, axis=1)) # 计算每一行之和 10 [4 6] [3 7] NumPy 提供的数学函数的完整列表请见官方文档。 除了用数组计算数学函数外，我们经常需要整形或以其他方式处理数组中的数据。此类操作的最简单的例子是转置矩阵；要转置矩阵，只需使用数组对象的T属性： 12print(x)print(x.T) [[1 2] [3 4]] [[1 3] [2 4]] 1234# 注意，对秩为1的数组求转置不会有任何变化：v = np.array([1,2,3])print(v)print(v.T) [1 2 3] [1 2 3] NumPy 提供了许多操作数组的函数，完整列表请见官方文档。 广播广播是一种强大的机制，允许 NumPy 在执行算术运算时处理不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，并且我们想多次使用较小的数组对较大的数组执行某些操作。 例如，假设我们要向矩阵的每一行添加一个常向量。我们可以这样做： 1234567891011# 我们将向量v加到矩阵x的每一行，# 并将结果存储在矩阵y中x = np.array([[1,2,3], [4,5,6], [7,8,9], [10,11,12]])v = np.array([1, 0, 1])y = np.empty_like(x) # 创建一个与x形状相同的空矩阵# 通过显式循环将向量v加到矩阵x的每一行for i in range(4): y[i, :] = x[i, :] + vprint(y) [[ 2 2 4] [ 5 5 7] [ 8 8 10] [11 11 13]] 这是可行的；但是当矩阵x非常大时，在 Python 中计算显式循环可能会很慢。注意，将向量v加到矩阵x的每一行相当于：垂直堆叠v的多个副本形成矩阵vv，然后执行x和vv的逐元素求和。我们可以这样实现这种方法： 12vv = np.tile(v, (4, 1)) # 将v的4个副本堆叠在一起print(vv) [[1 0 1] [1 0 1] [1 0 1] [1 0 1]] 12y = x + vv # x和vv逐元素相加print(y) [[ 2 2 4] [ 5 5 7] [ 8 8 10] [11 11 13]] NumPy 广播使我们无需实际创建多个v的副本即可执行此计算。考虑使用广播的这个版本： 123456# 我们将向量v加到矩阵x的每一行，# 并将结果存储在矩阵y中x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = x + v # 通过广播将v加到x的每一行print(y) [[ 2 2 4] [ 5 5 7] [ 8 8 10] [11 11 13]] 即使x的形状是(4, 3)而v的形状是(3,)，但由于广播，y = x + v这一行仍然可以工作；这一行的工作方式就好像v实际具有(4, 3)的形状，其中每一行都是v的一个副本，并且求和是逐元素进行的。 将两个阵列广播到一起遵循以下规则： 如果几个数组的秩不同，则在低秩数组的形状前面加1补齐，直到二者的形状具有相同的长度； 如果两个数组在某个维度上的大小相同，或者其中一个数组在该维度上的大小为1，则称这两个数组该维度上兼容； 如果几个数组在所有维度上都兼容，则它们可以广播到一起； 广播后的数组形状等于输入数组的形状在各个维度上的最大值； 在任一维度中，如果一个数组的大小为1而另一个数组的大小大于1，则第一个数组的行为就像是沿着该维度复制的一样。 如果上述解释难以理解，可以尝试阅读官方文档中的解释或这篇解释。 支持广播的函数称为通用函数。所有通用功能的列表请见官方文档。 以下是广播的一些应用： 1234567# 计算向量的张量积：v = np.array([1,2,3]) # v具有形状(3,)w = np.array([4,5]) # w具有形状(2,)# 为了计算外积，我们首先将v整形为形状为(3, 1)的列向量；# 然后我们可以把它广播到w上，以产生形状(3, 2)的输出，# 即v和w的外积：print(np.reshape(v, (3, 1)) * w) [[ 4 5] [ 8 10] [12 15]] 1234# 将向量加到矩阵的每一行：x = np.array([[1,2,3], [4,5,6]])# x具有形状(2, 3)而v具有形状(3,)，因此它们广播到(2, 3)print(x + v) [[2 4 6] [5 7 9]] 1234567891011# 将向量加到矩阵的每一列：# x具有形状(2, 3)而w具有形状(2,)。# 如果我们对x求转置，则它具有形状(3, 2)，# 并且可以对w进行广播以产生形状(3, 2)的结果；# 转置此结果将得出形状(2, 3)的最终结果，# 即将向量w加到矩阵x的每一列的矩阵。print((x.T + w).T)# 另一种解决方案是将w整形为(2, 1)的列向量；# 然后我们可以直接对x广播它以产生相同的输出。print(x + np.reshape(w, (2, 1))) [[ 5 6 7] [ 9 10 11]] [[ 5 6 7] [ 9 10 11]] 1234# 矩阵乘以常数：# x具有形状(2, 3)。NumPy将标量视为形状为()的数组；# 它们可以广播到一起，生成形状为(2, 3)的数组。print(x * 2) [[ 2 4 6] [ 8 10 12]] 广播通常会使您的代码更简洁，更快捷，因此，您应尽可能使用它。 NumPy 文档上文中简短的描述涉及到了您需要了解的有关 NumPy 的许多重要知识，但还远远不够。查看NumPy参考以了解更多关于 NumPy 的信息。 MatplotlibMatplotlib 是一个绘图库。在本节中将简要介绍matplotlib.pyplot模块，该模块提供了类似于 MATLAB 的绘图系统。 1import matplotlib.pyplot as plt 通过运行这个特殊的 iPython 命令，我们将内联显示绘图： 1%matplotlib inline 绘图Matplotlib 中最重要的函数是plot，它允许您绘制2D数据。这是一个简单的示例： 1234567# 计算正弦曲线上的点的x和y坐标x = np.arange(0, 3 * np.pi, 0.1)y = np.sin(x)# 使用Matplotlib绘制这些点plt.plot(x, y)plt.show() # 必须调用plt.show()才能显示图形 仅需一点点额外的工作，我们就可以轻松地一次绘制多条线，并添加标题、图例和轴标签： 1234567891011y_sin = np.sin(x)y_cos = np.cos(x)# 使用Matplotlib绘制这些点plt.plot(x, y_sin)plt.plot(x, y_cos)plt.xlabel('x axis label')plt.ylabel('y axis label')plt.title('Sine and Cosine')plt.legend(['Sine', 'Cosine'])plt.show() 您可以在官方文档中阅读有关plot函数的更多信息。 子图可以使用subplot函数在同一图中绘制不同的内容。下面是一个例子： 1234567891011121314151617181920# 计算正弦和余弦曲线上的点的x和y坐标x = np.arange(0, 3 * np.pi, 0.1)y_sin = np.sin(x)y_cos = np.cos(x)# 建立高度为2、宽度为1的子图网格，# 并将第一个子图设置为活动状态plt.subplot(2, 1, 1)# 绘制第一个图plt.plot(x, y_sin)plt.title('Sine')# 将第二个子图设置为活动状态，并绘制第二个图plt.subplot(2, 1, 2)plt.plot(x, y_cos)plt.title('Cosine')# 显示该图plt.show() 您可以在官方文档中阅读有关subplot函数的更多信息。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NumPy</tag>
        <tag>Matplotlib</tag>
        <tag>科学计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种外积的概念辨析]]></title>
    <url>%2F2020%2F02%2Fdiscrimination-of-several-outer-products%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习 PyTorch 的时候，看到文档中计算两个向量的“outer product”后得到一个矩阵。我刚开始理所当然地把“outer product”理解为高中所学的外积，即叉积。但我越想越不对劲：两个向量的叉积不应该还是向量吗，怎么会叉出矩阵来呢？查了一波资料后发现这里的“outer product”不是叉积，而是张量积。&emsp;&emsp;中文里的外积一词常出现在代数、几何学等领域中。对两向量 $\vec{A}$ 与 $\vec{B}$ 而言，外积可指： 叉积（Cross product），又称向量积（Vector product），常写为 $\vec{A}\times\vec{B}$； 楔积（Wedge product 或 Exterior product），常写为 $\vec{A}\wedge\vec{B}$； 张量积（Tensor product 或 Outer product），常写为 $\vec{A}\otimes\vec{B}$。 &emsp;&emsp;上述三种都可称作外积，但含义却大相径庭，因此极易出现混淆，尤其是“exterior”和“outer”都有外面的意思，我发现网上许多文章甚至一些教科书中都出现了翻译、解释上的错误。我认为避免混淆的最好办法就是使用“叉积”、“向量积”、“楔积”、“张量积”这些没有歧义的词语，而避免使用“外积”一词。&emsp;&emsp;下面是对几种外积概念的简要辨析。 一、叉积&emsp;&emsp;两个向量 $\vec{a}$ 和 $\vec{b}$ 的叉积仅在三维空间中有定义，写作 $\vec{a}\times\vec{b}$。在物理学中，叉积有时也被写成 $\vec{a}\wedge\vec{b}$，但在数学中 $\vec{a}\wedge\vec{b}$ 是外代数中的外积（楔积）。&emsp;&emsp;叉积可以定义为： \vec{a}\times\vec{b} = |\vec{a}||\vec{b}|\sin{\theta}\ \vec{n}其中 $\sin{\theta}$ 表示 $\vec{a}$ 和 $\vec{b}$ 在它们所定义的平面上的夹角（$0^{\circ}\leq\theta\leq180^{\circ}$）。$|\vec{a}|$ 和 $|\vec{b}|$ 是向量 $\vec{a}$ 和 $\vec{b}$ 的模长，而 $\vec{n}$ 则是一个与 $\vec{a}$、$\vec{b}$ 所构成的平面垂直的单位向量，方向由右手定则决定。 &emsp;&emsp;叉积可以表达为这样的行列式： \vec{u}\times\vec{v} = \begin{vmatrix}\vec{i}&\vec{j}&\vec{k}\\u_{1}&u_{2}&u_{3}\\v_{1}&v_{2}&v_{3}\end{vmatrix}&emsp;&emsp;沿第一行进行拉普拉斯展开可得： \begin{aligned} \vec{u}\times\vec{v} &= \begin{vmatrix}u_{2}&u_{3}\\v_{2}&v_{3}\end{vmatrix}\vec{i} + \begin{vmatrix}u_{1}&u_{3}\\v_{1}&v_{3}\end{vmatrix}\vec{j} + \begin{vmatrix}u_{1}&u_{2}\\v_{1}&v_{2}\end{vmatrix}\vec{k}\\ &= (u_{2}v_{3}-u_{3}v_{2})\vec{i} - (u_{1}v_{3}-u_{3}v_{1})\vec{j} + (u_{1}v_{2}-u_{2}v_{1})\vec{k} \end{aligned}二、楔积&emsp;&emsp;不了解，貌似是定义在张量空间上的一种运算。具体细节请移步维基百科外代数（格拉斯曼代数）词条，我反正看不懂。 三、张量积&emsp;&emsp;在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中,如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的：最一般的双线性运算。在某些上下文中也叫做外积。&emsp;&emsp;向量的外积是矩阵的克罗内克积的特殊情况。&emsp;&emsp;给定$m \times 1$列向量$\vec{u}$和$1 \times n$行向量$\vec{v}$，它们的外积$\vec{u} \otimes \vec{v}$被定义为$m \times n$矩阵$\mathbf{A}$，结果出自 \vec{u} \otimes \vec{v} = \mathbf{A} = \vec{u}\ \vec{v}这里的张量积就是向量的乘法。例子： \vec{b} \otimes \vec{a} \rightarrow \begin{bmatrix}b_1 \\ b_2 \\ b_3 \\ b_4\end{bmatrix} \begin{bmatrix}a_1 & a_2 & a_3\end{bmatrix} = \begin{bmatrix}a_1b_1 & a_2b_1 & a_3b_1 \\ a_1b_2 & a_2b_2 & a_3b_2 \\ a_1b_3 & a_2b_3 & a_3b_3 \\ a_1b_4 & a_2b_4 & a_3b_4\end{bmatrix}&emsp;&emsp;结果的秩为1，结果的维数为 4×3 = 12。这里的秩指的是“张量秩”（所需指标数），而维数计算在结果数组(阵列)中自由度的数目。]]></content>
      <categories>
        <category>学科</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>向量</tag>
        <tag>外积</tag>
        <tag>矩阵</tag>
        <tag>线性代数</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勇气的赞歌]]></title>
    <url>%2F2020%2F02%2Fthe-paean-of-courage%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;截至2月2日24时，持续肆虐的2019-nCoV急性呼吸疾病已经确诊超过1.7万例，此外还有超过2.2万疑似病例和近19万密切接触者。自从疫情爆发以来，越来越多的恐慌、谣言、猜忌、不信任甚至谩骂充斥在社交网络。诚然，现在人民的爆发并不全是天灾造成的，而是更多的来自于从地方政府到中央政府的错误决策与丑闻。越是在这种政府公信力和民族凝聚力最脆弱的时候，故宫停车、人民日报带货、鄂A0260W、武汉红十字会阻拦央视记者一类的事件便越会被积怨已久的人们无限放大，并以此作为宣泄心中愤懑的对象。然而，当人们都沉浸在对丑恶的斥责中时，会不会忘记了世间仍然存在的美好，会不会忘记了此时此刻还有多少人在坚守自己的岗位。我想，赞美勇气，要远比抨击怯懦来得有意义。&emsp;&emsp;刚刚看了回形针最新一期的视频《关于新冠肺炎的一切》，难能可贵的是，视频作者用客观的数据与文献资料向我们分析展示了关于此次疫情的真实信息。我在此对这些仍能保持冷静头脑的科普作者表示由衷的敬佩，并在下文引述视频中的一些内容，试图描绘此次疫情的大致轮廓。 以下包含非原创内容 关于疫情的伊始&emsp;&emsp;2019年12月8日，一位来自华南海鲜市场病人因为持续7天的发热、咳嗽和呼吸困难入院。5天后，他没有去过海鲜市场妻子也因为不明原因肺炎入院。&emsp;&emsp;2020年1月1日，华南海鲜市场关闭。1月2日，41名新型肺炎患者被确诊。&emsp;&emsp;此时喜迎新年的市民们还不知道，一场会感染上万人的瘟疫已经开始了。 关于人传人&emsp;&emsp;在1月24日发表于《柳叶刀》的论文《2019-nCoV感染患者的临床特征》（下载）中，我们可以了解最早被确诊的 41 名患者的具体情况。&emsp;&emsp;截至1月22日，41人中有28人出院，6人死亡。发烧和咳嗽是最常见的症状，从起病到呼吸困难，平均8天。 &emsp;&emsp;在肺炎初期，人传人的信号就已经很明显了，这41人中有14人都没有去过华南海鲜市场。 &emsp;&emsp;1月24日的另一篇论文《一场与2019年新型冠状病毒相关的家族肺炎表明了人与人之间的传播：家庭聚集研究》（下载）研究了一个12月29前往在武汉旅行的深圳家庭。&emsp;&emsp;最早出现症状的男士在到达武汉后的第4天开始发烧腹泻，之后3天，他的老婆岳父岳母和也都开始发烧咳嗽。1月5日，全家返回深圳，4天后，没有去过武汉的母亲开始全身乏力。最终，这个7口之家里，6人确诊新冠肺炎，包括他没有明显症状的儿子。 &emsp;&emsp;1月30的论文《新型冠状病毒感染的肺炎在武汉的早期传播动态》（下载）进一步分析了武汉前425例确诊患者的数据。 &emsp;&emsp;这张表中，横坐标是从感染至发病的时间，纵坐标是相对概率。可以看到大部分感染者7天内就会发病，病毒的平均潜伏期是5.2天。&emsp;&emsp;现在我们知道，在2020年1月11日之前确诊的295人里，只有45人去过华南海鲜市场，此外还有7名医护人员。 &emsp;&emsp;但在十天之后，人们才意识到要戴口罩了。 您的浏览器不支持video标签。 1月20日晚，官方首次肯定人传人 关于死亡率&emsp;&emsp;这是从1月16日到2月1日全中国累计确诊和死亡人数的增长曲线。如果我们用总死亡数除以总确诊数，可以得到一个2%左右的患病死亡率。 &emsp;&emsp;但这样的计算方式并不准确。根据前425名确诊患者的数据，我们可以知道病毒的平均潜伏期是5.2天，从发病到就诊平均是4.6天，就诊到入院平均4.5天，而入院到ICU是3.5天，假设从ICU到死亡是3天，整个过程就是21天左右。而如果就诊3天后就能确诊，那从确诊到死亡大概是8天。&emsp;&emsp;所以，1月31号的死亡患者大概在1月23号确诊。如果我们用湖北省1月29日—1月31日这三天死亡的124人除以1月21日—1月23日确诊的279人的话，病死率高达44.4%。&emsp;&emsp;但因为湖北省的医疗资源紧张确诊困难，很多老年病患发展到了重症才能确诊，病死率肯定偏高。相比之下，除湖北省外全国其他地区的数据更能反映真实情况。1月29日—1月31日，中国其他省份死亡患者共3人，除以1月21日—1月23日确诊的260人，病死率在1.1%左右，确实不高。&emsp;&emsp;如果按照这个病死率倒推1月21日—1月23日的湖北感染者，那应该不是279人，而是10700人。&emsp;&emsp;当然，这也只是一个非常粗糙的计算过程，样本量小，也不一定那么准确。但随着未来数据的完善，病死率的结果会越来越清晰。 关于勇气&emsp;&emsp;这场瘟疫让我们所有人精神紧张，但实际上，倒霉的事情每天都在发生。&emsp;&emsp;过去几年，中国平均每年有8.8万人死于流感引发的呼吸系统疾病，6.3万人死于交通事故，3.8万人死于安全事故。只要我们迈出家门，去工地，去写字楼，去流水线，风险就已经存在了。&emsp;&emsp;我们当然应该把倒霉的概率尽可能降低，但我们之所以赞颂勇气，是因为我们人类总是在明知风险的时候，仍然选择做我们该做的事情。 &emsp;&emsp;最后我们来看一眼这场肺炎的主角——这个直径在 0.1 微米左右的畸形圆球。可怕吗？我们已经知道了它的RNA序列、知道了它的感染机制、传播机制、临床表现和致死概率。其实也没那么吓人。&emsp;&emsp;如果我们被这个吓到，吓到要锁死来自武汉的邻居，吓到要攻击陌生的求助者，吓到要以谣言的名义让大家不敢说话。那才是真的吓人。&emsp;&emsp;人类的赞歌是勇气的赞歌，赞美所有还在认真工作的人们，希望新的一年，我们都能有更多勇气。 后记 &emsp;&emsp;惨象，已使我目不忍视了；流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵！不在沉默中爆发，就在沉默中灭亡。 ——鲁迅 &emsp;&emsp;值得庆幸的是，我们的社会还没有到“不在沉默中爆发，就在沉默中灭亡”的地步。但是，在这次疫情中，人民的政府、人民的红十字会，或者说我们的政府、我们的红十字会，仿佛已然陷入了塔西佗陷阱的无尽深渊。&emsp;&emsp;真正的人民政府不会允许官员全副武装却让医生手无寸铁，真正的红十字会也不会把人民的捐赠据为己有。人民永远是历史的创造者，当“人民政府”不再“人民”，当公权力开始丧失公信力之时，新的历史就会被人民书写。&emsp;&emsp;五千年屹立不倒的中华民族不会消亡，会消亡的只有失信于民的政权。真诚希望如今这个延续了七十年的政权能够幡然悔悟，带领人民走向安宁与富足，不要再让我们回到鲁迅所处的那至暗时代了。&emsp;&emsp;人类的赞歌是勇气的赞歌,人类的伟大是勇气的伟大。人们的勇气终将战胜疫情，希望这一天早日到来。最后，祝愿正笼罩在恐惧中的同胞幸福安康，向依然奋战在一线的医务工作者致以崇高的敬意。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>疫情</tag>
        <tag>死亡</tag>
        <tag>勇气</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【备忘】 youtube-dl使用方法]]></title>
    <url>%2F2020%2F02%2Fusage-of-youtube-dl%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;youtube-dl是一个Python编写的开源的音视频下载工具，只支持命令行操作。虽然名为youtube-dl，但它支持的站点非常多，包括了诸多国内外知名的音视频网站（查看完整的支持列表）。由于指令较多，容易忘记，故将常用的指令记录在此，以备不时之需。 安装官方GitHub仓库地址：https://github.com/ytdl-org/youtube-dlWindows下可以在releases页面找到最新发布版并直接下载youtube-dl.exe即可使用，更新方法如下：1youtube-dl -U Linux下可以通过pip安装：123pip install youtube-dl # 安装pip uninstall youtube-dl # 卸载pip install --upgrade youtube-dl # 更新 使用完整的指令列表和参数说明请见GitHub仓库里的官方文档，这里只记录最常用到的音视频下载指令由于众所周知的原因，大多数情况下都需要使用代理下载YouTube上的内容，因此下面所有指令都加上了--proxy socks5://127.0.0.1:1080/，即通过socks5协议的本地代理下载，记得挂上梯子并开启本地端口 列出所有可用的音视频格式1youtube-dl --proxy socks5://127.0.0.1:1080/ -F [url] 可以看到程序列出了该资源每个可用项的格式码、扩展名以及说明，其中包括audio only和video only 通过指定格式码下载 1youtube-dl --proxy socks5://127.0.0.1:1080/ -f [format code] [url] 下载纯音频至指定格式（需ffmpeg）需要保证ffmpeg在环境变量中或者与youtube-dl在同一目录才可正常转码 1youtube-dl --proxy socks5://127.0.0.1:1080/ -x --audio-format mp3 [url] 该指令可以下载音频并通过ffmpeg转至mp3格式，仅保留-x参数可以不转格式 下载最佳质量的音视频1234567891011# 下载最佳质量的音视频格式youtube-dl --proxy socks5://127.0.0.1:1080/ -f best [url]# 下载最佳质量的仅视频格式youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestvideo [url]# 下载最佳质量的仅音频格式youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestaudio [url]# 分别下载最高质量的仅视频和最高质量的仅音频格式，再用ffmpeg合并成一个最佳质量的mkv文件youtube-dl --proxy socks5://127.0.0.1:1080/ -f bestvideo+bestaudio [url]]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>下载</tag>
        <tag>工具</tag>
        <tag>视频</tag>
        <tag>YouTube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除夕夜小记]]></title>
    <url>%2F2020%2F01%2Fhappy-chinese-new-year-2020%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;除夕夜，万家灯火，十四亿华人共同迎接庚子年的到来。&emsp;&emsp;这个新年并不太平，刚一进入2020年，中华民族的儿女就历经了巨大挑战： 1月11日，蔡英文以史无前例的得票数连任台湾地区领导人，两岸关系不知将何去何从 1月16日，中美第一阶段经贸协议的签署让中国蒙受巨大损失，为即将打响的科技战、金融战埋下巨大隐患 1月23日，武汉封城，却难以阻止2019-nCoV在全国范围内大规模爆发，无人知晓真实的感染情况，无人知晓最终会付出多大的代价…… &emsp;&emsp;2020年，无论是国家命运，亦或是每一个国民的命运，都将注定不凡。真诚祝愿中华民族能够“风雨压不垮，苦难中开花”，继续屹立在世界东方。&emsp;&emsp;天佑中华！ 己亥年除夕于家中]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>生活</tag>
        <tag>新年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辩证法三大规律在生活中的体现]]></title>
    <url>%2F2019%2F12%2Fembodiment-of-three-laws-of-dialectics-in-life%2F</url>
    <content type="text"><![CDATA[大二上学期《马克思主义基本原理概论》实践环节报告 &emsp;&emsp;在本学期的《马克思主义基本原理概论》课堂上，我对辩证法及其三大规律即对立统一规律、量变质变规律和否定之否定规律有了系统的学习。为了对其有更为深刻的认识与理解，我尝试运用这三大规律来解释日常生活中的问题。以下我将分三个部分，分别阐述我在生活中对对立统一规律、量变质变规律和否定之否定规律的体会与感悟。一、生活中的对立统一规律&emsp;&emsp;对立统一规律作为唯物辩证法的实质和核心，在生活的各个角落都体现得淋漓尽致。例如平时我们在打篮球时，往往会遇到在攻守两端的体能分配问题：当我们在进攻端投入太多精力时，防守就会出现注意力不集中、漏人等情况；反之，若将重心放在防守上，那么进攻时就会出现体力不支、命中率下降的弊端。这告诉我们事物内部以及事物之间都包含着矛盾，即矛盾具有普遍性。&emsp;&emsp;除此以外，攻与守互为对立面，二者相互排斥、相互分离，体现着矛盾的斗争性；而攻与守又相互依存，在比赛中处于一个矛盾统一体中，因而出现所谓“以攻代守”、“防守带动进攻”等战术思想，体现了矛盾的同一性。攻守这对矛盾的同一性与斗争性共同作用在事物的发展即比赛的进程上，矛盾的两个对立面由于同一性和斗争性而相互转化，只有当攻守这对矛盾平衡、协调时事物才展现出和谐状态，球队才可能取胜。&emsp;&emsp;对立统一规律还体现在我们生病时吃药中，众所周知，大多数药物在帮助治疗疾病的同时，往往还伴随着或多或少的副作用，使我们出现不良反应。药物的正作用与副作用便构成了一对矛盾统一体。对立统一规律教导我们要把握主要矛盾和矛盾的主要方面，因此需要综合考量药物的治疗作用与副作用，判断其治疗作用带来的利与副作用带来的弊孰大孰小，当利大于弊时，医生或药师就会让我们服药，并且严格控制剂量以寻求矛盾的平衡。&emsp;&emsp;在生活中，我们应该学会用对立统一的眼光看待每一件事物，发现其内在的矛盾，坚持“两点论”和“重点论”的统一，这样我们才会对我们所处的这个世界有更为透彻的认识。二、生活中的量变质变规律&emsp;&emsp;量变和质变是事物变化的两种基本状态和形式，它们间的相互作用、相互转化在日常生活中极其常见，举一个最简单的例子：用水杯接水，在杯子满之前，杯内水的体积连续增加，属于持续的量变，当杯满的瞬间，其状态就会发生质变，即水开始溢出。这个质变的过程标志着水杯的状态阶段的更替，即由接水阶段更替为溢水阶段，这就是为什么说量变质变规律指出了连续性与阶段性的统一。&emsp;&emsp;除了接水，生活中处处体现着量变质变的规律。上学以来，许多老师都曾教导过我们要注重平时的积累，不论是英文单词的积累、诗词歌赋的积累，还是如今对代码量的积累，都是为了在相应领域的水平能够从量变到质变。&emsp;&emsp;量变和质变的辩证关系告诉我们量变是质变的必要准备。诚然，如果没有对英文单词的大量积累，我们就不可能读懂英文前沿期刊上的长篇大论；如果没有对诗词歌赋的大量背诵，就不会有“腹有诗书气自华”的精神风骨；如果没有对各类数据结构与算法的大量代码书写，就不可能在大型项目工程中熟练地运用各种算法并有效率地写出优质代码。这些积累就好比摩天大楼的根基，它们的必要性不言而喻。&emsp;&emsp;量变和质变的辩证关系还告诉我们质变是量变的必然结果。所以说，当一个人能够坚持一个好习惯足够长时间，这个好习惯最终注定会让他受益；同理，当一个人迟迟不肯改正他的坏习惯，那么这个坏习惯最终同样会给他烙上深深的烙印。因此量变质变规律教导我们，要坚持优良习惯，追求量变向质变的转化，同时要及时摒弃不良习惯，以防量变转向质变。三、生活中的否定之否定规律&emsp;&emsp;我们时常听到诸如“前途是光明的,道路是曲折的”一类的话语，其中就蕴含着否定之否定规律所揭示的事物发展的前进性与曲折性的统一。&emsp;&emsp;提到一规律时，我想最为人熟知的就是由地心说到日心说到现代天文学的曲折发展历程，在此我不想赘述。作为计算机科学与技术专业的本科生，适逢本学期学习了《计算机组成原理》一课，我想用否定之否定规律对CPU控制器的演进历程做出解读：在早期计算机中，由于逻辑功能简单，电路并不复杂，因此多采用硬布线控制器的设计，这就是第一阶段——肯定阶段；随着人们对计算机的功能需求不断增多以及复杂指令集的出现，若沿用硬布线控制器，则电路将十分复杂，因此人们摒弃了难以实现的硬布线控制器，设计了牺牲效率但电路简单的微程序控制器，这是第二阶段——否定阶段；如今，芯片制造技术极其成熟，生产复杂的硬布线控制器已不再是难事，故追求极致效率的人们便否定了效率低下的微程序控制器，重新采用硬布线控制器，这便是第三阶段——否定之否定。由此可见CPU控制器的演化并不是一帆风顺的，而是不断对此前的缺陷进行否定，螺旋式上升，很好的体现了事物发展的前进性与曲折性。&emsp;&emsp;其实，在我们的身边一样能找到类似的事情。比如，若我们闷头读书，只注重理论学习，那么在实践操作时我们就会束手无策，于是我们对此前的做法进行了否定，开始投入实践，尝试新鲜技术，减少理论学习；然而缺少了理论的支撑，我们对新生技术的原理就会感到茫然，无法透彻理解，因此我们需要进行否定之否定，做到理论与实践并重。&emsp;&emsp;由此可见，辩证法的三大规律体现在我们日常生活中的方方面面，很多实际问题都可以运用这三大规律进行很好地解释。通过这段时间的实践，我逐渐感受到对立统一规律、量变质变规律和否定之否定规律不但可以帮助我们解释问题，还对我们的学习生活有着很强的指导作用，让我们的行为更具智慧。在今后的生活中，我们需要勤于思考，时刻按辩证法所教导我们的规律行事，不要违背客观规律，否则只会与成功渐行渐远。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>辩证法</tag>
        <tag>马克思主义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么人类命运共同体理念产生了广泛而深远的国际影响？]]></title>
    <url>%2F2019%2F11%2Fthe-international-influence-of-the-concept-of-a-community-of-shared-future-for-mankind%2F</url>
    <content type="text"><![CDATA[大二上学期《形式与政策》论文 &emsp;&emsp;自党的十八大习近平总书记首次提出人类命运共同体理念以来，这一追求共同发展的价值观越来越被国际社会所接受。中国也不断提出构建人类命运共同体的中国方案，贡献着中国智慧。我认为，之所以人类命运共同体理念能够产生如此广泛而深远的国际影响，是因为这个价值理念维护着全世界人民的共同利益，能够兼容不同文化、不同种族的人民的价值理念。&emsp;&emsp;我认为，“人类命运共同体”不是哪一个人、哪一政党或是哪一国家的专利，而是一个客观存在的事实，全人类本就是一个“一荣俱荣，一损俱损”的命运共同体。纵观地球46亿年的浩瀚历史，人类的发展仅仅持续了不过15万年，因此人类文明的存在对于我们的家园——地球来说，只是弹指一挥间。我们主宰不了地球的命运，我们能够左右的，只有我们人类自己的命运。生存是文明的第一需要，人类利益远高于国家利益或是个人利益，因为当人类的共同利益即生存需要受到威胁时，国家间的较量、个人的财富和社会地位也就变得毫无意义。然而此时此刻，我们的生存正受到威胁，领土争端、民族宗教矛盾、恐怖袭击等事件时刻破坏着世界人民的安全与秩序，对地球资源的过度开发、碳排放的持续增加、核武器的扩散更是让人类愈发接近毁灭的边缘。&emsp;&emsp;要想捍卫全人类的共同利益，必须各个国家通力合作、达成共识，在追求自身利益的同时兼顾他国利益，时刻站在全人类的共同立场，与地球上的人民同呼吸、共命运。尤其是大国，更应该站在更高的角度审视问题，因为能够主宰人类命运的往往正是世界当中的强权。正如1962年的古巴导弹危机，美苏两国的军备竞赛把全人类推向了毁灭的边缘，国家间的不正当竞争险些让千年人类文明付之一炬。如今两极格局的世界已不复存在，但热核战争的威胁依旧笼罩在全世界人民头上，在朝核、伊核问题上，中国坚持倡导以对话、谈判的方式解决争端，在维护地区和平稳定方面贡献了自己的力量，体现出了大国外交的国际责任感。&emsp;&emsp;我认为，中国首先提出人类命运共同体理论，是中国和平崛起的象征，体现了我国的大国担当与大国责任。在当今世界多极化、经济全球化的趋势下，有更多的国家需要承担起维护人类共同利益的责任与使命，在这一方面，中国起到了很好的表率作用。在博鳌亚洲论坛、联合国大会、“一带一路”国际合作高峰论坛、二十国集团领导人峰会等国际会议上，我国多次向全世界发出构建人类命运共同体的倡议，并不断传达中国理念、提出中国方案。此外，中国身体力行，在经济、文化、教育、环境等诸多领域都为全世界做出了重大贡献，我们摒弃冷战思维的零和博弈，倡导互利共赢，“一带一路”建设为人类创造了巨大利益，是人类命运共同体理念的最好表现。&emsp;&emsp;中国从来没有像今天这样接近世界舞台中心, 从来没有像今天这样全方位影响世界。如今的中国，正在成为构建人类命运共同体的倡导者、实践者、先行者, 不断为人类做出更大贡献。正是因为符合全人类的价值理念、保障全人类的切身利益，人类命运共同体理念才会产生如此广泛而深远的国际影响。我相信世界各国会同中国一道，用互利共赢取代零和博弈，为全人类谋福祉，实现共同繁荣的“世界梦”。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>形式与政策</tag>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>人类命运共同体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我与共和国共成长]]></title>
    <url>%2F2019%2F10%2FI-grow-with-the-Republic%2F</url>
    <content type="text"><![CDATA[大二上学期《马克思主义基本原理概论》实践环节报告注：虽然是为了完成作业，但参加这次大典我确实感触颇多，此次经历真的胜过千百次爱国主义教育，令人记忆深刻，因此这篇文章具有一定纪念意义。 &emsp;&emsp;“今天是你的生日，我的中国。清晨我放飞一群白鸽，为你衔来一枚橄榄叶，鸽子在崇山峻岭飞过。”当童声演唱的《今天是你的生日》打破长安街清晨的寂静，仿佛有一股电流瞬间穿过我的脊背，使原本睡眼惺忪的我不禁颤栗，泪珠在眼眶中打转。这是我由衷地为祖国母亲感到动容，因为我深深地知道，我的祖国七十年一路走来，经历了什么样的惊涛骇浪，克服了什么样的艰难险阻。我想，只有了解了新中国走到今天的不易，才会发自肺腑地为之献上最美好的祝福，才会从心底里说出那句“我爱你，中国”。&emsp;&emsp;直到此时回顾参加群众游行的经历，我仍心潮澎湃。我们数十天的训练，为的是向全世界展示当代中国青年的朝气蓬勃，为的是向全世界展示中国人民群众强大的凝聚力。能够有幸成为十四亿中华儿女的代表，我感到无比荣幸与自豪。在10月1日的正义路上，我们聆听了习近平主席在庆祝中华人民共和国成立70周年大会上的讲话，其中讲到：“今天，社会主义中国巍然屹立在世界东方，没有任何力量能够撼动我们伟大祖国的地位，没有任何力量能够阻挡中国人民和中华民族的前进步伐”[1]，我相信我身边的每个人听到这里都像我一样慷慨激昂，这种空前的民族自豪感，是新中国从站起来富起来到强起来的最好印证。&emsp;&emsp;随着分列式的开始，我们涌入长安街两侧，坦克、装甲车的轰鸣声充斥着我的双耳，雄壮威武的武器装备从我眼前缓缓经过。难以想象无侦-8、攻击-11、东风-17、东风-41等最先进的国防重器竟距离我不足10米远。我想，这种场景所带来的震撼，远比任何爱国主义教育都要来得实在。新中国国防实力的提升一举改变了近代中国落后挨打的局面，也使中国人有底气屹立在世界民族之林。&emsp;&emsp;当《红旗颂》奏响，“致敬”方阵的礼宾车从我面前驶过，大家情不自禁地向车上的新中国缔造者亲属、老红军、老八路军、老解放军挥动五星红旗。他们为了民族独立和人民幸福做出了卓著贡献，铸就了坚强不屈的民族脊梁，他们值得接受我们每一名中国人向他们的致敬。&emsp;&emsp;走在“一国两制”方阵里，我们挥舞旗帜，欢呼致意。当我们经过天安门前，我向左望去，看到孙中山先生凝望着广场，这位革命的先行者曾经奋力让黑暗的中国走向黎明；我又向右望去，看到毛泽东主席注视着广场，这位开国领袖让沉睡的东方雄狮昂起了头颅。我们每一个人高喊“祖国我爱你”，喊出的不光是我们自己的心声，更代表了包含港澳台同胞在内的十四亿中华儿女的心声。我坚信，在“一国两制”伟大构想的框架下，香港明天会更好，澳门明天会更好，祖国统一大业也终将实现。&emsp;&emsp;在我回看这次庆祝大会的时候，一句解说词让我久久不能忘怀：“今天的天安门广场是世界瞩目的中心，今天的中国正前所未有的靠近世界舞台中心。”诚然，中国正以和平崛起的方式，悄然走向世界的中心。回望我与共和国共同走过的这十九年，我见证了中国加入世界贸易组织，见证了一届难以超越的奥运会，见证了诺贝尔文学奖和诺贝尔生理学或医学奖花落神州大地，见证了北京的“APEC蓝”，见证了G20峰会的“最忆是杭州”，见证了世界第二大经济体之名的易主，这些都是中国一步步迈向世界舞台中心所留下的坚实脚印。&emsp;&emsp;中国的和平崛起必将经历艰难险阻的考验，当今的中国，正面临着前所未有的巨大挑战。对外，在美国坚持奉行单边主义、贸然向中国挑起“贸易战”的情形下，需要我们众志成城、共同面对，同时坚持以和平谈判的方式解决争端；对内，香港“反送中”运动的延烧仍需林郑政府在“一国两制”的框架下提出一个智慧的解决方案，台湾问题同样要求双方领导集团运用各自的大智慧，以政治谈判的方式共同推进和平统一进程。诚然，当下的形势是严峻的，但这也是复兴之路上我们不得不面对的挑战。&emsp;&emsp;面对挑战，需要我们青年一代做出自己的贡献。经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位[2]。随着我阅历的增长与思想认识的不断深化，我愈发意识到自己处在这个令我心潮澎湃的“黄金时代”：我今年19岁，到2035年社会主义现代化基本实现时，还不到40岁；到本世纪中叶全面建成社会主义现代化强国时，刚刚50岁。我将有幸成为民族复兴伟大进程的见证者与亲历者，但是，我更想成为开创者与建设者。我深知，如今的青春中国风华正茂，民族复兴的梦想正由我们去实现。为此，需要我继续加强理论知识学习，增强自身能力，在学校、社会中起积极带头作用，用自己的奋斗走好我们这一代人的新长征。&emsp;&emsp;共和国见证着我的成长，我也见证着共和国一步步走向强盛。在接下来的漫长道路上，我与共和国仍将继续披荆斩棘，共同成长，向民族复兴的共同目标不断迈进。祝福我与共和国的明天更加灿烂辉煌！ 参考文献：&emsp;&emsp;[1]习近平.在庆祝中华人民共和国成立70周年大会上的讲话[M].人民出版社:北京,2019:1.&emsp;&emsp;[2]习近平.决胜全面建成小康社会夺取新时代中国特色社会主义伟大胜利——在中国共产党第十九次全国代表大会上的报告[M].人民出版社:北京,2017:1.]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>国庆</tag>
        <tag>群众游行</tag>
        <tag>爱国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【音乐】庆祝中华人民共和国成立70周年阅兵式军乐欣赏]]></title>
    <url>%2F2019%2F10%2Fthe-military-music-of-the-parade%2F</url>
    <content type="text"><![CDATA[点击进入播放器 《钢铁洪流进行曲》 - 中国人民解放军联合军乐团 《东风浩荡进行曲》 - 中国人民解放军联合军乐团 《雄鹰出击进行曲》 - 中国人民解放军联合军乐团 《冲上云霄》 - 中国人民解放军联合军乐团]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>军乐</tag>
        <tag>交响乐</tag>
        <tag>阅兵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假小结]]></title>
    <url>%2F2019%2F08%2Fsummer-vacation-summary%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;此时此刻，窗外不断传来大一新生军训中演讲比赛的激昂呐喊。新鲜血液的涌入着实给了我一种紧迫感，回想一年前，我也和他们一样，刚刚踏入大学的校门，心中有憧憬也有迷茫。转眼一年过去了，仿佛憧憬与迷惘都变多了。&emsp;&emsp;从7月13号到今天，一个半月的暑假已接近尾声。其实这个暑假做的事有限，掰着手指头数都能数的过来，所以本来没想写这个总结。但思前想后觉得还是应该简要记录一下，也算是警醒自己今后要做更多有意义的事。&emsp;&emsp;文字能力有限，依旧是流水账。&emsp;&emsp;小学期里，我们的任务是完成“外卖派单模拟系统”，这是我第一次着手这种具有一定规模的项目，项目需求与规则繁杂且模糊，并且几经修改，最要命的是在7月13号验收的前一天傍晚被要求新增不少功能，所有人都很无奈。好在经历了几天几夜的爆肝之后，顺利完成了验收。最终，我们花大量精力研究的算法在所有组的比拼中喜提头名，可喜可贺。然而看了别的组华丽的GUI之后我们才意识到我们在用户体验上所做的工作确实有些简陋，不过这也是在时间紧迫的前提下所做出的必然取舍，因为在我们看来，相比于图形界面，算法是我们更应该投入精力去琢磨的地方。&emsp;&emsp;暑假伊始，由于刚刚结束了小学期的项目，有些身心俱疲，所以没干什么正事。唯一做的就是 Express + EJS + ajax + MongoDB 写了一个 ToDo List，顺带学到了些前端知识。到了七月底回到学校，参加某大型红色活动的训练，为期二十余天，除了太阳晒点，还是比较轻松欢愉的。训练之余，在宿舍学习了 Docker，并尝试把我所有的站点和服务进行容器化，不过目前还只是在虚拟机上，没有上线。等过段时间域名完成备案，可以A记录解析到服务器上之后应该就可以享受 docker-compose up -d 一键部署的快感了😝。&emsp;&emsp;在此之后训练任务断断续续，我的暑假生活也以娱乐为主，通关了老早以前搁下的弹丸论破1和2，没事就和舍友开黑GTAOL，还是挺轻松加写意的。&emsp;&emsp;总的来说这个暑假过得很快活，但有意义的事做得不多，换句话说，有点浪费。不过这一切都是我自己的选择，也不会后悔。期待下学期的学习生活，也期待十月一号能够用最好的表现为祖国母亲七十华诞献礼！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文案排版指北]]></title>
    <url>%2F2019%2F08%2Fchinese-copywriting-guidelines%2F</url>
    <content type="text"><![CDATA[原文地址：https://github.com/sparanoid/chinese-copywriting-guidelines 中文文案排版指北空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。 毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间需要增加空格正确： 我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB 错误： 我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB 例外：度 / 百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ 刚刚买了一部 iPhone， 好开心！ 用 text-spacing 来挽救？CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace.aspx) 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全形和半形』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！ 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！ 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这个蛋糕只卖 1000 元。 错误： 这个蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。 遇到完整的英文整句、特殊名词，其内容使用半角标点正确： 贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？”]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>文档</tag>
        <tag>标准</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualenv创建Python虚拟环境时抛出UnicodeDecodeError异常的解决]]></title>
    <url>%2F2019%2F07%2Fsolution-of-UnicodeDecodeError-thrown-by-virtualenv%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在通过pip安装TensorFlow时遇到了一个问题，当执行virtualenv --system-site-packages -p python ./venv创建新的虚拟环境时会抛出如下异常：123456789101112131415161718192021Traceback (most recent call last): File "e:\python\lib\site-packages\virtualenv.py", line 939, in call_subprocess line = line.decode(encoding)UnicodeDecodeError: 'utf-8' codec can't decode byte 0xca in position 38: invalid continuation byteDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File "e:\python\lib\site-packages\virtualenv.py", line 2635, in &lt;module&gt; main() File "e:\python\lib\site-packages\virtualenv.py", line 870, in main symlink=options.symlink, File "e:\python\lib\site-packages\virtualenv.py", line 1173, in create_environment install_wheel(to_install, py_executable, search_dirs, download=download) File "e:\python\lib\site-packages\virtualenv.py", line 1019, in install_wheel _install_wheel_with_search_dir(download, project_names, py_executable, search_dirs) File "e:\python\lib\site-packages\virtualenv.py", line 1110, in _install_wheel_with_search_dir call_subprocess(cmd, show_stdout=False, extra_env=env, stdin=script) File "e:\python\lib\site-packages\virtualenv.py", line 941, in call_subprocess line = line.decode(fs_encoding)UnicodeDecodeError: 'utf-8' codec can't decode byte 0xca in position 38: invalid continuation byte &emsp;&emsp;经过一番研究，原来出现异常的原因是调用decode()方法的errors参数为默认值&quot;strict&quot;，即任何编码错误都会引发UnicodeDecodeError，将其更改为&quot;ignore&quot;即可忽略错误。具体修改如下：&emsp;&emsp;根据异常信息，将Python安装目录下的.\Lib\site-packages\virtualenv.py的第939行修改为line = line.decode(encoding, &quot;ignore&quot;)，即增加一个&quot;ignore&quot;参数。再次尝试创建虚拟环境，此时就不会抛出异常了：123456Running virtualenv with interpreter E:\Python\python.exeAlready using interpreter E:\Python\python.exeUsing base prefix 'E:\\Python'New python executable in D:\TensorFlow\venv\Scripts\python.exeInstalling setuptools, pip, wheel...done. &emsp;&emsp;这时我们就拥有了一套独立的Python运行环境，不用担心污染主环境了]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>virtualenv</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【备忘】 SS代理服务器配置及优化]]></title>
    <url>%2F2019%2F07%2Fconfiguration-and-optimization-of-ss-proxy-server%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于Vultr日本节点大量被墙，所以被迫转投DigitalOcean，最便宜的是5刀一个月，但首充5刀后会送50刀，再加上Github教育礼包里包含的50刀优惠（需要验证教育邮箱、上传学生证照片），所以算下来几乎可以白嫖两年，岂不美滋滋。美中不足是DigitalOcean的系统快照占用的存储空间是要另付费的，所以每次换IP开新机就需要重新配置代理服务器，这里简单记录一下流程和命令，方便以后复制。 以Ubuntu 18.04搭建SS服务为例，如果今后SS情势不好可能会换用V2Ray 安装及配置项目地址：https://github.com/shadowsocks/shadowsocks/tree/master123456# 从源更新软件列表apt-get update# 安装pipapt-get install python-pip# pip安装SSpip install git+https://github.com/shadowsocks/shadowsocks.git@master 安装完成后可以建两个脚本start.sh、stop.sh方便控制服务开关（或编写json配置文件，反而麻烦）start.sh：1sudo ssserver -p 端口 -k 密码 -m aes-256-cfb --user nobody -d start stop.sh：1sudo ssserver -d stop 最后还要给这两个脚本赋予执行权限1chmod +x start.sh stop.sh # 或直接chmod 777 开启服务之前可以做以下优化，提高带宽利用率 优化首先按照官方Wiki上的教程进行优化，地址：https://github.com/shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks创建/etc/sysctl.d/local.conf并写入以下配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445# max open filesfs.file-max = 51200# max read buffernet.core.rmem_max = 67108864# max write buffernet.core.wmem_max = 67108864# default read buffernet.core.rmem_default = 65536# default write buffernet.core.wmem_default = 65536# max processor input queuenet.core.netdev_max_backlog = 4096# max backlognet.core.somaxconn = 4096# resist SYN flood attacksnet.ipv4.tcp_syncookies = 1# reuse timewait sockets when safenet.ipv4.tcp_tw_reuse = 1# turn off fast timewait sockets recyclingnet.ipv4.tcp_tw_recycle = 0# short FIN timeoutnet.ipv4.tcp_fin_timeout = 30# short keepalive timenet.ipv4.tcp_keepalive_time = 1200# outbound port rangenet.ipv4.ip_local_port_range = 10000 65000# max SYN backlognet.ipv4.tcp_max_syn_backlog = 4096# max timewait sockets held by system simultaneouslynet.ipv4.tcp_max_tw_buckets = 5000# turn on TCP Fast Open on both client and server sidenet.ipv4.tcp_fastopen = 3# TCP receive buffernet.ipv4.tcp_rmem = 4096 87380 67108864# TCP write buffernet.ipv4.tcp_wmem = 4096 65536 67108864# turn on path MTU discoverynet.ipv4.tcp_mtu_probing = 1# for high-latency networknet.ipv4.tcp_congestion_control = hybla# for low-latency network, use cubic instead# net.ipv4.tcp_congestion_control = cubic 最后的net.ipv4.tcp_congestion_control选择hybla还是cubic取决于服务器延迟的高低然后加载我们写好的配置文件：1sysctl --system 接下来是启用TCP BBR拥塞控制算法，可以用来取代ServerSpeeder已经有人做好了傻瓜式脚本，我们只需要根据提示操作：1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 使用lsmod | grep bbr查看系统模块，若返回tcp_bbr说明BBR已启动 这时我们就可以运行start.sh，开启代理服务，进行科学上网了]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在十八岁的最后一天]]></title>
    <url>%2F2019%2F07%2Fon-my-last-day-of-eighteen%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;十八岁，过的可真快，转眼就到了最后一天，以至于我还没反应过来。这就好比，在看一场精彩绝伦的足球赛时，往往会觉得上半场怎么这么快就结束了。而我的十八岁，虽称不上精彩，但也足够充实，或者说，只是单纯的忙碌，忙碌到这一年里发生的许多事我都快忘却了，所以我才要在这儿记下那些快要忘却的事，也算是对自己的十八岁做个简要的小结吧。&emsp;&emsp;如果用一个词来总结这一年的话，我想应该是五味杂陈吧，因为这一年里，我哭过，痛过，累过，当然，也笑过。在度过了一个安逸的暑假之后，我开启了大学之旅，第一学期可以说是平淡无奇的四个月——很快我就适应了大学里的生活节奏，接着就是在上课、作业、游戏中轮回，周而复始。除了基本的课业知识，没有任何长进，虽然成绩还不错，但我对那个学期是不满意的，因为我虚度了四个月的时光。&emsp;&emsp;浪费就会受到惩罚，这是颠扑不破的真理。很快，惩罚就降临了。我别无选择，只得默默接受。接下来的寒假对我来说无疑是煎熬的，当然，也有痛定思痛、扪心自问。&emsp;&emsp;在假期临近结束之际，我做出了让我自己为之骄傲的决定，我遵从了自己的内心，提交了转专业申请，向自己的热爱与理想迈出了一大步。这一次，我终于没再辜负你，也没再辜负自己，这就是我为之骄傲的原因。&emsp;&emsp;第二学期，我体验到了从未有过的忙碌与充实，大大小小的事务等待着我去一一处理，一个个抉择与挑战摆在我面前。这个学期，我参加了ACM校赛，见识了那些高水平选手的风采，让我深刻体会到天外有天，人外有人。我正视到自己的差距，意识到此刻开始追赶并不是一个明智的选择，ACM竞赛也并非我所认为的计算机科学的最好体现。正所谓条条大路通罗马，我需要尽早找到自己真正感兴趣的方向，追寻我所憧憬的计算机科学。&emsp;&emsp;这一年，也是我自信心大幅提升的一年。我向自己证明了我的能力：第一学期综合成绩排名18/808，转入计科实验班后排名3/55，进入火花空间创客社团技术组，担任过一次技术沙龙的主讲人，带领宿舍全员设计开发寻物微信小程序……这些成绩告诉我，我不必自卑，无论在哪，我都能够站稳脚跟、发挥自己的作用、实现自己的价值。&emsp;&emsp;人际交往方面，我倒是没有什么变化：不大不小的朋友圈，几个挚友，一个念念不忘的人，没有树敌。偶尔会感到孤独，但孤独是人生的必修课，我想这样就挺好。&emsp;&emsp;这学期有位老师的一段话引发了我的思考：“科学是和人们的生活不相干的东西，而造福人类的是技术”。一开始，我对这种说法嗤之以鼻，心想科学怎么会和人们无关呢，但仔细想想，这种说法其实不无道理，科学与技术相辅相成——科学是技术的前提，而技术是科学的实现，因此科学对生活的影响是间接的，技术是直接的。我认为科学之于技术好比世界观之于方法论：方法论真正左右我们的行为，而决定方法论的却是世界观。&emsp;&emsp;对科学与技术的思考让我对未来感到有些迷茫。如果你在十年前问我未来的职业理想是什么，我也许会给出和大部分孩子一样的答案：科学家，当然，这是一个极其笼统的回答；如果你在三年前问我同样的问题，我会毫不犹豫的回答你：计算机科学家；但如果你现在再来问我，我会犹豫，因为也许技术从业者会为这个社会创造更大的价值。这样的迷茫可能会持续一段时间，在我找到答案之前，我需要不断培养自己的计算思维、扩充自己的技术栈，尽可能做到理论与实践并行。&emsp;&emsp;还有三个小时，我的十八岁就要过去了，竟有些伤感。十八岁，有太多的始料未及，此后，再不会有八月瓢泼大雨里的那种感动，再不会有一月寒风凛冽中的那种悲痛。时间会冲淡一切，现在需要我做的，就是以更好的态度，迎接十九岁的时空旅行。&emsp;&emsp;薯片忍者，生日快乐！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>生活</tag>
        <tag>人生</tag>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构考试——链表去重]]></title>
    <url>%2F2019%2F06%2Flinked-list-duplicate-removal%2F</url>
    <content type="text"><![CDATA[链表去重时间限制: 400 ms内存限制: 64 MB 给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。输入格式：输入在第一行给出 L 的第一个结点的地址和一个正整数 N（≤10^5，为结点总数）。一个结点的地址是非负的 5 位整数，空地址 NULL 用 -1 来表示。随后 N 行，每行按以下格式描述一个结点：1地址 键值 下一个结点 其中地址是该结点的地址，键值是绝对值不超过10^4的整数，下一个结点是下个结点的地址。 输出格式：首先输出去重后的链表，然后输出被删除的链表。每个结点占一行，按输入的格式输出。 输入样例:12345600100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854 输出样例:1234500100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct node&#123; int val; int next;&#125; ram[100005];int exist[100005] = &#123;0&#125;;int main()&#123; int start, n, addr, val, next; scanf("%d%d", &amp;start, &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;addr, &amp;val, &amp;next); ram[addr].val = val; ram[addr].next = next; &#125; int a[n], na = 1, b[n], nb = 0; a[0] = start; exist[abs(ram[start].val)] = 1; for(int i = ram[start].next; i != -1; i = ram[i].next) &#123; if(!exist[abs(ram[i].val)]) &#123; exist[abs(ram[i].val)]++; a[na++] = i; &#125; else b[nb++] = i; &#125; for(int i = 0; i &lt; na; ++i) &#123; printf("%05d %d ", a[i], ram[a[i]].val); if(i == na-1) printf("-1\n"); else printf("%05d\n", a[i+1]); &#125; for(int i = 0; i &lt; nb; ++i) &#123; printf("%05d %d ", b[i], ram[b[i]].val); if(i == nb-1) printf("-1\n"); else printf("%05d\n", b[i+1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构考试——关于堆的判断]]></title>
    <url>%2F2019%2F06%2Fjudgment-of-heap%2F</url>
    <content type="text"><![CDATA[关于堆的判断时间限制: 400 ms内存限制: 64 MB 将一系列给定数字顺序插入一个初始为空的小顶堆H[]。随后判断一系列相关命题是否为真。命题分下列几种： x is the root：x是根结点； x and y are siblings：x和y是兄弟结点； x is the parent of y：x是y的父结点； x is a child of y：x是y的一个子结点。 输入格式：每组测试第1行包含2个正整数N（≤ 1000）和M（≤ 20），分别是插入元素的个数、以及需要判断的命题数。下一行给出区间[−10000,10000]内的N个要被插入一个初始为空的小顶堆的整数。之后M行，每行给出一个命题。题目保证命题中的结点键值都是存在的。 输出格式：对输入的每个命题，如果其为真，则在一行中输出T，否则输出F。 输入样例:1234565 446 23 26 24 1024 is the root26 and 23 are siblings46 is the parent of 2323 is a child of 10 输出样例:1234FTFT 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;int H[1005], ind[20005];void adj(int start, int end) //向下调整&#123; int rc = H[start]; int s = start; for(int j = start * 2; j &lt;= end; j *= 2) &#123; if(j &lt; end &amp;&amp; H[j+1] &lt; H[j]) j++; if(rc &gt; H[j]) &#123; H[s] = H[j]; s = j; &#125; else break; &#125; H[s] = rc; return;&#125;int main()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;H[i+1]); for(int j = (i+1)/2; j &gt; 0; --j) //每次插入后都需要向上调整成小根堆 adj(j, i+1); &#125; //存储索引 for(int i = 0; i &lt; n; ++i) ind[H[i+1] + 10000] = i+1; int a, b, ans = 0; char comm[10]; while(m--) &#123; ans = 0; scanf("%d%s", &amp;a, comm); if(comm[0] == 'a') &#123; scanf("%d%*s%*s", &amp;b); if(ind[a + 10000] / 2 == ind[b + 10000] / 2) ans = 1; &#125; else &#123; scanf("%s", comm); if(comm[0] == 'a') &#123; scanf("%*s%*s%d", &amp;b); if(ind[a + 10000] / 2 == ind[b + 10000]) ans = 1; &#125; else &#123; scanf("%s", comm); if(comm[0] == 'r') &#123; if(ind[a + 10000] == 1) ans = 1; &#125; else &#123; scanf("%*s%d", &amp;b); if(ind[b + 10000] / 2 == ind[a + 10000]) ans = 1; &#125; &#125; &#125; printf("%c\n", ans ? 'T' : 'F'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
        <tag>二叉树</tag>
        <tag>最小堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[争做新时代新青年——读《习近平谈治国理政》有感]]></title>
    <url>%2F2019%2F06%2Fthoughts-after-reading-Xi-Jinping-The-Governance-of-China%2F</url>
    <content type="text"><![CDATA[大一下学期《中国近现代史纲要》实践环节报告P.S. 其实根本没读 &emsp;&emsp;本学期，我仔细研读了《习近平谈治国理政》一书，感触颇深。全书包含了有关国家发展、社会建设的方方面面，由于今年适逢五四运动爆发一百周年与新中国成立七十周年，因此我想着重对青年人在新时代的责任与担当以及我的切身体会进行阐述。&emsp;&emsp;“中国梦是历史的、现实的，也是未来的；是我们这一代的，更是青年一代的。中华民族伟大复兴的中国梦终将在一代代青年的接力奋斗中变为现实。”，这是习近平总书记在同各界优秀青年代表座谈时所讲的一句话，也是最触动我的一句话。诚然，青年人肩负着重大历史使命和时代责任，正所谓青年兴则国家兴，青年强则国家强，可见青年一代对民族命运的重要意义。也正因如此，党的十九大提出了“培养担当民族复兴大任的时代新人”的战略要求。作为大学生的我们，是国家宝贵的人才资源，是民族的希望、祖国的未来，肩负着人民的重托、历史的重任，我必须以民族复兴为己任，勇做时代的弄潮儿，做有理想有本领有担当的时代新人。&emsp;&emsp;十九大报告指出，经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位。随着我阅历的增长与思想认识的不断深化，我愈发意识到自己处在这个令我心潮澎湃的“黄金时代”：我今年18岁，到2035年社会主义现代化基本实现时，还不到40岁；到本世纪中叶全面建成社会主义现代化强国时，刚刚50岁。我将有幸成为民族复兴伟大进程的见证者与亲历者，但是，我更想成为开创者与建设者。我坚信，这个承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代需要我们青年一代做出自己的贡献。&emsp;&emsp;作为新时代的新青年，我深知自己将肩负起实现中华民族伟大复兴的中国梦这一重大使命，正因如此，我始终严格要求自己。去年5月2日，习近平总书记到北京大学同师生代表座谈时指出，广大青年生逢其时，也重任在肩。同时向广大青年提出了四点希望：一是要爱国，忠于祖国，忠于人民；二是要励志，立鸿鹄志，做奋斗者；三是要求真，求真学问，练真本领；四是要力行，知行合一，做实干家。我会始终以此为标准，把“勤学、修德、明辨、笃实，爱国、励志、求真、力行”这十六字箴言铭刻在心，不辜负总书记的殷切期望，让中华民族伟大复兴在我们的奋斗中梦想成真。&emsp;&emsp;习近平同青年大学生座谈时强调，广大青年一定要坚定理想信念、一定要练就过硬本领、一定要勇于创新创造、一定要矢志艰苦奋斗、一定要锤炼高尚品格。我想，总书记的这五个“一定要”，既是对我们青年大学生的殷切希望，更是一种要求。人的一生只有一次青春。现在，青春是用来奋斗的；将来，青春是用来回忆的。现如今，我们在大学校园里面临着许多机遇和挑战，也经历了许多摔打和挫折，但与此同时，我们练就了宠辱不惊的心理素质，磨砺了锐意进取的意志，无论成功还是失败，都将是青春奋斗历程中的宝贵财富。&emsp;&emsp;除此以外，青年一代在奋斗的同时不应忘记时刻提升自己的思想道德素质与法治素养，因为具备良好的思想道德素质和法治素养，是新时代大学生必须具备的基本素质。《习近平谈治国理政》的第五章着重记录了总书记在法治建设工作中的重要发言。通过这一部分我认识到，全面依法治国，是国家治理的一场深刻革命，全面依法治国的总目标就是建设中国特色社会主义法治体系、建设社会主义法治国家。作为大学生，我们应当通过理论学习和实践体验，牢固树立坚定的理想信念和正确的价值观念，陶冶高尚的道德情操，增强尊法学法守法用法的自觉性，不断提高自身的思想道德素质和法律素养。&emsp;&emsp;争做新时代新青年，还需要我们有宽广的视野，能够纵观世界风云变幻。《习近平谈治国理政》记录了多篇习总书记关于共同建设“丝绸之路经济带”和二十一世纪“海上丝绸之路”、推动构建新型大国关系、加强与发展中国家团结合作、积极参与多边事务的讲话。我认为，随着我国日益走近世界舞台中央，做一个具有国际视野的中国人自然是时代对我们的必然要求。也正因如此，我对国内外时事格外关注，能够立足中国、眼观世界，积极了解国内外资讯。在两岸问题上，我国始终有着明确的目标与坚定的决心。习近平在《告台湾同胞书》发表40周年纪念会上的讲话中提到：“祖国必须统一，也必然统一。这是70载两岸关系发展历程的历史定论，也是新时代中华民族伟大复兴的必然要求。”作为担当民族复兴大任的时代新人，我们青年大学生理应积极关切两岸局势，坚持一个中国原则，维护和平统一前景，抵制“台独”分裂活动，为祖国统一进程做出贡献。&emsp;&emsp;通过对《习近平谈治国理政》一书的研读，我深深感受到自己肩上的责任之重。我们在祖国的发展中成长，而祖国的发展，同样离不开我们青年人的努力。我们与祖国紧密联系在一起，祖国的强大让我们变得更好，而我们将是让祖国继续腾飞的助推器。在这个令人心潮澎湃的新时代，我们青年一代唯有挥洒热血、书写奋斗的篇章，才不会辜负这个伟大的时代。我将不忘初心，牢记使命，继续前行，在家庭、学校以及社会中起积极带头作用，争做担当民族复兴大任的时代新人，为实现中华民族伟大复兴中国梦而不懈奋斗。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>读后感</tag>
        <tag>习近平</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构作业——最大数]]></title>
    <url>%2F2019%2F05%2Fmaxnumber%2F</url>
    <content type="text"><![CDATA[最大数时间限制: 1000 ms内存限制: 128 MB 现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。(L &gt; 0)2、 插入操作。语法：A n功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t = 0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。限制：n是整数（可能为负数）并且在长整范围内。 注意：初始时数列是空的，没有一个数。输入格式：第一行两个整数，M和D，其中MM表示操作的个数(M ≤ 200,000)，D如上文中所述，满足(0 &lt; D &lt; 2,000,000,000)接下来的M行，每行一个字符串，描述一个具体的操作。语法如上文所述。 输出格式：对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。 输入样例:1234565 100A 96Q 1A 97Q 1Q 2 输出样例:123969396 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;struct node&#123; int val, pos;&#125; stack[200005];int cnt = 0, top = -1;void push(int val) //压栈，维护单调递减&#123; while(top &gt;= 0 &amp;&amp; stack[top].val &lt;= val) top--; stack[++top].val = val; stack[top].pos = cnt++;&#125;int query(int len) //二分查找&#123; int ans, mid, l = 0, r = top; while(l &lt;= r) &#123; mid = (l + r) / 2; if(stack[mid].pos &gt;= cnt - len) &#123; r = mid - 1; ans = stack[mid].val; &#125; else l = mid + 1; &#125; return ans;&#125;int main()&#123; int m, d, t = 0; long long val; char cmd[2]; scanf("%d%d", &amp;m, &amp;d); while(m--) &#123; scanf("%s%lld", cmd, &amp;val); if(cmd[0] == 'A') push((val + t) % d); else printf("%d\n", t = query(val)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>单调栈</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一个精巧的算法与一段感伤的话]]></title>
    <url>%2F2019%2F05%2Frecord-a-clever-algorithm-and-a-sentimental-remark%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;5月20号，中午吃饭，看见一道很有意思的题，题面很简单： &emsp;&emsp;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 这道题解法颇多，但如果要求时间复杂度为O(n)，空间复杂度为O(1)，问题就似乎变得有挑战性了。&emsp;&emsp;此题的正解非常简单也极其巧妙：将所有元素做异或运算，即a[1] ⊕ a[2] ⊕ a[3] ⊕ … ⊕ a[n]，所得的结果就是那个只出现一次的数字。&emsp;&emsp;原理很好理解：出现2次（可推广为偶数次）的元素经过按位异或后全部变为0，而出现1次（可推广为奇数次）的元素与0进行异或后会被保留。因此所有元素依次异或后得到的结果即为所求。代码如下：12345678// LeetCode No.136int singleNumber(int *nums, int numsSize)&#123; int ans = 0; for(int i = 0; i &lt; numsSize; ++i) ans ^= nums[i]; return ans;&#125; &emsp;&emsp;晚上打完球回到宿舍，看到下面这段话，有所触动，一种难以言状的思绪在心中徘徊。在此把这段话摘录下来： 年轻时你做了一个决定要把生命献给爱情 后来万箭穿心的时候你没事因为青春替你抵了命 青春死了但你还活着可你却再也不会心动了 每个人都要熬过一段付出很多却没有结果的爱情才会一夜之间突然长大 所以不要笑话一个人面无表情你只是没看到过他汹涌的内心]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>日记</tag>
        <tag>随笔</tag>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构作业——绳子与重物]]></title>
    <url>%2F2019%2F05%2Fropes-and-weights%2F</url>
    <content type="text"><![CDATA[绳子与重物时间限制: 400 ms内存限制: 64 MB 有N条绳子编号 0 至 N - 1，每条绳子后面栓了一个重物重量为Wi，绳子的最大负重为Ci。每条绳子或挂在别的绳子下或直接挂在钩子上（编号-1）。如果绳子下所有重物的重量大于绳子的最大负重就会断掉（等于不会断）。依次给出每条绳子的负重Ci、重物的重量Wi以及绳子会挂在之前的哪条绳子的下面，问最多挂多少个绳子而不会出现绳子断掉的情况。例如下图： 5, 2, -13, 3, 06, 1, -13, 1, 03, 2, 3 挂到第4个时会有绳子断掉，所以输出3。 输入格式：第1行：1个数N，表示绳子的数量(1 &lt;= N &lt;= 50000)。第2 - N+1行：每行3个数，Ci, Wi, Pi。Ci表示最大负重，Wi表示重物的重量，Pi表示挂在哪个绳子上，如果直接挂在钩子上则Pi = -1（1 &lt;= Ci &lt;= 10^9，1 &lt;= Wi &lt;= 10^9，-1 &lt;= Pi &lt;= N - 2)。 输出格式：输出1个数，最多挂到第几个绳子，不会出现绳子断掉的情况。 输入样例:12345655 2 -13 3 06 1 -13 1 03 2 3 输出样例:13 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct node&#123; int c, w, p, fa; long long sum;&#125;;struct node *a;/* 路径压缩的递归实现，大规模数据可能造成栈溢出int find(int n)&#123; if(a[n].fa != n) a[n].fa = find(a[n].fa); return a[n].fa;&#125;*/// 路径压缩的非递归实现int find(int n)&#123; int root = n, curr = n, temp; while(a[root].fa != root) root = a[root].fa; while(curr != root) &#123; temp = a[curr].fa; a[curr].fa = root; curr = temp; &#125; return root;&#125;int main()&#123; int n, ans; scanf("%d", &amp;n); a = (struct node *)malloc(sizeof(struct node) * n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;a[i].c, &amp;a[i].w, &amp;a[i].p); a[i].fa = i; a[i].sum = a[i].w; &#125; ans = n-1; for(int i = n-1; i &gt;= 0; --i) &#123; while(a[i].sum &gt; a[i].c) &#123; a[find(ans)].sum -= a[ans].w; ans--; &#125; a[a[i].p].sum += a[i].sum; if(a[i].p &gt; -1) a[i].fa = a[i].p; &#125; printf("%d", ans+1); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>路径压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[证明两种线性对数阶复杂度的表示方法等价]]></title>
    <url>%2F2019%2F05%2Fprove-the-equivalence-of-two-representations-of-complexity-of-quasilinear-time%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是离散数学中一道关于算法渐进复杂度的证明题：求证 \log_2n!\in\Theta(n\log_2n) 。&emsp;&emsp;看了网上的一些证明，大多借助斯特林公式，即 \lim\limits_{n\to+\infty}\frac{n!}{\sqrt{2\pi n}(\frac ne)^n}=1 ，将 n! 替换成同阶的 \sqrt{2\pi n}(\frac ne)^n 进行证明。若不熟悉该公式，很难想到这种等价替换。在此给出一种比较朴素的证明方法。证明分两部分：1.&emsp;先证 \log_2n!\in O(n\log_2n) \begin{aligned} &∵\ ∀n\gt0,\ \log_2n!\le \log_2n^n=n\log_2n \\ &∴\ \log_2n!\in O(n\log_2n) \end{aligned}2.&emsp;再证 \log_2n!\in \Omega(n\log_2n) \begin{aligned} &∵\ n!\ge (\frac n2)^\frac n2 \\ &∴\ \log_2n!\ge\log_2(\frac n2)^\frac n2=\frac n2\log_2\frac n2=\frac n2\log_2n-\frac n2\log_22 \\ &∵\ ∀n\gt4,\ \frac n2\log_22=\frac n4\log_24\lt\frac n4\log_2n \\ &∴\ ∀n\gt4,\ \log_2n!\ge\frac n2\log_2n-\frac n4\log_2n=\frac 14n\log_2n \\ &∴\ \log_2n!\in \Omega(n\log_2n) \end{aligned}综上所述， \log_2n!\in\Theta(n\log_2n) 。]]></content>
      <categories>
        <category>学科</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>数学</tag>
        <tag>离散数学</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构作业——游戏分组]]></title>
    <url>%2F2019%2F05%2Fgame-grouping%2F</url>
    <content type="text"><![CDATA[游戏分组时间限制: 1000 ms内存限制: 128 MB 为了活跃蒜厂的工作气氛，促进彼此间的友谊，蒜头君决定挑个阳光明媚的周末，带领同学们一起玩游戏。一共有 n 位同学要参加，编号为 0 到 n - 1。蒜头君要对这些同学进行分组，而且蒜头君已经知道哪两个同学之间是好友关系。为了让同学们都玩得开心，蒜头君决定最终的分组方案要将所有好友组合都被分在一组。蒜头君现在知道有 m 对好友关系，需要注意的是，有可能一个同学有很多个好友，也有可能一个同学没有好友。为了让游戏更有趣，蒜头君希望最后分出的组数尽可能多。你能帮蒜头君算出来最多可以分成多少组么？输入格式：第一行输入两个数 n 和 m，1 ≤ n, m ≤ 1000000。接下来输入 m 行，每行输入两个数 a 和 b，表示编号 a 和编号 b 的同学是好友关系，0 ≤ a, b ≤ n - 1。 输出格式：输出为一行，表示最多可以分成多少组。 输入样例:1235 20 22 3 输出样例:13 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int *father, *size;int find(int n)&#123; if(father[n] != n) father[n] = find(father[n]); //路径压缩 return father[n];&#125;int merge(int a, int b)&#123; int roota = find(a), rootb = find(b); if(roota == rootb) return 0; if(size[roota] &gt; size[rootb]) &#123; int temp = roota; roota = rootb; rootb = temp; &#125; father[roota] = rootb; //启发式合并（按集合大小） size[rootb] += size[roota]; return 1;&#125;void init(int n)&#123; father = (int *)malloc(sizeof(int) * n); size = (int *)malloc(sizeof(int) * n); for(int i = 0; i &lt; n; ++i) &#123; father[i] = i; size[i] = 1; &#125;&#125;int main()&#123; int n, m, a, b, num; scanf("%d%d", &amp;n, &amp;m); init(n); num = n; while(m--) &#123; scanf("%d%d", &amp;a, &amp;b); if(merge(a, b)) num--; &#125; printf("%d", num); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>路径压缩</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区域协调发展战略之我见]]></title>
    <url>%2F2019%2F05%2Fmy-view-on-regional-coordinated-development-strategy%2F</url>
    <content type="text"><![CDATA[大一下学期《形式与政策》论文 &emsp;&emsp;今年是新中国成立的第七十个年头，纵观我国七十载的发展与演化，区域发展战略自始至终都扮演着至关重要的角色。从最初的区域均衡发展战略，到区域非均衡发展战略，再到如今的区域协调发展战略，我国的区域发展战略日趋完善，逐渐形成了一套与时俱进、符合我国国情的发展格局。在此，我想分别就我国区域协调发展战略的成效与挑战两个方面简述我的理解与看法，并结合我的切身体会着重阐述我对京津冀协同发展战略的思考。&emsp;&emsp;首先，我认为区域协调发展对于我国命运可谓举足轻重。其主要原因是我国基本国情所决定的——我国幅员辽阔、人口众多，各地区条件差异显著、发展极不平衡。此外，改革开放以及工业化和市场化两次历史性社会转型使得我国各地区经济发展差距进一步拉大。如此大规模的社会变迁和特殊的国情在当今世界乃至人类历史中都绝无仅有。上世纪九十年代以来，地区差距已经严重威胁到我国经济、社会的稳定，扭转区域发展差距拉大的趋势迫在眉睫。由此来看，实行区域协调发展战略可谓关乎国家命运的明智之举。&emsp;&emsp;随着推进西部大开发，振兴东北地区等老工业基地，促进中部地区崛起，鼓励东部地区率先发展等战略的实施，我国区域协调发展已经取得积极成效。近年来，西部大开发扎实推进，经济实力稳步提升，近五年西部地区生产总值年均增8.8%。公路、铁路、机场等基础设施建设取得突破性进展，人民生活水平持续提高；东北地区等老工业基地全面振兴步伐加快，逐步缩小了与全国的发展差距，东北三省地区生产总值占全国的比重在进入新世纪后首次止跌回升；促进中部地区崛起取得重要进展，产业结构优化升级，经济结构调整成效显著，与战略实施之初相比，第一产业占比下降6.4个百分点。人才支撑能力逐年增强，普通高等学校增加近200所；东部地区继续率先发展，《长江三角洲地区区域规划》、《京津冀都市圈区域规划》等重大规划的出台使得我国区域经济发展版图进一步细化，上海浦东新区、天津滨海新区、河北雄安新区等国家级新区带动区域经济发展，国际竞争力逐年加强。&emsp;&emsp;综上所述，我国区域协调发展战略在各条战线上均取得一定成绩，逐步扭转区域发展差距拉大的趋势，形成东中西相互促进、优势互补、共同发展的新格局。然而与此同时，我国区域发展仍然面临着诸多问题与挑战。最直接的问题就是我国区域间经济社会发展差距仍然过大，而且继续扩大的总体趋势没有改变，以人均GDP为例，近两年中部、西部地区的人均GDP均不及东部地区的6成；更有甚者，在部分发展差距较大的地区，如上海市和云南省，两地的人均GDP相差3.7倍以上。这表明，我国区域发展不协调的状况仍未发生实质性的转变。除此以外，很多地区的经济发展是以牺牲环境生态为代价的，忽略了生态文明建设的重要性。由此不难看出，要想真正实现地区差距的缩小，区域发展战略的进一步调整、优化任重道远。&emsp;&emsp;作为一名北京青年，我对京津冀协同发展、设立河北雄安新区、设立北京城市副中心等重大战略的提出与实施有一定的思考。我认为，京津冀协同发展作为重大国家战略，有着光明的前景，同时也肩负着疏解北京非首都功能、调整区域经济结构和空间结构等诸多重大使命。雄安新区与北京城市副中心的建设确实能够有效地疏解北京非首都功能，着重突出北京政治中心、文化中心、国际交往中心、科技创新中心的功能定位。但我认为在这之中存在两个问题：第一是“都”与“城”的辩证关系。北京首先是一座城市，其次才是首都，因此其城市职能的优先级应高于其首都功能，疏解非首都功能必须建立在维持城市功能的前提之下，即不应影响市民的正常生活。在我看来，将北京市级行政中心迁入通州确实能够有效调整城市发展布局，对区域协调发展有着积极作用，但将医疗资源、教育资源、生产企业等基本城市元素向外迁移无疑将对民生造成影响，其合理性有待商榷；第二是“优势互补”与“单向输出”的关系。京津冀协同发展战略的初衷之一便是促进京津冀间的优势互补，然而就目前来看，所谓“互补”尚未显著体现，占据主导地位的仍是北京非首都功能向河北、天津的输出，这无疑不能将区域协调发展的优势最大化，因此我认为如何将三地的优势同时向外输出是目前亟待解决的问题。&emsp;&emsp;总览我国区域协调发展战略实施以来取得的成效与面临的挑战，可谓喜忧参半。若想真正扭转地区差距拉大的趋势，仍需进一步调整、优化区域发展总体战略，与此同时细化、完善区域协调发展机制并构建区域协调管理、监督体系。唯有兼具粗壮的树干与丰茂的树叶，区域协调发展这棵参天大树才能茁壮成长。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>形式与政策</tag>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>区域协调发展</tag>
        <tag>京津冀一体化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天，致敬青春]]></title>
    <url>%2F2019%2F05%2Ftribute-to-youth%2F</url>
    <content type="text"><![CDATA[转自 新浪微博 @人民日报 &emsp;&emsp;青春，是一场场考试，是宽大的校服，是同桌的你和上铺的兄弟；更是青春追梦，成长担当，哪怕万人阻挡，也不曾投降的勇气和力量。青春不是年华，而是心境。它属于年轻人，更属于奋斗者。每一个为梦想拼尽全力的人，都有着青春的光芒。今天，五四青年节，追梦吧，青春！ .noBr { font-size: 0px; } .myGroup { width: 70%; } .myGroup img { margin-top: 0px !important; margin-bottom: 0px !important; }]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>转载</tag>
        <tag>青春</tag>
        <tag>五四运动一百周年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客装修小记]]></title>
    <url>%2F2019%2F05%2Fblog-decoration-notes%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;五一小长假，身边的小伙伴大都奔赴各地领略大好河山，朋友圈里的各种照片看得我眼花缭乱。我赋闲在家，做自己喜欢做的事，放松之余也捯饬捯饬自己的小站。 小站概况自2016年建站以来，先后经历了多次更换托管主机（Hostinger → GitHub Pages → Coding Pages）与域名（potatochipsninja.tk → pcninja.tk → pcninja.cn），也从动态网站转型成了静态网站（WordPress → Hexo），可谓风雨飘摇、命途多舛。尽管如此，小站的建设确确实实让我学习了许多前端方面的知识，同时也带给我不小的成就感。 主要改动博客继续采用 Hexo 搭配 Next 主题，风格从原来的 Pisces 更换成了更具现代感的 Gemini，阴影的加入使得页面区块化更加显著。加入了 Valine 评论系统，支持 Markdown 语法，与原有的文章阅读量统计整合在一块，一并存储在 LeanCloud。 改动一览 字体：全局字体采用 Noto Serif SC，网站标题字体采用 ZCOOL XiaoWei，均来自 Google 字体库。为了优化访问速度，使用了 CDN（fonts.loli.net）。如果字体没有生效，请清除缓存后刷新网页 增加背景图片及背景不透明度 网站标题框及“阅读全文”按钮配色更改 侧边栏头像改为圆形，鼠标移入有旋转动画效果，点击可跳至主页 侧边栏社交链接改为仅有图标的简约风格 侧边栏加入知识共享许可协议 BY-NC-SA 声明图标，取消了文章底部的文字声明 返回页面顶部按钮由页面右下角移动到侧边栏底部，并显示阅读百分比 文章阅读量统计与 Valine 评论系统进行合并 页脚背景样式美化 页脚跳动的红色爱心（）改为静止的灰色爱心（），期待它的重新跳动 页脚总访客量与总访问量显示风格改为数值居中，图标分列两侧TODO 有精力的时候从零写一个 Hexo 主题，尝试用 PHP 等编写动态博客程序（可能会是暑假） 扩充自己的技术栈，积极更新技术类博文 丰富博客内容，多读书，多记录生活，努力提升自身文学素养]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>生活</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构作业——地铁一日游]]></title>
    <url>%2F2019%2F04%2Fone-day-metro-tour%2F</url>
    <content type="text"><![CDATA[地铁一日游时间限制: 550 ms内存限制: 64 MB 森森喜欢坐地铁。这个假期，他终于来到了传说中的地铁之城——魔都，打算好好过一把坐地铁的瘾！魔都地铁的计价规则是：起步价 2 元，出发站与到达站的最短距离（即计费距离）每 K 公里增加 1 元车费。例如取 K = 10，动安寺站离魔都绿桥站为 40 公里，则车费为 2 + 4 = 6 元。为了获得最大的满足感，森森决定用以下的方式坐地铁：在某一站上车（不妨设为地铁站 A），则对于所有车费相同的到达站，森森只会在计费距离最远的站或线路末端站点出站，然后用森森美图 App 在站点外拍一张认证照，再按同样的方式前往下一个站点。坐着坐着，森森突然好奇起来：在给定出发站的情况下（在出发时森森也会拍一张照），他的整个旅程中能够留下哪些站点的认证照？地铁是铁路运输的一种形式，指在地下运行为主的城市轨道交通系统。一般来说，地铁由若干个站点组成，并有多条不同的线路双向行驶，可类比公交车，当两条或更多条线路经过同一个站点时，可进行换乘，更换自己所乘坐的线路。举例来说，魔都 1 号线和 2 号线都经过人民广场站，则乘坐 1 号线到达人民广场时就可以换乘到 2 号线前往 2 号线的各个站点。换乘不需出站（也拍不到认证照），因此森森乘坐地铁时换乘不受限制。输入格式：输入第一行是三个正整数 N、M 和 K，表示魔都地铁有 N 个车站 (1 ≤ N ≤ 200)，M 条线路 (1 ≤ M ≤ 1500)，最短距离每超过 K 公里 (1 ≤ K ≤ 10^6)，加 1 元车费。接下来 M 行，每行由以下格式组成：&lt;站点1&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点2&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点3&gt; … &lt;站点X-1&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点X&gt;其中站点是一个 1 到 N 的编号；两个站点编号之间的距离指两个站在该线路上的距离。两站之间距离是一个不大于 10^6 的正整数。一条线路上的站点互不相同。注意：两个站之间可能有多条直接连接的线路，且距离不一定相等。再接下来有一个正整数 Q (1 ≤ Q ≤ 200)，表示森森尝试从 Q 个站点出发。最后有 Q 行，每行一个正整数 Xi，表示森森尝试从编号为 Xi 的站点出发。 输出格式：对于森森每个尝试的站点，输出一行若干个整数，表示能够到达的站点编号。站点编号从小到大排序。 输入样例:123456786 2 61 6 2 4 3 1 45 6 2 6 642345 输出样例:12341 2 4 5 61 2 3 4 5 61 2 4 5 61 2 4 5 6 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;int main(void)&#123; int n, m, k, i, j, a; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); //Init D int D[n][n]; for(i = 0; i &lt; n; ++i) for(j = 0; j &lt; n; ++j) D[i][j] = (i == j ? 0 : -1); //Get D int s1, s2, len, terminal[m*2]; char ch; for(i = 0; i &lt; m; ++i) &#123; scanf("%d", &amp;s1); s1--; terminal[i*2] = s1; ch = getchar(); while(ch != '\n') &#123; scanf("%d %d", &amp;len, &amp;s2); s2--; if(D[s1][s2] == -1 || D[s1][s2] &gt; len) &#123; D[s1][s2] = len; D[s2][s1] = D[s1][s2]; &#125; s1 = s2; ch = getchar(); &#125; terminal[i*2 + 1] = s1; &#125; //Floyd for(a = 0; a &lt; n; ++a) for(i = 0; i &lt; n; ++i) for(j = 0; j &lt; n; ++j) if(D[i][a] != -1 &amp;&amp; D[a][j] != -1) if(D[i][j] == -1 || D[i][a] + D[a][j] &lt; D[i][j]) D[i][j] = D[i][a] + D[a][j]; //Preprocess int canArr[n][n]; for(i = 0; i &lt; n; ++i) for(j = 0; j &lt; n; ++j) canArr[i][j] = 0; for(i = 0; i &lt; n; ++i) &#123; for(j = 0; j &lt; m*2; ++j) if(D[i][terminal[j]] != -1) canArr[i][terminal[j]] = 1; for(j = 0; j &lt; n; ++j) &#123; if(j != i) &#123; if(D[i][j] == -1) continue; for(a = 0; a &lt; n; ++a) if(a != i &amp;&amp; a != j) if(D[i][a] != -1 &amp;&amp; D[i][a] / k == D[i][j] / k &amp;&amp; D[i][a] &gt; D[i][j]) break; if(a == n) canArr[i][j] = 1; &#125; &#125; &#125; //Solve Problem int q, start, arr[n], queue[n], head, tail, flag; scanf("%d", &amp;q); for(i = 0; i &lt; q; ++i) &#123; for(j = 0; j &lt; n; ++j) arr[j] = 0; scanf("%d", &amp;start); arr[--start] = 1; head = 0, tail = 0; queue[0] = start; while(head &lt;= tail) &#123; for(j = 0; j &lt; n; ++j) if(!arr[j] &amp;&amp; canArr[queue[head]][j]) &#123; queue[++tail] = j; arr[j] = 1; &#125; head++; &#125; flag = 0; for(j = 0; j &lt; n; ++j) if(arr[j]) &#123; if(flag) printf(" "); else flag = 1; printf("%d", j+1); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构作业——天梯地图]]></title>
    <url>%2F2019%2F04%2Fhigh-ladder-map%2F</url>
    <content type="text"><![CDATA[天梯地图时间限制: 300 ms内存限制: 64 MB 本题要求你实现一个天梯赛专属在线地图，队员输入自己学校所在地和赛场地点后，该地图应该推荐两条路线：一条是最快到达路线；一条是最短距离的路线。题目保证对任意的查询请求，地图上都至少存在一条可达路线。输入格式：输入在第一行给出两个正整数N（2 ≤ N ≤ 500）和M，分别为地图中所有标记地点的个数和连接地点的道路条数。随后M行，每行按如下格式给出一条道路的信息：1V1 V2 one-way length time 其中V1和V2是道路的两个端点的编号（从0到N-1）；如果该道路是从V1到V2的单行线，则one-way为1，否则为0；length是道路的长度；time是通过该路所需要的时间。最后给出一对起点和终点的编号。 输出格式：首先按下列格式输出最快到达的时间T和用节点编号表示的路线：1Time = T: 起点 =&gt; 节点1 =&gt; ... =&gt; 终点 然后在下一行按下列格式输出最短距离D和用节点编号表示的路线：1Distance = D: 起点 =&gt; 节点1 =&gt; ... =&gt; 终点 如果最快到达路线不唯一，则输出几条最快路线中最短的那条，题目保证这条路线是唯一的。而如果最短距离的路线不唯一，则输出途径节点数最少的那条，题目保证这条路线是唯一的。 如果这两条路线是完全一样的，则按下列格式输出：1Time = T; Distance = D: 起点 =&gt; 节点1 =&gt; ... =&gt; 终点 输入样例1：123456789101112131415161710 150 1 0 1 18 0 0 1 14 8 1 1 15 4 0 2 35 9 1 1 40 6 0 1 17 3 1 1 28 3 1 1 22 5 0 2 22 1 1 1 11 5 0 1 31 4 0 1 19 7 1 1 33 1 0 2 56 3 1 2 15 3 输出样例1：12Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3Distance = 3: 5 =&gt; 1 =&gt; 3 输入样例2：12345678910117 90 4 1 1 11 6 1 3 12 6 1 1 12 5 1 2 23 0 0 1 13 1 1 3 13 2 1 2 14 5 0 2 26 5 1 2 13 5 输出样例2：1Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Edge&#123; int Target; int Length; int Time; struct Edge *NextEdge;&#125;;struct Vertex&#123; struct Edge *Head; int Known; int Dist; int PathDist; int Time; int PathTime; int VertexNums;&#125;;void ReadGraph(struct Vertex *G, int n, int m)&#123; int begin, target, oneWay, length, time; struct Edge *p; for(int i = 0; i &lt; n; ++i) G[i].Head = NULL; for(int i = 0; i &lt; m; ++i) &#123; scanf("%d %d %d %d %d", &amp;begin, &amp;target, &amp;oneWay, &amp;length, &amp;time); p = G[begin].Head; G[begin].Head = (struct Edge *)malloc(sizeof(struct Edge)); G[begin].Head-&gt;Target = target; G[begin].Head-&gt;Length = length; G[begin].Head-&gt;Time = time; G[begin].Head-&gt;NextEdge = p; if(!oneWay) &#123; p = G[target].Head; G[target].Head = (struct Edge *)malloc(sizeof(struct Edge)); G[target].Head-&gt;Target = begin; G[target].Head-&gt;Length = length; G[target].Head-&gt;Time = time; G[target].Head-&gt;NextEdge = p; &#125; &#125;&#125;void Dijkstra(struct Vertex *G, int n, int begin)&#123; int v, vDist, vTime, vNums; for(int i = 0; i &lt; n; ++i) &#123; G[i].Known = 0; G[i].Dist = G[i].Time = G[i].PathDist = G[i].PathTime = G[i].VertexNums = -1; &#125; G[begin].Dist = G[begin].Time = G[begin].VertexNums = 0; while(1) &#123; v = vTime = -1; for(int i = 0; i &lt; n; ++i) if(!G[i].Known &amp;&amp; G[i].Time != -1) &#123; if(v == -1 || G[i].Time &lt; vTime) &#123; vTime = G[i].Time; vDist = G[i].Dist; v = i; &#125; else if(G[i].Time == vTime &amp;&amp; G[i].Dist &lt; vDist) &#123; vDist = G[i].Dist; v = i; &#125; &#125; if(v == -1) break; G[v].Known = 1; for(struct Edge *p = G[v].Head; p; p = p-&gt;NextEdge) &#123; if(!G[p-&gt;Target].Known) &#123; if(G[p-&gt;Target].Time == -1 || G[v].Time + p-&gt;Time &lt; G[p-&gt;Target].Time) &#123; G[p-&gt;Target].Time = G[v].Time + p-&gt;Time; G[p-&gt;Target].Dist = G[v].Dist + p-&gt;Length; G[p-&gt;Target].PathTime = v; &#125; else if((G[v].Time + p-&gt;Time == G[p-&gt;Target].Time) &amp;&amp; (G[v].Dist + p-&gt;Length &lt; G[p-&gt;Target].Dist)) &#123; G[p-&gt;Target].Dist = G[v].Dist + p-&gt;Length; G[p-&gt;Target].PathTime = v; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i) &#123; G[i].Known = 0; G[i].Dist = -1; &#125; G[begin].Dist = 0; while(1) &#123; v = vDist = -1; for(int i = 0; i &lt; n; ++i) if(!G[i].Known &amp;&amp; G[i].Dist != -1) &#123; if(v == -1 || G[i].Dist &lt; vDist) &#123; vDist = G[i].Dist; vNums = G[i].VertexNums; v = i; &#125; else if(G[i].Dist == vDist &amp;&amp; G[i].VertexNums &lt; vNums) &#123; vNums = G[i].VertexNums; v = i; &#125; &#125; if(v == -1) break; G[v].Known = 1; for(struct Edge *p = G[v].Head; p; p = p-&gt;NextEdge) &#123; if(!G[p-&gt;Target].Known) &#123; if(G[p-&gt;Target].Dist == -1 || G[v].Dist + p-&gt;Length &lt; G[p-&gt;Target].Dist) &#123; G[p-&gt;Target].Dist = G[v].Dist + p-&gt;Length; G[p-&gt;Target].VertexNums = G[v].VertexNums + 1; G[p-&gt;Target].PathDist = v; &#125; else if((G[v].Dist + p-&gt;Length == G[p-&gt;Target].Dist) &amp;&amp; (G[v].VertexNums + 1 &lt; G[p-&gt;Target].VertexNums)) &#123; G[p-&gt;Target].VertexNums = G[v].VertexNums + 1; G[p-&gt;Target].PathDist = v; &#125; &#125; &#125; &#125;&#125;void PrintPath(struct Vertex *G, int end, int type)&#123; if(type) &#123; if(G[end].PathDist != -1) &#123; PrintPath(G, G[end].PathDist, 1); printf(" =&gt; %d", end); &#125; &#125; else &#123; if(G[end].PathTime != -1) &#123; PrintPath(G, G[end].PathTime, 0); printf(" =&gt; %d", end); &#125; &#125;&#125;void Output(struct Vertex *G, int begin, int end)&#123; int i = end; while(i != begin) &#123; if(G[i].PathDist != G[i].PathTime) break; i = G[i].PathDist; &#125; if(i == begin) &#123; printf("Time = %d; Distance = %d: %d", G[end].Time, G[end].Dist, begin); PrintPath(G, end, 0); &#125; else &#123; printf("Time = %d: %d", G[end].Time, begin); PrintPath(G, end, 0); printf("\nDistance = %d: %d", G[end].Dist, begin); PrintPath(G, end, 1); &#125;&#125;int main(void)&#123; int n, m, begin, end; scanf("%d %d", &amp;n, &amp;m); struct Vertex G[n]; ReadGraph(G, n, m); scanf("%d %d", &amp;begin, &amp;end); Dijkstra(G, n, begin); Output(G, begin, end); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>作业</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有点小累]]></title>
    <url>%2F2019%2F04%2Fi-am-tired%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;距离上次更新博客已经过去足足五个月了，尽管时常想起自己还有这么个博客，但总会因为种种原因而被搁置。难得今天有兴致记录一下生活，就大概写写这小半年发生的大小事吧。&emsp;&emsp;一九年初，正当人们沉浸在新年来临的喜悦之际，我遭受到了迄今为止最大的挫折——我丢了我最重要的东西，这是无疑是一次难以承受的挫折。巨大的冲击让我陷入恍惚与错乱，我想用万念俱灰来形容那时的我再合适不过了。就这样，我陷入了无尽的回忆之中，神魂颠倒地挨过了这个寒冬。&emsp;&emsp;大概历经两个多月，我才渐渐恢复意识，开始重新认识自己、认识世界、认识眼前的一草一木。我意识到不应再踯躅，也不需要不停地回忆。我们只要在恰当的时候，回首眺望似水年华，这便是回忆的全部作用。为了最初的理想，也为了另外一个更重要的原因，我踏上了新的征程。&emsp;&emsp;新学期，新的班级，新的同学，一切都不再熟悉。但是没时间让我熟悉这些，因为学业上的压力明显要高过以往。迫不得已，我把更多的时间分给课业。尽管跟别的同学比，我玩的时间绝对算是最多的之一，但是要知道在中学时期我从来没有花过这么多时间在学习上，所以无论是身体还是精神都需要适应适应。我发现，在实验班，需要的不仅是智力，还需要有足够的精力来处理各种报告、集会、比赛以及各种各样的琐事。今天之所以写博客来小小地抱怨一下就是因为光一个电子电路实验报告就占去了我溜溜三个多小时，这让我不太能接受。 &emsp;&emsp;但我其实并不是想抱怨什么，只是我有点累了。我相信，此时此刻，把自己的疲倦写下来，就是最好的缓解。&emsp;&emsp;明天，太阳照常升起，我知道那时我会充好能量，开始新的一天。所以现在，就让我结束这篇语无伦次的博文，然后，睡个好觉。&emsp;&emsp;祝我晚安，也祝你晚安。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>日记</tag>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穷则变，变则通，通则久]]></title>
    <url>%2F2018%2F11%2F40-years-of-reform-and-opening-up%2F</url>
    <content type="text"><![CDATA[大一上学期《形式与政策》论文 &emsp;&emsp;八十年前，鲁迅先生在回顾历史时曾说道：“中国太难改变了，即使搬动一张桌子，改装一个火炉，几乎也要血。”诚然，中华几千年沉重的历史文化积淀决定了变革的困难。尽管如此，在我国的历史长河中也不乏王安石、康有为这样的改革先锋，他们用实践找寻着国家通达长久的发展之道。&emsp;&emsp;四十年前，小岗村的血雨腥风拉开了新中国全面改革的序幕；十一届三中全会上，邓小平“解放思想、开动脑筋、实事求是”的思想方针为改革开放大潮开辟了道路。我不禁要问：为什么要变？我想答案是显而易见的：因穷而变。改革开放前，我国国民经济衰弱，物质资源匮乏，人民生活条件差。穷苦的生活让人们迎难而上、主动思变，富强的迫切愿望给予了小岗村村民第一个吃螃蟹的勇气。&emsp;&emsp;我认为，我国改革开放对当代中国命运的影响主要体现在政治、经济、文化三个方面。首先，政治体制改革使我国进一步发展民主，加强法制，精简机构，完善了民主监督制度，为经济的腾飞奠定了坚实的基础。20世纪70年代末期，受“文化大革命”影响，把矛头指向我国社会主义制度的舆论逐渐升温，而1978年至1979年间出现的西单民主墙可谓是新中国民主运动的开端。叶剑英元帅在1978年12月说过一段话：“党的十一届三中全会是党内民主的典范，西单民主墙是人民民主的典范。”改革开放使得政治民主化的潮流不仅有自下而上的推动，也有了自上而下的顺应，我认为这是改革开放对当代中国政治体制改革做出的最卓著的贡献。&emsp;&emsp;改革开放对我国经济的促进作用更是不言而喻。十一届三中全会以来，国民经济进入调整时期，我国先后建立了深圳、海南等经济特区，将农村家庭联产承包责任制在全国范围内推广，让人民的生活水平有了质的飞跃，14个港口城市的开放更是让我国经济与世界经济对接。以加入WTO为标志，中国经济已经完成市场化和国际化进程，融入世界经济体系和经济全球化浪潮之中，得到了国际社会越来越广泛的认可。近年“丝绸之路经济带”和“21世纪海上丝绸之路”的建设也让全球更多的目光投向这古老而又焕发生机的世界第二大经济体——中国。&emsp;&emsp;不仅如此，文艺界也参与到了这场改革当中来。有人说，李谷一是内地的邓丽君，我认为，如果中国的改革开放再早几年，那么邓丽君就会是台湾的李谷一。1979年《三峡传说》的一首插曲引起了不小的风波，它便是李谷一演唱的《乡恋》。《乡恋》的意义并不仅限于一首歌曲，它更像是扔向一潭死水的一颗石子，激起了千层涟漪。歌词的“缠绵悱恻”与李谷一的“轻声唱法”一改此前革命歌曲的时代特点，引发了文艺领域的论战。李谷一曾因这首“黄色歌曲”、“靡靡之音”遭受非议、中伤和抵制。终于在1983年中央电视台第一届春节联欢晚会上，总导演黄一鹤和时任广电部部长吴冷西顶着巨大的压力接受了观众们山呼海啸般的点播，让这首“禁歌”登台，同时也为李谷一正了名。自此以后，我国多样共融、多态共生的社会文化逐渐形成，人民的精神生活也得到了极大的丰富与满足。因此，改革开放也是决定当代中国文化命运的关键一招。&emsp;&emsp;40年来，我国改革开放事业取得了巨大成就，无论对政治、经济还是文化，都有着许多积极的作用，为实现中华民族伟大复兴的中国梦奠定了基础，可见改革开放是决定当代中国命运的关键一招。但与此同时也存在着缺乏顶层设计等诸多问题，因此改革的脚步时刻不能停歇，党的十八届三中全会提出了全面深化改革的指导思想与目标任务，唯有将改革进行到底，我们才能继续强有力地发展，让中国始终屹立在世界民族之林。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>改革开放</tag>
        <tag>形式与政策</tag>
        <tag>大学</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[申请Let's Encrypt免费SSL证书并在Node.js建立HTTPS服务]]></title>
    <url>%2F2018%2F11%2Fletsencrypt-certificates-and-https-in-nodejs%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;为了更安全地传输，我们往往需要建立HTTPS连接。我们可以利用OpenSSL创建自签名的证书，但创建自己的CA机构并不安全也不被各大浏览器承认。目前有不少免费SSL证书提供商，其中最流行的便是Let’s Encrypt（官网），下面是关于如何申请Let’s Encrypt免费SSL证书并用Node.js建立一个HTTPS服务器。 申请Let’s Encrypt免费SSL证书Let’s Encrypt官方推荐使用Certbot ACME客户端。它可以自动执行证书颁发和安装，无需停机且易于使用。 首先安装certbot通过SSH连接到你的VPS或云服务器，确保已经安装了Python及Git。本文以CentOS为例，其他发行版大同小异。 1$ sudo yum install certbot 获取证书首先停止你服务器上的服务，保证80端口没有被占用并且你的域名被正确解析到你的服务器，否则在证书获取过程中会出现错误。 1$ sudo certbot certonly --standalone -d diunar.tk -d www.diunar.tk #把diunar.tk换成你的域名 当看到“Congratulations”字样时，代表你已经成功申请到Let’s Encrypt的免费SSL证书，证书有效期是90天，后面会讲如何&nbsp;续命&nbsp;延期。证书文件被保存到了/etc/letsencrypt/live/你的域名/，其中的fullchain.pem和privkey.pem是我们接下来需要用到的完整证书链及私钥 如果你希望在Nginx或Apache等Web服务器上应用你的SSL请在Certbot的官网上查看方法。下面我们用Node.js编写服务器建立HTTPS服务 通过Node.js建立HTTPS服务 为了方便，我们使用Express框架，因此需要安装Express： 1$ npm install express 创建index.js： 1234567891011121314151617181920212223242526const express = require('express')const fs = require('fs')const http = require('http')const https = require('https')const app = express()const port = 80 //HTTP访问端口号，默认80，可更改为你希望的端口号const SSLport = 443 //HTTPS访问端口号，默认443，可更改为你希望的端口号const options = &#123; key: fs.readFileSync('/etc/letsencrypt/live/diunar.tk/privkey.pem'), //异步读取私钥文件 cert: fs.readFileSync('/etc/letsencrypt/live/diunar.tk/fullchain.pem'), //异步读取证书文件 requestCert: false, //是否请求客户端证书 rejectUnauthorized: false //是否拒绝无信任CA颁发的证书的客户端连接请求&#125;http.createServer(app).listen(port, () =&gt; console.log(`HTTP server is listening on port $&#123;port&#125;`)) //创建http服务监听https.createServer(options, app).listen(SSLport, () =&gt; console.log(`HTTPS server is listening on port $&#123;SSLport&#125;`)) //创建https服务监听app.get('/', function(req, res) &#123; if (req.protocol == 'https') &#123; res.send("This is HTTPS Server") &#125; else &#123; res.send("This is HTTP Server") &#125;&#125;) 如果不需要HTTP服务可以删除http.createServer(app)，只保留HTTPS服务 运行Node.js服务123$ node index.jsHTTP server is listening on port 80HTTPS server is listening on port 443 在浏览器分别通过http://和https://协议访问你的域名，看看有什么区别： 通过浏览器可以看到我们与服务器建立的是密文传输连接： 大功告成之后，别忘了每隔90天通过certbot renew命令进行证书的续订。你也可以设置自动续订，具体方法请见Certbot官网。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>网络</tag>
        <tag>SSL</tag>
        <tag>HTTPS</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDB后端与微信小程序前端建构最小端到端系统]]></title>
    <url>%2F2018%2F10%2Fminimum-end-to-end-system%2F</url>
    <content type="text"><![CDATA[服务端搭建 一、环境准备1.操作系统与网络本文以Arch Linux为例，在VirtualBox虚拟机下运行，通过SSH与宿主机连接。由于虚拟机通过NAT联网，要想访问在虚拟机中部署的Web服务需要进行端口转发： 打开VirtualBox管理器，进入Arch虚拟机的设置页，在网络选项卡中点击高级 点击端口转发，我们新建一个端口转发规则。协议为TCP；主机IP填写VirtualBox虚拟网卡的地址，在Windows宿主机通过ipconfig命令可查看，默认为192.168.56.1；子系统IP填写虚拟机IPv4地址，在Arch虚拟机中通过ip addr命令可查看（图中红框所示处）；子系统端口为我们即将部署的Node服务的监听端口；主机端口为转发到主机后的端口，我们应该避开常用或已被占用的端口（如21、22、25、80、443），为了方便我们可以转发到原端口，本文以3000端口为例 这样设置完毕后虚拟机的3000端口就可以通过192.168.56.1:3000访问了 2.Node.js由于该虚拟机此前已安装Node.js、MongoDB等，首先将其卸载再做演示：1$ pacman -Rsc nodejs mongodb #删除Node.js、MongoDB和所有依赖这两个软件包的程序 更多关于pacman（Arch官方软件包管理器）的用法请见这里通过pacman安装Node.js：1$ pacman -S nodejs npm #安装node及包管理器npm 或者从Node.js官网下载二进制文件：123$ wget https://nodejs.org/dist/v8.12.0/node-v8.12.0-linux-x64.tar.xz$ xz -d node-v8.12.0-linux-x64.tar.xz$ tar -xvf node-v8.12.0-linux-x64.tar 3.MongoDB 方法一： 123$ pacman -S mongodb #从官方软件仓库安装mongodb$ systemctl start mongodb.service #启动mongodb服务$ systemctl enable mongodb.service #设置开机启动服务 Arch Linux的默认dbpath是/var/lib/mongodb/，启动服务后可以通过mongo命令进入Mongo Shell 方法二： 123$ cd /home$ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.2.tgz #从官网下载二进制包$ tar -xzvf mongodb-linux-x86_64-4.0.2.tgz 为了快速使用mongodb命令，可以配置环境变量。编辑~/.profile或/etc/profile文件，将mongodb/bin路径加入即可：1$ sudo vim /etc/profile 在文件末尾添加一行：1export PATH=$PATH:/home/mongodb-linux-x86_64-4.0.2/bin 保存修改后，在终端运行以下命令使环境变量生效：1$ source /etc/profile 启动mongod：12$ mkdir /data/db #创建数据存放目录$ mongod --dbpath /data/db 此时mongod已经启动，我们可以在另一终端中通过mongo命令进入交互程序 二、部署服务1.建立应用并安装依赖首先建立一个工作目录：12$ mkdir wx$ cd wx 通过npm init初始化一个应用，此时会要求你输入应用的名称、版本、入口文件等信息，可以按Enter键选择默认值，最终npm会为你生成一个package.json文件1$ npm init 下面通过Node包管理器安装Express、Mongoose：1$ npm install express mongoose --save 安装成功后会出现+ express、+ mongoose等字样，这两个包及其所需依赖都被安装在/node_modules中并被写入package.json： 除了上述方法，我们也可以通过全局安装来达到一劳永逸的目的：1$ npm install express mongoose -g 2.建立HWMongo模块编辑hwmongo.js：1vim hwMongo.js 将数据库连接与定义Schema部分写进hwMongo.js，以便后续调用：1234567891011//hwmongo.jsvar mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test'); //与数据库建立连接var helloWorldSchema = mongoose.Schema(&#123; country: String, helloWorld: String,&#125;); //定义数据架构helloWorldSchemavar HWMongo = mongoose.model('HWs', helloWorldSchema);module.exports = HWMongo; //导出HWMongo 3.初始化数据编辑initData.js：1vim initData.js 将初始数据插入文档：1234567891011121314151617181920212223242526var HWMongo = require('./hwMongo');new HWMongo(&#123; country: 'China', helloWorld: '你好，世界!'&#125;).save();new HWMongo(&#123; country: 'US', helloWorld: 'Hello World!'&#125;).save();new HWMongo(&#123; country: 'Danmark', helloWorld: 'Hallo, Verden!'&#125;).save();new HWMongo(&#123; country: 'Germany', helloWorld: 'Hallo, Welt!'&#125;).save();new HWMongo(&#123; country: 'France', helloWorld: 'Bonjour, tout le monde'&#125;).save(); 运行程序：1node initData.js 如果出现“当前URL解析器被弃用”的警告，我们可以修改hwMongo.js的数据库连接部分（第3行），使用新的解析器：1mongoose.connect('mongodb://localhost/test', &#123;useNewUrlParser: true&#125;); //Line 3 数据初始化完成之后我们可以通过mongo进入Mongo Shell，在交互程序中通过use wx切换至数据库“wx”，通过show collections可以列出数据库中的全部集合，通过db.hws.find()可以进行查询：12345678910&gt; use wxswitched to db wx&gt; show collectionshws&gt; db.hws.find()&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b72&quot;), &quot;country&quot; : &quot;US&quot;, &quot;helloWorld&quot; : &quot;Hello World!&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b73&quot;), &quot;country&quot; : &quot;Danmark&quot;, &quot;helloWorld&quot; : &quot;Hallo, Verden!&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b74&quot;), &quot;country&quot; : &quot;Germany&quot;, &quot;helloWorld&quot; : &quot;Hallo, Welt!&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b75&quot;), &quot;country&quot; : &quot;France&quot;, &quot;helloWorld&quot; : &quot;Bonjour, tout le monde&quot;, &quot;__v&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bb597c822106c03e8e75b71&quot;), &quot;country&quot; : &quot;China&quot;, &quot;helloWorld&quot; : &quot;你好，世界!&quot;, &quot;__v&quot; : 0 &#125; 4.建立HTTP服务器编辑入口文件index.js：1vim index.js 在index.js中编写简易HTTP服务器与查询服务：12345678910111213141516171819202122const express = require('express');const HWMongo = require('./hwMongo.js'); //调用模块const app = express();const port = 3000; //http服务器端口号app.get('/country', function(req,res) &#123; HWMongo.findOne(&#123;'country': req.query.country&#125;, function(err, doc) &#123; if (err) &#123; console.log("数据库出错"); &#125; else if (doc==null) &#123; res.send("输入信息有误，请重试"); console.log(req.query.country + ":" + doc); &#125; else &#123; res.send(doc.helloWorld); //应答报文 console.log(req.query.country + ":" +doc.helloWorld); &#125; &#125;);&#125;);app.listen(port, function() &#123; console.log('Server is running at http://localhost:3000/.');&#125;); HTTP服务器跑起来后宿主机所在局域网内的设备可以通过http://192.168.56.1:3000来访问：1node index.js 至此，服务端已搭建完成 前端小程序实现 一、开发工具在这里下载并安装微信web开发者工具 二、项目与项目配置文件新建一个空白项目，编辑项目配置文件project.config.json，为了调试方便，我们将urlCheck一项改为false:12345678&#123; ... "setting": &#123; "urlCheck": false, ... &#125;, ...&#125; 更多关于项目配置文件的描述请见这里 三、文件结构从微信小程序官方文档中我们可以知道小程序的文件组成结构，具体内容如下 小程序主体部分（项目根目录下）： 文件 必需 作用 app.js 是 小程序逻辑 app.json 是 小程序公共配置 app.wxss 否 小程序公共样式表 小程序页面： 文件类型 必需 作用 js 是 页面逻辑 wxml 是 页面结构 json 否 页面配置 wxss 否 页面样式表 因此我们在项目目录中新建app.js和app.json，并编辑app.json： 12345&#123; "pages": [ "pages/index/index" ]&#125; 此时开发工具会自动建立pages/index目录及其页面组成文件，至此只包含一个页面的最小项目的框架搭建完成，其文件结构如下：12345678.├── app.js├── app.json├── pages│ └── index│ ├── index.js│ └── index.wxml└── project.config.json 四、页面逻辑及生命周期每个页面的JS文件中通过Page(Object)函数来注册页面，它接受一个对象类型参数，指定页面的初始数据、生命周期回调、事件处理函数等。我在此列举几个主要、常用的对象参数（详见这里）： 属性 类型 说明 data 对象 页面第一次渲染使用的初始数据，JSON类型 onLoad 函数 页面加载时触发，一个页面只会调用一次 onShow 函数 页面显示/切入前台时触发 onReady 函数 页面初次渲染完成时触发，一个页面只会调用一次 onHide 函数 页面隐藏/切入后台时触发 其他 任意 开发者添加任意函数或数据 其中所有函数类型的参数均为生命周期回调函数我们编辑pages/index的页面逻辑文件index.js： 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //页面的初始数据 data: &#123; hidden: true, data_from_mongodb: "" &#125;, //开发者自定义函数 query: function() &#123; var index = Math.floor(Math.random() * 5) //产生0-4的随机数 var wxcountry = "" if (index == 0) &#123; wxcountry = "China" &#125; else if (index == 1) &#123; wxcountry = "US" &#125; else if (index == 2) &#123; wxcountry = "Danmark" &#125; else if (index == 3) &#123; wxcountry = "Germany" &#125; else if (index == 4) &#123; wxcountry = "France" &#125; var that = this wx.request(&#123; url: "http://192.168.56.1:3000/country", data: &#123; country: wxcountry &#125;, success: function(res) &#123; that.setData(&#123; hidden: false, data_from_mongodb: wxcountry + " : " + res.data &#125;) &#125;, &#125;) //从后端请求数据 &#125;,&#125;) 由于微信小程序支持ECMAScript 6（ES6）标准，因此JS代码可以省略语句末的分号;，并且微信官方所有示例程序均采用省略，因此我们也应该遵循微信小程序的编码规范，语句末省略分号; 五、编译与运行点击开发者工具工具栏中的编译按钮，即可在左侧的模拟器中看到运行效果： 至此，前端部分建构完成 将服务部署至VPS/云服务器 我们可以把我们建构好的服务部署至服务器以实现公网访问，我将该Node+Express+MongoDB组成的服务端部署在Vultr的VPS上（新加坡机房，用来搭梯子的），由于操作系统是CentOS，在部署过程中部分操作略有不同，在此不再赘述。部署后将微信小程序中pages/index/index.js的查询函数中的URL修改为VPS/云服务器的公网IP:端口号，实现了全网访问服务： 至此，最小端到端系统实验完成 总结 本实验使我巩固了Node.js、MongoDB、Linux运维、网络原理等多方面知识，并对微信小程序的开发有了一定了解，增强了我对新事物的探索能力。我将在继续深入钻研既学技术的同时努力接触新技术，让自己的技术栈更加充实]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
        <tag>网络</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JavaScript实现网页自动刷新]]></title>
    <url>%2F2018%2F10%2Fweb-page-auto-refresh-by-JavaScript%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多时候我们需要让网页不断刷新来达到持续监视或刷访问次数等目的，我们可以通过简单的JS脚本来实现网页自动刷新的操作。123456789101112131415161718var timeout = prompt("设置刷新时间间隔[S]");var current = location.href;function reload() &#123; setTimeout('reload()', 1000 * timeout); var myFrame = "&lt;frameset cols=\'*\'&gt;&lt;frame src=\'" + current + "\' /&gt;&lt;/frameset&gt;"; with (document) &#123; write(myFrame); void(close()); &#125;&#125;if (timeout &gt; 0) &#123; setTimeout('reload()', 1000 * timeout);&#125; else &#123; location.replace(current);&#125; 我们可以打开浏览器提供的开发者工具（如Chrome为F12），进入控制台，复制以上代码来实现功能。为了更加简化操作步骤，我们可以将以下压缩后的JS代码保存至书签栏/收藏夹（Ctrl+D），这样即可快速调用：1javascript:&#123;function reload()&#123;setTimeout('reload()',1000*timeout);var myFrame="&lt;frameset cols='*'&gt;&lt;frame src='"+current+"' /&gt;&lt;/frameset&gt;";with(document)&#123;write(myFrame);void(close())&#125;&#125;var timeout=prompt("设置刷新时间间隔(s)");var current=location.href;if(timeout&gt;0)&#123;setTimeout('reload()',1000*timeout)&#125;else&#123;location.replace(current)&#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C/C++中主函数的声明及返回值问题]]></title>
    <url>%2F2018%2F09%2Fabout-main-function-declaration-and-returned-value%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在C/C++程序中有时会见到采用诸如void main()等方式来声明主函数，很多人在主函数返回值的问题上也略显随意。经过查阅多版本的C、C++标准文档与相关书籍，我将我的结论与认识总结于此。不可避免地，其中可能包含我错误的认识，欢迎大家指正。 main()函数的函数类型关于main()的原型，C89/99/11以及C++98/03/11/14等标准给出的说法略有出入，尤其在早期标准中差异更为显著。然而，共同的，在任何一个版本的标准中，均未承认void main()这种声明方式。首先可以得出结论：void main()为错误写法，所有编译器都没有理由支持该种写法。 在K&amp;R C与C89里，若函数没有显式声明返回类型，则默认是int，因此在早期C程序中经常出现这样的主函数：12345main()&#123; // 函数体 return 0;&#125; 这种写法在早期标准中是被认可的，main()等价于int main()。但是，C99标准不再支持函数的int类型的默认设置，因此该写法被废止，新的编译器不再允许此类main函数。 在C99/11标准中，明确定义了对于标准的main函数的两个原型：12int main(void) &#123; /* ... */ &#125;int main(int argc, char *argv[]) &#123; /* ... */ &#125; 为了增强说服力，我在《C Primer Plus》（第六版）（该书以1999 ISO/ANSI作为标准）中找到了这样一段话： &emsp;&emsp;如果浏览老版本的C代码，您将发现程序常常以：main()这种形式开始。C90标准勉强允许这种形式，但是C99标准不允许。因此即使您当前的编译器允许，也不要这么做。&emsp;&emsp;您还将看到另一种形式：void main()&emsp;&emsp;有些编译器允许这种形式，但是还没有任何标准考虑接受它。因而，编译器不必接受这种形式，并且许多编译器也不这样做。再者说，如果坚持使用标准形式，那么当您把程序从一个编译器移到另一个编译器时也不会有问题。 main()函数的形式参数此部分C与C++略有差异 C int main()和int main(void)在C语言中是有区别的：123int main() &#123; /* ... */ &#125;// 不等价于int main(void) &#123; /* ... */ &#125; 在C语言中参数列表为空(即不提供参数列表也不为void)，表示不提供参数数量和参数类型信息：1234567891011#include &lt;stdio.h&gt;void func() // 参数列表为空不代表不接受参数&#123; print("Hello, world\n");&#125;int main(void)&#123; func(1,2,3,4); // 调用func()，并传递了参数 return 0;&#125; 因此在C中，main函数的参数部分应该以以下两种方式描述：12int main(void) &#123; /* ... */ &#125;int main(int argc, char *argv[]) &#123; /* ... */ &#125; 不应该写：1int main() &#123; /* ... */ &#125; C++ 由于C和C++中对于函数参数列表的规则并不一致(C++中参数列表为空代表不接收任何参数)。所以C++中main的原型和ISO C也并不太一样。在C++中，下面两种写法是完全等价的。123int main() &#123; /* ... */ &#125;// 等价于int main(void) &#123; /* ... */ &#125; 以上两种形式均符合标准。 main()函数的返回值上文指出，main()应以int类型定义，故需要返回一个int类型的返回值到操作系统。在早期标准中，主函数中的return 0;是可以省略的，main()最后如果没有返回值，则会自动return 0;，但是记住，只有main函数是这样，其他函数不能省略return。自C99/C++98以来，主函数的返回值为强制，若漏掉了返回语句，大多数编译器会给出警告，但仍将编译程序。 return 0;：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数 return -1;：一般用在子函数结尾，按照程序开发的一般惯例，表示该函数失败 main()必须要有返回值的原因是：在C和C++中使用return-statement都是将return的值作为参数来调用exit/std::exit来终止程序。此外，返回值对于某些操作系统（包括DOS和UNIX）而言，具有实际的用途。以Windows为例，编译以下程序：12345/* test.c */int main(void)&#123; return 0;&#125; 在命令提示符下运行命令test &amp;&amp; dir，得到以下结果：123456789101112D:\code&gt;test &amp;&amp; dir D:\code 的目录2018/09/26 10:31 &lt;DIR&gt; .2018/09/26 10:31 &lt;DIR&gt; ..2018/09/26 10:29 35 test.c2018/09/26 10:30 41,664 test.exe 2 个文件 41,699 字节 2 个目录 605,409,882,112 可用字节D:\code&gt; test.exe正常结束后执行dir指令，输出了目录列表。若将第4行返回值由0改为-1:1return -1; 再次执行test &amp;&amp; dir命令：123D:\code&gt;test &amp;&amp; dirD:\code&gt; test.exe将-1返回给了操作系统，即程序异常结束，因此windows没有继续执行dir打印目录列表。总结一下，正常情况下main函数应以return 0;结束，不能随意更改返回值。 结语综上所述，一般情况下，C/C++程序的主函数都应该以如下方法编写：12345int main(void) // void在C++中可省，C不建议省&#123; // 函数体 return 0;&#125; 即使其他不标准的声明方法也许不会影响程序的正常编译、运行，但为了程序的可移植性与易维护性，我们应该养成良好的编码习惯，利人利己。 参考文献[1] Stephen Prata 编著，《C Primer Plus》，人民邮电出版社，2005年，§2.2 §9.2 §B.5.[2] Andrew Koenig 编著，《C陷阱与缺陷》，人民邮电出版社，2008年，§2.1 §7.1.[3] Stephen Prata 编著，《C++ Primer Plus》，人民邮电出版社，2012年，§2.1 §2.4.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训小结]]></title>
    <url>%2F2018%2F09%2Fsummary-of-military-training%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2018年9月2日，我与全新结识的同学们踏上了前往北京八达岭军训基地的汽车。天蒙蒙亮，我怀着既紧张又期待的心情开始了为期14天的军事训练。&emsp;&emsp;在军训过程中，我感受到了军旅生活的艰辛与严谨。生活中，同学们在承训教官的悉心指导与监督下坚持每天认真整理内务，培养了雷厉风行的优良作风。同学们士气高涨，“将士们，听党指挥，能打胜仗，作风优良”的歌声时常响彻整个基地；训练中，同学们挥汗如雨，在飞沙走石的训练场上留下了自己坚持的痕迹。教官们的严格要求使我们进一步深化了听从指挥、令行禁止的意识。&emsp;&emsp;此外，穿插在军训期间的演讲比赛、拔河比赛、合唱比赛等文体活动更是为同学们提供了展示自我、结识朋友的机会。同学们在竞争中学会团结、学会合作、学会理解，为今后的学习生活打下了坚实的基础。&emsp;&emsp;9月15日，伴随着《分列式进行曲》，我昂首走过检阅台，展示了刻苦训练的成果。这同时也标志着短暂的军训时光渐渐走向尾声。&emsp;&emsp;通过这次军训，我受益匪浅。我意识到了优良的作风、强健的体魄、坚强的意志是个人与团队进步的先决条件，我将把军训中养成的优良习惯延续到今后的学习生活中。军训不仅提升了我的国防意识，更让我深刻认识到和平的来之不易。铭记历史，缅怀先烈，珍爱和平，开创未来。我将牢牢记住并践行这十六个字，让祖国强大，让世界和平！]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生何其苦]]></title>
    <url>%2F2018%2F08%2Fthe-bitter-life%2F</url>
    <content type="text"><![CDATA[微博上看到的一段话，若有所思，也许若干年后再回首看到此文会别有一番感悟，故转载于此。 25岁，你找到了一份“高薪”工作爸妈开心，同学羡慕你对工作充满热情，全部心思扑在工作上 35岁你因为身体越来越差加班越来越少晋升的速度也越来越缓慢收入原地踏步，生活压力却越来越大 那天下班，媳妇告诉你孩子要上幼儿园了双语的一个月3000你皱了皱眉头，那边就已经不耐烦了“四单元的老王家孩子，一个月6000”“你已经这样了，你想让孩子也输？”你没说话，回屋绐媳妇转了6000块钱这笔钱，你原本打算绐自己过个生日，买个新电脑 38岁，孩子上了一年级老师说一年级最关键，打好基础很重要你笑着说，是是是，老师您多照顾 新生接待的老师看着你不明事理的脸给你指了一条明路“课外辅导班，一个月2200” 40岁的时候，孩子上了三年级老师说，三年级，最关键，承上启下很重要你笑着说：是是是，正打算再报个补习班 44岁，孩子上了初中有一天回到家，她对你说爸爸，我想学钢琴你没什么犹豫的你以为这些年，你已经习惯了 那句“爸爸现在买不起”你始终说不出口好在孩子比较懂事她说：爸爸没事，要不我先学陶笛也可以你看着这么懂事的孩子，却开心不起来 46岁，孩子上了一个不好不差的高中有一天你在开会，接到了老师的电话电话里说你的孩子在学校打架了叫你去一趟你唯唯诺诺的和那个比你还小5岁的领导请了个假 到学校又被老师训了一通无非台词就是那一句你们做家长的就知道工作，能不能陪陪孩子 你看着这个老师，有点可笑好像当时说：家长在外辛苦点多赚点钱让孩子多补补课的和他不是一个人 50岁，孩子上了大学很争气，是一个一本他学的专业你有点看不懂你只知道工作不一定好找而且学费还死贵你和他深夜想聊聊准备了半斤白酒，一碟花生米你说着那些曾经你最讨厌的话 还是要为以后工作着想挑个热门的专业活着比热爱重要 你们从交流变成了争吵你发现，你老了老到可能都打不过这个18岁的孩子你说不过他，只能说一句：我是你爸爸！孩子看着你，知道再怎么争辩都没用这场确立你最后威严的酒局不欢而散你听的不真切在孩子回自己屋的路上好像叨叨了一句“我不想活的像你一样” 怎么就哭了呢？50岁的人了一定是酒太辣了，对不对一定是酒太辣 55岁，孩子工作了，似乎有一点理解你了但你却反了过来，你说不要妥协 60岁，辛苦了一辈子，想出去走走身边的那个人过了30年你依旧分不清到底喜不喜欢你们开始规划旅游路线这么多年了你们还是存在分歧，还是在争吵某个瞬间，你觉得这样可能也挺好 一切都准备好了儿子说：爸妈，我工作太忙了可以帮我照顾一下孩子么你们退了机票，又回到了30年前]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>生活</tag>
        <tag>人生</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷信科学与科学迷信]]></title>
    <url>%2F2017%2F04%2Fsuperstitious-science-and-scientific-superstitions%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是我于2017年4月11日进行的简短演讲的演讲稿，文中简单阐述了我对科学以及迷信间关系的理解，在此记录，因为今天的故事是明天的回忆。 迷信科学与科学迷信 &emsp;&emsp;大家好，今天我想谈谈我对迷信科学与科学迷信的理解与看法。&emsp;&emsp;众所周知，科学与迷信是两个相互对立的实践方法。古往今来，人类思维的发展可大致分为三个阶段，即神学、玄学与科学，这是“汉语拼音之父”周有光对人类的认识阶段作出的划分。神学依靠天命，那时的人们相信是神指导着他们的生活、行为、思想以及命运，上帝是不容置疑的。魏晋时期老庄“玄远之学”的起源为迷信增添了推理的成分，《周易》便是玄学的典型代表，它脱离神学，但不可否认，它仍是形而上的。十六世纪，哥白尼的“日心说”，率领人类进入科学的认知阶段。&emsp;&emsp;科学是一个可解释的、有序的知识系统，在广义上还被认为是可靠的代名词；而迷信指盲目的相信、不理解的相信，它象征着愚昧与落后。二者完全对立，但又界限模糊。如今，人们的最大迷信叫做“科学”。生活中，人们大多对科学非常崇拜，往往对科学不假思索地认可。试想：一名村干部在向农民们推广化肥时，他会理直气壮地说：“这是科学！”尽管他可能不懂这其中的化学原理，但他也会底气十足。这恰恰说明科学在大众心中的形象是个神！把自己不懂的东西尊奉到一个至高无上的地位，这种态度正是迷信。&emsp;&emsp;在互联网时代，人们在享受便利的同时也不得不接受如潮水般涌来的资讯，其中鱼龙混杂，充斥着大大小小的谣言与骗局。在这些资讯中，最令人难辨真假的大都与科学有关，例如：转基因食物究竟对人体有无害处？碘盐究竟能不能预防辐射？维生素C能治疗感冒吗？这些信息离每个人的生活都非常近，因此即使科学界尚未对此盖棺定论，但只要打着“科学”的旗号，无论依据是否可靠，多数人都会信服，尤其是中老年人。我想，之所以科技类谣言编造成本低，是因为大多科学谣言的论据不为大众所熟悉，国民科学素养的低下导致他们丧失了判断能力，只能盲目地相信，这无异于迷信。&emsp;&emsp;科学只是前人经过实践探究得出的规律性结论，并非绝对意义的真理。哥白尼的“日心说”推翻了广为认可的“地心说”，而后人又指出了哥白尼观点中的瑕疵；开普勒发现了托勒密折射规律的错误但仍没能给出正确的规律，最终由斯涅耳找出了正确的折射定律；牛顿推翻了亚里士多德的观点，而后量子物理的发展又找出了经典力学的局限性。这些发现都引起了人类对宇宙认识的巨大思想变革。由此可见，我们不必迷信科学，要辩证地看待科学，提高自身科学素养，勇于抱着“大胆假设，小心求证”的心态挑战科学。&emsp;&emsp;反观迷信，只要是稍有些学识的人大都会说迷信是值得唾弃的，殊不知迷信无处不在，它也在潜移默化地改变着我们的生活。据调查，美国作为科学教育最为完善的国家之一，有三成以上的国民相信占星术，并乐意按照星座指南上的指示行事。中国的大街小巷上也不乏风水先生与算卦先生，尽管人们知道这是玄学也愿意以此为自己祈求好运。这样的例子在我们身边也不少见，例如社交媒体上，经常出现诸如“转发即可带来好运”之类的信息，这种事情在考试前尤为常见。不少人照做后真的灵验了，你可能会说这只是巧合。但事实上，这不完全是巧合，这种现象在心理学中叫做“心理暗示”，是人们日常生活中最常见的心理现象。这种祈求尽管不一定有根据，但由于主观上已肯定了它的存在，心理上便竭力趋向于这项内容，这便是信念的力量。如果我们能适当的、科学的运用这种心理暗示，那么迷信也不失为一种利于发展的方式。&emsp;&emsp;综合来看，即使是科学也可能被颠覆，而迷信也并非有百害而无一利。杜绝迷信科学，学会科学迷信，才是最佳发展之道。&emsp;&emsp;我的演讲到此结束，感谢各位的倾听！ 2017年4月9日]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>杂谈</tag>
        <tag>高中</tag>
        <tag>演讲</tag>
        <tag>玄学</tag>
        <tag>科学</tag>
        <tag>迷信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职业无高低]]></title>
    <url>%2F2017%2F02%2Fall-jobs-are-equal%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近日，清华女学霸石悦因选择做游戏主播为职业而走红网络，网友大都报以不支持的态度，原因是在大多数人的认知中，游戏主播是个低贱的行业，不学无术的人才会以此为出路。我想这种扭曲的观念的产生原因有二：一是网络直播作为新兴产业，还未能被大众认可，尤其是在中老年群体中，旧思想根深蒂固，无法接受新鲜事物；二是有许多人不能以端正的态度审视游戏主播这一职业，他们仅仅因为游戏主播大都学历偏低就以偏概全，贬低这种职业的社会地位，从门缝里看游戏主播，导致了这种扭曲的社会怪象。&emsp;&emsp;我认为，术业有专攻，无论在哪个行业之中都会有贵有贱，但职业本身并无高低贵贱之分。即使是大部分人看不起的清洁工人，也不乏有成功人士。因此，我认为石悦选择自己的爱好作为职业是对这一职业的贡献，不应受到贬低，更不应因自己清华出身就遭到谴责。&emsp;&emsp;职业无高低，贵贱在自身，社会需要以包容的态度接纳新观念、新行业。唯有这样，才能构成一个健全的社会。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>主播</tag>
        <tag>杂谈</tag>
        <tag>职业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux实现《黑客帝国》中的“字符雨”]]></title>
    <url>%2F2016%2F11%2Frealizes-character-rain-in-the-matrix%2F</url>
    <content type="text"><![CDATA[《黑客帝国》电影里满屏幕代码的“数字雨”，在 Linux 里面你也可以轻松实现这样的效果，你只需要一个命令：cmatrix。 需要先安装，因为 Ubuntu 没有预装： 12$ sudo apt-get update$ sudo apt-get install cmatrix 装好之后先不要急着执行，为了看到更好的效果，我们需要先修改终端的主题配色，修改为黑底绿字。 这时执行：$ cmatrix就可以看到效果了，按F11可全屏控制台，Ctrl+C可以终止程序。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的Banner生成工具]]></title>
    <url>%2F2016%2F11%2FBanner-generation-tools-under-Linux%2F</url>
    <content type="text"><![CDATA[一、banner——使用#生成banner使用apt-get安装：12$ sudo apt-get update$ sudo apt-get install sysvbanner 使用方法：1$ banner TestText 效果：1234567####### ####### # ###### #### ##### # ###### # # ##### # # # # # # # # # # ##### #### # # ##### ## # # # # # # # ## # # # # # # # # # # # # ###### #### # # ###### # # # 另一个命令：1$ printerbanner -w 50 A ‘-w’参数指定打印宽度，因为我们的环境在屏幕中显示比较小，必须要加上宽度限制。效果：123456789101112131415161718192021# # ########## ##### #### ## #### ## ##### ## ##### ## ##### ## ############ ## ############## ## ############## ############## # ################ ############################################### 二、figlet——使用一些普通字符生成banner使用apt-get安装：1$ sudo apt-get install figlet 使用方法：1$ figlet TestText 使用参数-f可以指定字体，如figlet -f slant EastCoke使用参数-ctf可以使banner居中并且与终端等宽输出到文件可以使用figlet -p &lt; /path/to/file 效果：12345 _____ _ _____ _ |_ _|__ ___| ||_ _|____ _| |_ | |/ _ \/ __| __|| |/ _ \ \/ / __| | | __/\__ \ |_ | | __/&gt; &lt;| |_ |_|\___||___/\__||_|\___/_/\_\\__| 三、toilet——使用一些复杂的彩色特殊字符生成banner使用apt-get安装：1$ sudo apt-get install toilet 使用方法：123$ toilet -f bigmono9 -F gay TestText$ toilet -f mono12 -F metal TestText 效果(截图)： 如果希望在每次打开终端的时候都会显示出banner，可以使用下面的命令：1echo &apos;toilet -f bigmono9 -F gay EastCoke&apos; &gt;&gt; ~/.bashrc]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[航天精神依然在]]></title>
    <url>%2F2016%2F11%2Fthe-spirit-of-space-is-still-there%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;1970年4月24日，中国第一颗人造地球卫星“东方红一号”成功发射，中国航天事业的序幕从此拉开。50多年来，中国航天事业从无到有、从小到大、从弱到强，人们记住了钱学森，记住了杨利伟，也记住了航天“三大”精神，即航天传统精神、“两弹一星”精神和载人航天精神。然而时至今日，中国航天事业已走向成熟，进入了平稳发展时期，没有了重大突破，没有了所谓“大新闻”，因此，航天精神慢慢不再被人提及，人们逐渐淡忘了这曾经催人奋进的灵魂精神。&emsp;&emsp;但是，尽管“东方红一号”早已从我们的眼前消失，但航天精神仍然能应用在各行各业的各个领域。“自强不息，顽强拼搏，团结协作，开拓创新”对于今天的人们仍是发展的动力源泉。2016年8月，中国成功把世界首颗量子科学实验卫星“墨子号”送入太空。此前，潘建伟和他的团队为了这次“全球首发”，做了十一年的分发实验。这十一年间，他们刻苦工作，发扬了“特别能吃苦、特别能战斗、特别能攻关、特别能奉献”的航天精神，为全世界的网络通信安全做出了重大贡献。他们的成功与航天精神是密不可分的。&emsp;&emsp;然而，今天也有不少人违背了航天精神，因此他们与成功背道而驰。如今，中国是一个程序员过剩的国家，然而中国的软件产业仍不能跻身世界前列。举个简单的例子，在几十年前，计算机进行某种计算需要20秒，若是程序员对算法、数据结构进行深度、广度优化，时间可以减半，即10秒完成运算，时间缩短了整整10秒，这种优化就十分有意义；但随着纳米级处理器的迅猛发展，如今的家用计算机仅需0.02秒即可完成原程序，此时若是进行同样的算法改造，可使时间缩为0.01秒，仅有0.01秒之差。不少程序员就忽视了这0.01秒，因为为了这0.01秒他们可能需要几天的时间来攻关、优化，这看似可以理解。然而这些看似聪明的人殊不知不积跬步无以至千里，不积小流无以成江海。一旦程序写大，效率问题就随之暴露，这就是中国人写不出优秀的软件、写不出自己的操作系统的原因。此外在Github等开源平台中，优秀的开源项目多是出自他国人之手，中国程序员中愿意把自己的心血奉献出来的却寥寥无几，因此他们得不到交流的机会，自身水平也就很难提高。通过以上两个实例不难看出，不少中国程序员“特别怕吃苦、特别怕战斗、特别怕攻关、特别怕奉献”，与航天精神相悖，因此中国软件产业难有长足发展。若是人们都能发扬航天精神，恐怕早已不是今天这幅景象。&emsp;&emsp;有的人“特别能吃苦、特别能战斗、特别能攻关、特别能奉献”，他们大都走向成功，有的人“特别怕吃苦、特别怕战斗、特别怕攻关、特别怕奉献”，他们难有成才者。我想航天精神在今天仍然发挥的作用已不言而喻。航天精神依然在，它早已不再局限于航天领域，它已经刻在每一个想要取得辉煌成就的人心中。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>爱国</tag>
        <tag>评析</tag>
        <tag>航天精神</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对公网、路由器、内网关系的理解]]></title>
    <url>%2F2016%2F10%2Fthe-understanding-of-the-relationship-between-WAN-routers-and-LAN%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;怎样才能让别人直接访问我的本地网站，这个问题困扰了我很久，原因在于本机IP为类似于192.168.1.xxx的内网IP，显然在公网（全域网）别人是访问不到这里的。今天我对这三者有了更加深刻、透彻的理解。&emsp;&emsp;最简单的，在同一局域网（如同一WIFI下）的设备可以通过这个本地IP（本文以192.168.1.106为例）访问本机。首先在本机上跑一个WEB服务器软件，这里使用的是Nginx，原因是轻小方便，当然Apache等Web服务器也是可以的。&emsp;&emsp;此时，用浏览器访问Localhost（即http://127.0.0.1）即可看到服务器的index.html。&emsp;&emsp;当然，在同一局域网内的其他设备也可以通过你的局域网IP（Windows下可以用ipconfig命令查看IPv4地址）访问此站。顺便一提IPv4指的就是有四个字段的IP地址（xx.xx.xx.xx），而现在逐渐流行的IPv6，顾名思义就是有六个字段的IP地址（xx.xx.xx.xx.xx.xx）。&emsp;&emsp;此时我们已经实现了让同一局域网的设备访问自己的Web服务器。但如何让不在局域网的设备访问呢？这就需要路由器的功能及其原理。&emsp;&emsp;在我们的家中，若是接入了互联网，便可以通过网线让自己的设备接入互联网。但如何让所有的设备都能接入网络呢？路由器的存在主要就是为了解决这个问题。&emsp;&emsp;在路由器的管理界面（地址通常是192.168.1.1或192.168.0.1），我们可以找到接入的公网IP地址，这也就是互联网服务提供商（ISP）分给我们的IP。&emsp;&emsp;当其他设备接入这个路由器后，路由器就会建立一个局域网，介入的设备便会被分得内网IP，如我的计算机的局域网IP就是192.168.1.106，它的作用域仅仅是在这个局域网内。此外，路由器本身也是一个系统，它的内网IP一般是192.168.1.1。画一个简图就是这样：&emsp;&emsp;因此，在一个局域网内的设备可以互访，但外部的访问请求只能发送到180.xxx.xxx.216，也就是路由器，但路由器本身并不是Web服务器，因此无法发送请求的数据。如果Web服务器是局域网内的一台设备，那么就需要通过路由器映射80端口（网页传输的默认端口）。具体步骤是：打开路由器管理界面，进入“转发规则”菜单（不同路由器可能不尽相同，但都大同小异），服务端口号填写80，也可以自己指定任意空闲端口，IP地址填写Web服务器的局域网IP（192.168.1.106），协议选择TCP，常用服务端口号选择HTTP。生效后任何接入互联网的设备就都可以通过你路由器的公网IP访问你的Web服务器了。&emsp;&emsp;总结一下，所谓“转发”就是路由器把外来请求下放到局域网中指定的Web服务器，简图如下：]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>网络</tag>
        <tag>Web服务器</tag>
        <tag>局域网</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种语言画国旗]]></title>
    <url>%2F2016%2F10%2Fdraw-the-national-flag-by-four-languages%2F</url>
    <content type="text"><![CDATA[国庆假期，闲来无事，用HTML、C、Java、Python四种语言画国旗 HTML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;html&gt;&lt;head&gt; &lt;script&gt; var col=new Array("red","brown"); var ticker=0; var step=0; function drawBackground()&#123; var g=document.getElementById("background").getContext("2d"); var grd=g.createLinearGradient(-560+ticker, 0, 1400+ticker,0); for (var i=0; i&lt;10; i++) grd.addColorStop(i/10,col[(i + step)%col.length]); ticker=ticker+10; if (ticker&gt;=196)&#123; ticker=0; step++; &#125; g.fillStyle=grd; g.fillRect(0,0,1600,700); &#125; function preperation()&#123; setInterval('drawBackground()',100); &#125; &lt;/script&gt; &lt;style type="text/css"&gt; #myCanvas&#123; z-index:2; position:absolute; left:0px; top:-5px; &#125; #background&#123; z-index:1; position:absolute; left:0px; top:0px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body onLoad="preperation()"&gt; &lt;canvas id="myCanvas" width="900" height="600" &gt; Your browser does not support the HTML5 canvas tag. &lt;/canvas&gt; &lt;canvas id="background" width="1600" height="700" &gt;&lt;/canvas&gt; &lt;script&gt; var x=new Array(0,12,54,18,28,0,-28,-18,-54,-12,0); //五角星样品坐标xx数组 var y=new Array(-53,-17,-17,1,45,19,45,1,-17,-17,-53); //五角星样品坐标y数组 var c=document.getElementById("myCanvas"); var ctx=c.getContext("2d"); //获得画笔 //样品数组x轴坐标 a , 和y轴坐标 b //指定位置[locationX,locationY] //真实五角星的大小，与样品五角星尺寸之比 f //五角星画完后，旋转的角度 rotation function star(a,b,locationX,locationY,f,rotation)&#123; ctx.save();//记录画图（画笔）的初始环境 ctx.translate(locationX,locationY); ctx.rotate(rotation*Math.PI/180.0); ctx.beginPath(); ctx.moveTo(Math.round(a[0]*f),Math.round(b[0]*f)); for (var i=1;i&lt;a.length;i++) ctx.lineTo(Math.round(a[i]*f),Math.round(b[i]*f)); ctx.closePath(); ctx.fillStyle="yellow"; ctx.fill(); ctx.restore();//还原画图（画笔）的初始环境 &#125; star(x,y,165,165,1.4,0);//画大五角星 star(x,y,301,65,0.5,30);//画小五角星 star(x,y,362,126,0.5,-30);//画小五角星 star(x,y,359,216,0.5,0);//画小五角星 star(x,y,301,273,0.5,30);//画小五角星 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;windows.h&gt;#include &lt;math.h&gt;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);void DrawFiveStarFlag(HDC hdc, int x, int y, int w);void DrawFivePointedStar(HDC hdc, int x, int y, int r, float d);/* Current app instance */HINSTANCE hInst;/* Make the class name into a global variable */TCHAR szClassName[] = TEXT("WindowsApp");int WINAPIWinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nFunsterStil)&#123; HWND hwnd; /* This is the handle for our window */ MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* Save this instance */ hInst = hThisInstance; /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows's default color as the background of the window */ wincl.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let's create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ TEXT("TestPie"), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ 0, /* where the window ends up on the screen */ CW_USEDEFAULT, /* The programs width */ 0, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nFunsterStil); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) &#123; /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); &#125; /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;&#125;/* This function is called by the Windows function DispatchMessage() */LRESULT CALLBACKWindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; PAINTSTRUCT ps; HDC hdc; switch (message) /* handle the messages */ &#123; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); /* TODO: Add any drawing code here... */ DrawFiveStarFlag(hdc, 50, 50, 300); EndPaint(hwnd, &amp;ps); break; case WM_DESTROY: PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; default: /* for messages that we don't deal with */ return DefWindowProc (hwnd, message, wParam, lParam); &#125; return 0;&#125;/* 画五角星 * 参数：hdc画图句柄，xy中心点坐标，r外圆半径，d偏斜角度（逆时针） */void DrawFivePointedStar(HDC hdc, int x, int y, int r, float d)&#123; float r0 = 0.381966*r; //内圆半径：r*sin(0.1*M_PI)/sin(0.7*M_PI) int i; POINT p[10]; //计算10个顶点的坐标（72度为实心五角星，144为空心五角星） for(i=0; i&lt;5; i++) &#123; p[2*i].x = x + r*cos((i*72-18+d)*M_PI/180); p[2*i].y = y + r*sin((i*72-18+d)*M_PI/180); p[2*i+1].x = x + r0*cos((i*72+18+d)*M_PI/180); p[2*i+1].y = y + r0*sin((i*72+18+d)*M_PI/180); &#125; //画五角星 Polygon(hdc, p, 10);&#125;/* 画五星红旗 * 参数：hdc画图句柄，xy旗左上角坐标，w旗宽 */void DrawFiveStarFlag(HDC hdc, int x, int y, int w)&#123; COLORREF RED = RGB(255, 0, 0), YELLOW = RGB(255, 255, 0); HPEN hPen1 = CreatePen(PS_SOLID, 1, RED), hPen2 = CreatePen(PS_SOLID, 1, YELLOW); HBRUSH hBrush1 = CreateSolidBrush(RED), hBrush2 = CreateSolidBrush(YELLOW); //画旗面 SelectObject(hdc, hPen1); SelectObject(hdc, hBrush1); Rectangle(hdc, x, y, x+w, y+2*w/3); //画5星 SelectObject(hdc, hPen2); SelectObject(hdc, hBrush2); DrawFivePointedStar(hdc, x+w/6, y+w/6, w/10, 0); //大星 DrawFivePointedStar(hdc, x+w/3, y+w/15, w/30, 18); //4个小星，倾斜角度都是估的 DrawFivePointedStar(hdc, x+2*w/5, y+2*w/15, w/30, 45); DrawFivePointedStar(hdc, x+2*w/5, y+7*w/30, w/30, 9); DrawFivePointedStar(hdc, x+w/3, y+3*w/10, w/30, 27); DeleteObject(hPen1); DeleteObject(hPen2); DeleteObject(hBrush1); DeleteObject(hBrush2);&#125; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.awt.RenderingHints;import java.awt.geom.AffineTransform;import java.awt.geom.GeneralPath; import javax.swing.JFrame; public class NationalFlag extends JFrame &#123; private int width = 288,height = width/3*2; private double maxR = 0.15, minR = 0.05; private double maxX = 0.50, maxY = 0.50; private double[] minX = &#123;0.75, 0.85, 0.85, 0.75&#125;; private double[] minY = &#123;0.35, 0.45, 0.60, 0.70&#125;; public NationalFlag() &#123; setTitle("国旗 - by PotatoChipsNinja"); setDefaultCloseOperation(EXIT_ON_CLOSE); &#125; @Override public void paint(java.awt.Graphics graphics) &#123; super.paint(graphics); java.awt.Graphics2D g = (java.awt.Graphics2D)graphics; g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); //棋面 g.setColor(java.awt.Color.red); g.fillRect(50, 50, width, height); g.setColor(java.awt.Color.yellow); //画大星星 double ox = height*maxX, oy = height*maxY; g.fill(createPentacle(ox,oy,height*maxR,-Math.PI/2)); //画小星星 for(int idx =0;idx &lt; 4;idx ++)&#123; double sx = minX[idx]*height, sy = minY[idx]*height; double theta = Math.atan2(oy-sy,ox-sx); g.fill(createPentacle(sx,sy,height*minR,theta)); &#125; &#125; /** * 创建一个五角星形状. 该五角星的中心坐标为(sx,sy),中心到顶点的距离为radius,其中某个顶点与中心的连线的偏移角度为theta(弧度) * * @return pentacle 一个☆ */ public static java.awt.Shape createPentacle(double sx, double sy, double radius,double theta) &#123; final double arc = Math.PI / 5; final double rad = Math.sin(Math.PI / 10) / Math.sin(3 * Math.PI / 10); GeneralPath path = new GeneralPath(); path.moveTo(1, 0); for (int idx = 0; idx &lt; 5; idx++) &#123; path.lineTo(rad * Math.cos((1 + 2 * idx) * arc),rad * Math.sin((1 + 2 * idx) * arc)); path.lineTo(Math.cos(2 * (idx + 1) * arc),Math.sin(2 * (idx + 1) * arc)); &#125; path.closePath(); AffineTransform atf = AffineTransform.getScaleInstance(radius, radius); atf.translate(sx / radius, sy / radius); atf.rotate(theta); return atf.createTransformedShape(path); &#125; public static void main(String[] args) &#123; NationalFlag flag = new NationalFlag(); flag.setBounds(100, 100, 400, 400); flag.setVisible(true); &#125;&#125; Python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding=utf-8import turtleimport math def draw_polygon(aTurtle, size=50, n=3): ''' 绘制正多边形 args: aTurtle: turtle对象实例 size: int类型，正多边形的边长 n: int类型，是几边形 ''' for i in xrange(n): aTurtle.forward(size) aTurtle.left(360.0/n) def draw_n_angle(aTurtle, size=50, num=5, color=None): ''' 绘制正n角形，默认为黄色 args: aTurtle: turtle对象实例 size: int类型，正多角形的边长 n: int类型，是几角形 color: str， 图形颜色，默认不填色 ''' if color: aTurtle.begin_fill() aTurtle.fillcolor(color) for i in xrange(num): aTurtle.forward(size) aTurtle.left(360.0/num) aTurtle.forward(size) aTurtle.right(2*360.0/num) if color: aTurtle.end_fill() def draw_5_angle(aTurtle=None, start_pos=(0,0), end_pos=(0,10), radius=100, color=None): ''' 根据起始位置、结束位置和外接圆半径画五角星 args: aTurtle: turtle对象实例 start_pos: int的二元tuple，要画的五角星的外接圆圆心 end_pos: int的二元tuple，圆心指向的位置坐标点 radius: 五角星外接圆半径 color: str， 图形颜色，默认不填色 ''' aTurtle = aTurtle or turtle.Turtle() size = radius * math.sin(math.pi/5)/math.sin(math.pi*2/5) aTurtle.left(math.degrees(math.atan2(end_pos[1]-start_pos[1], end_pos[0]-start_pos[0]))) aTurtle.penup() aTurtle.goto(start_pos) aTurtle.fd(radius) aTurtle.pendown() aTurtle.right(math.degrees(math.pi*9/10)) draw_n_angle(aTurtle, size, 5, color) def draw_5_star_flag(times=20.0): ''' 绘制五星红旗 args: times: 五星红旗的规格为30*20， times为倍数，默认大小为10倍， 即300*200 ''' width, height = 30*times, 20*times # 初始化屏幕和海龟 window = turtle.Screen() aTurtle = turtle.Turtle() aTurtle.hideturtle() aTurtle.speed(10) # 画红旗 aTurtle.penup() aTurtle.goto(-width/2, height/2) aTurtle.pendown() aTurtle.begin_fill() aTurtle.fillcolor('red') aTurtle.fd(width) aTurtle.right(90) aTurtle.fd(height) aTurtle.right(90) aTurtle.fd(width) aTurtle.right(90) aTurtle.fd(height) aTurtle.right(90) aTurtle.end_fill() # 画大星星 draw_5_angle(aTurtle, start_pos=(-10*times, 5*times), end_pos=(-10*times, 8*times), radius=3*times, color='yellow') # 画四个小星星 stars_start_pos = [(-5, 8), (-3, 6), (-3, 3), (-5, 1)] for pos in stars_start_pos: draw_5_angle(aTurtle, start_pos=(pos[0]*times, pos[1]*times), end_pos=(-10*times, 5*times), radius=1*times, color='yellow') # 点击关闭窗口 window.exitonclick() if __name__ == '__main__': draw_5_star_flag()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>HTML</tag>
        <tag>Java</tag>
        <tag>国旗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月盈则亏，水满则溢——读《红楼梦》有感]]></title>
    <url>%2F2016%2F08%2Fsense-of-reading-A-Dream-in-Red-Mansions%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在中国古典四大名著之一《三国演义》中开篇便有这样一句话：“话说天下大势，分久必合，合久必分。”这是指人或事物变化无常，分合无定。此句也用来表示人物或事情的发展分分合合拥有一定的必然性，是事物发展的规律和必然注定。我想这也是同为四大名著之一——《红楼梦》的作者想要告诉我们的。&emsp;&emsp;《红楼梦》全文都是围绕贾、史、王、薛四大家族的兴衰展开的。比如最后贾府的衰败，表面看上去是多种因素共同导致的：首先，贾府在当时的社会赫赫有名、盛极一时，必然会树敌众多，遭人嫉妒，有很大隐患；此外，长辈们对后代的教育不得力，使得子孙游手好闲，不思进取；其次，他们当时嚣张、专横、跋扈的作风得罪了不少人，也与权臣结怨；最后，也是最重要的是当时封建家族为利益联姻，大家运命相连，一荣皆荣，一损俱损，因此薛、王、史三家的衰落直接导致了贾府的崩盘。&emsp;&emsp;但是，列出这些所有的原因，可以全部归结于一个道理：盛极必衰。&emsp;&emsp;在现代汉语中，有很多表达类似盛极必衰这样的思想的词语，比如：物极必反、乐极生悲等等。早在春秋时期，儒家学派就已经意识到这个问题了，因此儒家推崇中庸思想。而《红楼梦》中这四大家族却都忽视了这个问题，这些封建贵族为了权势与钱财，不惜一切。表面温情脉脉，实际充满了勾心斗角和种种激烈的矛盾和斗争。他们这样做，只能换取一时的繁盛，换不来一世的安宁。&emsp;&emsp;《红楼梦》中最深刻的哲学思想，不是正义与邪恶的较量，也不是欲与理的纠缠，而是月盈则亏，水满则溢。在小说第一回中就有“瞬息间则又乐极悲生，人非物换，究竟是到头一梦，万境归空”，曹雪芹暗示了运势会因时间而轮回的道理。&emsp;&emsp;这个道理在我们的日常生活中同样适用。我们都有过这样的经历：有时越想办成一件事就越难成功，反而会在不经意间“无心插柳柳成荫”。在没有头绪的时候，与其绞尽脑汁，倒不如放轻松，休息片刻也许能够剑走偏锋、出奇制胜。无论如何，都不要采取极端的手段，否则就像四大家族那样，即便取得了短暂的成功，也不可能是长久之计。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>红楼梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟随时代的脚步——读《唐•吉诃德》有感]]></title>
    <url>%2F2016%2F08%2Fsense-of-reading-Don-Quixote%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;读了《唐·吉诃德》这部反骑士小说，我对理想与现实的区别有所感悟，但此书给我最大的启示是：要紧跟时代的脚步。&emsp;&emsp;很多人说唐·吉诃德没能实现理想是因为他的理想和现实之间存在矛盾。而我认为唐·吉诃德之所以失败，并不是因为他思想的错误，而是由于时代的变迁。鲁迅先生在把此书引入中国时就曾有过解读：“以此书为刺，揭示人以旧思想之难行于新时代也”。&emsp;&emsp;这部小说终结了骑士文学，书中主人公阿隆索·吉哈诺一切荒诞的行为看似匪夷所思，但如果在骑士没有绝迹的年代，他的行为就不会令人感到奇怪。因此，我们不能说唐·吉诃德的做法是错误的，只能说这并不为当今时代所接受。&emsp;&emsp;人类永远不会停止发展的脚步，优胜劣汰是大自然永恒的法则。仔细想想骑士为何会被淘汰，是因为人们发明了枪炮，自然就不会有人再去当骑士。而主人公看了无数骑士小说并深受其感染，他把已被时代淘汰的事物当作自己的理想，这在一开始就注定了他的失败。&emsp;&emsp;但这并不意味着旧事物、旧思想不重要。若没有地基哪会有参天大楼？从原始人类开始，人们一代一代地繁衍，每一代人都是站在前一代搭建好的平台上继续搭建，这使得人类文明发展到了如今的水平。既然如此，我们只需在前人努力的基础上继续发展，为何还要记录已经被淘汰的历史呢？这就好比一个公式，你使用时只需记住结论，但了解其推倒过程会让你有更深刻的认识。我想我们铭记历史是为了今后更好地发展，不要再走重复的路。&emsp;&emsp;理想能激励我们向前，但理想的确立要站在现实的基础之上，若与现实背道而驰，那充其量算是梦想，永远不可能实现。比如书中的唐·吉诃德，他的理想建立在已被淘汰的时代，而时代容不得倒退，他的理想就不可能在当时他所处的时代实现。当然把理想建立得离现实太过遥远也是荒诞的。仰望星空，脚踏实地，理想要建立在现实之上，不能总想一步登天，也不要走重复的路，我想这是作者塞万提斯想借讽刺唐·吉诃德警示人们的。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>唐·吉诃德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活不能等待别人来安排——读《平凡的世界》有感]]></title>
    <url>%2F2016%2F08%2Fsense-of-reading-the-Ordinary-World%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;读了这部讴歌劳动者的伟大作品《平凡的世界》，我感触颇多。起初，我不明白此书为何名叫“平凡的世界”，通篇读完后，我觉得真正平凡的人一定不平凡。&emsp;&emsp;何为平凡？我认为平凡不仅仅是无特色或无区别，更是一种为人处世的良好心态，这与儒家的中庸思想不谋而合。主人公孙少安、孙少平尽管生活历尽艰辛、苦苦挣扎，但他们从未言弃，积极与命运作斗争,追求自己的幸福。他们自强不息的精神带给苦难中的劳动者希望与动力，我想这也是路遥先生作此小说的目的。&emsp;&emsp;不同于其他现实主义小说作家，路遥的《平凡的世界》主旨并不在突出表现劳动者的苦难或是抨击社会的压抑，而是把这种苦难转化为继续努力的精神食粮，给人以希望。我认为，在现实生活中，我们也应该如此，因为活着不是为了苦恼生活的不如意，而是要努力活得更好。“在这个世界上，不是所有合理的和美好的都能按照自己的愿望存在或实现。”正因如此，才有了中华民族千百年来“自强不息，厚德载物”的美德。&emsp;&emsp;小说中在讲述劳动者生产生活的艰辛之余，还有不少美好的情感令人动容，给人温暖。这里既有邻里之情、同学之情、同事之情，还有美好又令人惋惜的爱情。作者之所以加入这些情感故事，为的是弘扬人性之光，带给劳动人民温暖，《平凡的世界》给无数劳动人民心灵上的慰藉。&emsp;&emsp;处在不同时代的人都有不同的命运，也许我们无法切身感受到那个年代劳动人民的艰辛，但从《平凡的世界》中，我发现了身边的幸福，平凡也是幸福的，但要想平凡就一定要有不平凡的理想与抱负，即使最平凡的人也要为他生活的那个世界而奋斗。有一句话说得好：“命是弱者的借口，运是强者的谦辞。”尽管我们不能完全左右自身的命运，但“生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，但可以慰藉的是，你总不枉在这世上活了一场。有了这样的认识，你就会珍重生活，而不会玩世不恭；同时，也会给人自身注入一种强大的内在力量。”]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>平凡的世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[薯片忍者的Wiki上线了！]]></title>
    <url>%2F2016%2F08%2Fmy-wiki-launched%2F</url>
    <content type="text"><![CDATA[2016年8月2日，我的个人知识网络系统——“薯片忍者的Wiki”正式上线，地址为http://wiki.potatochipsninja.tk/，希望大家光临。 此站采用开源的wiki引擎程序DokuWiki搭建，站内全部内容除另有声明外，均在署名-非商业性使用-相同方式共享 4.0 国际协议下发布。]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>公告</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大家好！这里是我的博客]]></title>
    <url>%2F2016%2F08%2Fhere-is-my-blog%2F</url>
    <content type="text"><![CDATA[我是薯片忍者，今天是2016年8月1日，我建立了我的个人博客。 我的博客地址：http://blog.potatochipsninja.tk（暂停使用） https://pcninja.cn 我的网站地址：http://www.potatochipsninja.tk（暂停使用）以上地址如有变动，我将第一时间在此公布。 您也可以关注我的新浪微博或Twitter获取其他信息。]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>公告</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南方之学，得其菁华——江苏之行有感]]></title>
    <url>%2F2016%2F06%2Ffeeling-after-the-trip-to-Jiangsu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2016年6月11日，我与同学们在星期六的黄昏踏上了难忘的京外社会实践活动之旅。此次实践活动中，我们的目的地是南方城市江苏省，等待我们的是为期一周的京外学习生活。&emsp;&emsp;当天晚九时许，我们登上了Z29次列车，正式开启了此次江苏之行。当晚，在火车上的自习让我感到了与在家中不一样的学习氛围与感受。次日早晨，我们抵达扬州，随即在雨中漫步瘦西湖。在瘦西湖，我有了对江南气候与文化的初步认识。我想正是这不期而遇的大雨，让这瘦西湖变得更有韵味，富有朦胧意境之美。午饭过后，我们集体参观了扬州双博馆，即扬州博物馆和扬州中国雕版印刷博物馆。馆内设有广陵潮—扬州城市故事厅、扬州八怪书画厅、馆藏明清书画厅、国宝厅、扬州古代雕刻厅、中国雕版印刷展厅、扬州雕版印刷展厅和一个临展厅计八个展厅。在这里，我们领略了扬州历史文化的悠久与中华雕版印刷的奇妙。当天下午，我们乘车抵达并入驻了最具中国文化情怀的学校——江苏省南菁高级中学，一进大门我就被校园的美丽所震撼。这里地处无锡市江阴市的市郊，文化气息浓厚，因此是学习的好地方。晚上我们在南菁高中用餐并进行了晚自习后结束了这忙碌而又充实的一天。&emsp;&emsp;13日早，我们伴着校园内响起的《命运》交响曲迎来了崭新的一天。早餐过后，我们随南菁高中的同学们一同参加了升旗仪式，感受到了南菁的校园文化。当天上午，我们在学政厅参加了随班听课与同课异构活动，这一次我切身感受到了身处中国高考最难省的江苏省的学生的学习压力，他们的课堂不仅带给我四节课的知识，更重要的是让我明白了自己的幸福，因此我们更应该努力学习。中午，在正学亭前组织了北京十二中与南菁高级中学学生联谊会，歌舞、相声让观众的掌声不断。午后，我们参观了校园。在这所距今已有133余年历史的校园中，造就了无数各领域的精英，他们的校训是“忠恕勤俭”，值得每个人学习。下午的辩论赛与篮球赛颇为精彩，输赢并不重要，重要的是两校的同学都辩出了风采、打出了激情。晚饭后，我们参观了坐落于校园内的沈鹏艺术馆。沈鹏先生作为著名的书法家，尽管一生取得无数辉煌成就，但不忘初心，致力于慈善、教育等事业，并坚持把沈鹏艺术馆建在自己的母校——南菁高中，这种精神让我动容，值得我们学习。&emsp;&emsp;接下来的三天中，我们先后参观了太湖边农庄、鼋头渚景区、惠山古镇、拙政园、枫桥夜泊、扬州博物馆、中山陵、侵华日军南京大屠杀遇难同胞纪念馆、夫子庙。在这些地方，我学会了知识、懂得了欣赏，让这次游学变得更有意义。&emsp;&emsp;16日晚，我们告别了南京，告别了江苏、告别了这美丽的地方。夜色中的江南是那么美丽，我舍不得离开，但不得不离开。随着T66次列车的开动，我们踏上了回家的旅途，回家是美好的，更何况我们是带着这么多美好的回忆满载而归。&emsp;&emsp;次日早10时许，火车停在了北京站，下车后，干燥但又熟悉的空气包围了我，我感到那么亲切。11时，我们抵达了我的学校北京十二中，在烈日下，我们做了简单的分别，这也标志这此次京外社会实践活动的结束，每个人都需要一段时间的休整，待收好行囊、整装待发之际，迎来新的征程与挑战。&emsp;&emsp;这次社会实践活动我收获了许多，扬州双博让我看到中华文化的博大精深，南菁高中带给我文化底蕴的冲击，枫桥夜泊让我置身诗画之中，南京大屠杀遇难同胞纪念馆让我铭记历史，为每个人敲响了爱国的警钟……仰望星空，脚踏实地，这些收获无不激励着我们前行。尽管旅途结束了，但希望与星火不灭，因为我们的征途是星辰大海，我们志存高远！&emsp;&emsp;愿北京市第十二中学与江苏省南菁高级中学的友谊长存！2016年6月18日]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>回忆</tag>
        <tag>江苏</tag>
        <tag>游记</tag>
        <tag>高中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《红楼梦》第四回有感]]></title>
    <url>%2F2016%2F04%2Fsense-of-reading-A-Dream-in-Red-Mansions-chapter-four%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;《红楼梦》第四回中，表面上只是写了几个人的故事，但在之中“早为下半部伏根”，它为后文写四大家族的兴衰做足了铺垫。四大家族缘何衰败，在第四回中就能找到答案。&emsp;&emsp;贾雨村做了官，上任后就有了一桩人命官司，开始贾雨村还准备秉公执法，捉拿杀人凶手，但见了“护官符”他就徇私枉法，胡乱判案，让薛蟠逍遥法外。这护官符中这样写道：“贾不假，白玉为堂金作马。阿房宫，三百里，住不下金陵一个史。东海缺少白玉床，龙王来请金陵王。丰年好大雪，珍珠如土金如铁。”，其中“雪”字就暗指“薛”，贾雨村一见此符就照做，说明四大家族是个“命运共同体”，他们相互勾结，狼狈为奸，因此“一荣俱荣，一损皆损”，贾雨村不想因此为自己招惹是非，便做出此事。从中不难看出贾雨村内心深不可测，在官场下，他虚情假意；而在官场上，他又小心谨慎，装腔作势，阴险狡诈。贾雨村面对普通百姓就态度强硬，面对有关系的人物便阿谀奉承；他恃强凌弱，见风使舵，为了自己的仕途与利益不顾正义，徇私枉法，是一个小人。贾雨村的这种行为迟早要受到法律的制裁，因此四大家族的衰败是必然的结果。&emsp;&emsp;从“护官符”一事就可见当时社会中高层贵族对底层群众的血汗与生命的剥削，揭露了封建政治的腐败和整个社会的黑暗与残酷，也为后面写因“事败”而“一损皆损”做铺垫，为四大家族的衰败“伏根”。&emsp;&emsp;第四回中还出现了一个角色——薛蟠。他因幼年受到溺爱，导致性情奢侈，言语傲慢，只顾游山玩水，不学无术，他蛮横暴力，一直放纵自己，过着安逸、富贵的生活，最终落得一无是处。这是缺乏教养的表现，更是长辈对他过度溺爱的结果，从中体现出四大家族对后代的管教不严，不成体统，贾宝玉就是个例子，因此我认为后代骄奢淫逸、不学无术也是四大家族最终落寞的一大原因。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>红楼梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔问题解法探究]]></title>
    <url>%2F2016%2F03%2Fexplore-the-solution-of-Hanoi%2F</url>
    <content type="text"><![CDATA[摘要：汉诺塔问题如何解决？有何规律与方法？通过发现、研究、总结规律，探索出解决n个盘子汉诺塔问题的方法。关键词：汉诺塔、递归第一部分、问题的提出&emsp;&emsp;汉诺（Hanoi）塔问题是源于法国数学家爱德华·卢卡斯编写的一个印度古老传说的益智玩具。其规则是：现有三根柱，即A柱、B柱与C柱，在A柱上从上往下按照从小到大的顺序摞着64片圆盘，要求在大盘不能在小盘之上、一次只能移动一个圆盘的前提下，把圆盘按大小顺序完全移动至C柱（如图1所示）。&emsp;&emsp;要想完成这个游戏，需要按怎样的步骤移动？至少需要多少步才能完成？怎样移动步数最少？一个个问题困扰着我，于是我对汉诺塔问题展开了探究。 第二部分、问题的探究&emsp;&emsp;要想解决原题目中64个圆盘的汉诺塔问题，不妨先从简单的汉诺塔问题入手，再从特殊到一般，总结出n个盘子的规律。&emsp;&emsp;经过一段时间的尝试，我发现1个盘子的汉诺塔问题只需一步即可解决，即A—&gt;C；2个盘子的汉诺塔问题最少需要三步来解决，即A—&gt;B，A—&gt;C，B—&gt;C；3个盘子的汉诺塔问题最少需要七步来解决，即A—&gt;C，A—&gt;B，C—&gt;B，A—&gt;C，B—&gt;A，B—&gt;C，A—&gt;C。这三种简单情况之需经过简单的尝试即可解决，但从4个盘子开始，问题变得越来越复杂，经过屡次尝试我才找到了最少步数的解决方法：A—&gt;C，A—&gt;B，C—&gt;B，A—&gt;C，B—&gt;A，B—&gt;C，A—&gt;C，共15步。&emsp;&emsp;通过上面的四次尝试，我对于盘子数（n）与最少步数（S）列出下表： n/个 1 2 3 4 … S/步 1 3 7 15 … &emsp;&emsp;根据表中数据，我做出大胆猜测：最少步数（S）与盘子数（n）成正相关，且S=2^n-1。&emsp;&emsp;为了验证以上猜想的正确性，我开始寻找n=2、3、4时移动步骤的共性。若从原始条件出发没有头绪，不妨试试从结果出发。因为目的是把所有盘子移动到C柱，而又必须遵循大在下小在上的原则，那么就必须先把最大的盘子移动到C柱，再把次大的盘子移动到C柱，再把第三大的盘子移动到C柱，循环往复，直到最小的盘子也“抵达”C柱。&emsp;&emsp;这个方法就好比大货车与小轿车发生车祸，轿车被压在货车下，一名行人被压在轿车之下。要想先救出被压在车底的人，就必须先把车一并抬起，移动到他处，再把人救出。&emsp;&emsp;经过思考，我发现，不论2个、3个还是4个盘子，都是先想办法把A柱上除最后一个盘子以外的所有盘子移动到B柱上（如图2所示），这样就得以把A柱上剩下的最大的盘子移动至C柱（如图3所示）；这时B柱上套着除最大盘外所有的盘子，B柱就好比一开始的A柱，A柱就变为空柱；把B柱上除最后一个盘子以外的所有盘子移动到A柱上（如图4所示），这样就得以把B柱上剩下的次大的盘子移动至C柱（如图5所示）……&emsp;&emsp;实践是检验真理的唯一标准，借助这个思路，我成功地解决了5个盘子的汉诺塔问题，步骤为：A—&gt;C，A—&gt;B，C—&gt;B，A—&gt;C，B—&gt;A，B—&gt;C，A—&gt;C，A—&gt;B，C—&gt;B，C—&gt;A，B—&gt;A，C—&gt;B，A—&gt;C，A—&gt;B，C—&gt;B，A—&gt;C，B—&gt;A，B—&gt;C，A—&gt;C，B—&gt;A，C—&gt;B，C—&gt;A，B—&gt;A，B—&gt;C，A—&gt;C，A—&gt;B，C—&gt;B，A—&gt;C，B—&gt;A，B—&gt;C，A—&gt;C，共计31步，这也成功地验证了我对于步数与盘子数之间关系：S=2^n-1的猜想。&emsp;&emsp;综上所述，我总结出了解决n个盘子的汉诺塔问题的移动步骤：(a1)把A柱上上面的n-1个盘子移动至B柱；(a2)把A柱上剩下的一个盘子移动至C柱；(a3)把B柱上的n-1个盘子移动至C柱。&emsp;&emsp;在这之中a2步是很好实现的，而a1步与a3步却不能直接实现。若想实现第a1步，就需要进行以下三个步骤：(b1)把A柱上上面的n-2个盘子移动至C柱；(b2)把A柱上上面的一个盘子移动至B柱；(b3)把C柱上的n-2个盘子移动至B柱。&emsp;&emsp;这三步本质上和a1、a2、a3三步是相同的，只不过要移动的盘子少了一个，而目的地也从C柱变成了B柱。若想实现第b1步，就还需要进行三个步骤……&emsp;&emsp;这种逆推的思想使得问题变为了一个个循环的过程，每一次过程都比原过程的盘子数少一个，循环往复，直到新过程中的盘子数变为1为止。这便是一个典型的递归方法。&emsp;&emsp;借助C语言允许在函数中直接调用此函数本身的特性，我用C语言实现了汉诺塔问题的递归调用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Hanoi.c#include &lt;stdio.h&gt;int step = 0;void hanoi (int d, char first, char second, char third);void out (char from, char to); //输出int main(void)&#123; int disk; //盘子数 char ch; printf("Please input the number of diskes:"); scanf("%d", &amp;disk); printf("\n\nThis is the step to move %d diskes:\n", disk); hanoi (disk, 'A', 'B', 'C'); printf("\nThis is all of %d steps.\n", step); while ((ch = getchar()) != '\n') //按任意键继续 continue; getchar(); return 0;&#125;void hanoi (int n, char first, char second, char third)&#123; if (n == 1) &#123; out (first, third); step++; &#125; else &#123; hanoi (n - 1, first, third, second); out (first, third); step++; hanoi (n - 1, second, first, third); &#125;&#125;void out (char from, char to)&#123; printf("%c ---&gt; %c\n", from, to);&#125; &emsp;&emsp;程序实现了对用户指定盘子数n的移动步骤与总步数的输出，在MinGW编译环境下编译，运行效果如图6（输入3）。&emsp;&emsp;至此，关于汉诺塔问题的探究便告一段落。 第三部分、结论与启示&emsp;&emsp;从最初的尝试，到大胆猜想，再到获得思路，最后成功把理论应用至实践，用计算机实现了对于n个盘子汉诺塔问题步骤的输出。整个探究过程帮助我透彻地理解了汉诺塔等递归问题的本质。其实递归问题不仅仅只有汉诺塔问题，例如“有5个人，问第5个人多少岁，他说比第4个人大两岁；问第4个人多少岁，他说比第3个人大两岁；问第3个人多少岁，他说比第2个人大两岁；问第2个人多少岁，他说比第1个人大两岁；最后问第1个人多少岁，他说是十岁。求第5个人多少岁。”这个问题就可以用递归方法来解决：第n个人的年龄用式子表达就是age(n)=age(n-1)+2(n&gt;1), 10(n=1) 。&emsp;&emsp;综合整篇文章，得出了S=2^n-1的结论以及n个盘子的解法，更重要的是成功应用了递归的思想，我从中体验到了一种数学的和谐之美，我们要发现生活中的数学之美，感受数学的魅力。 参考文献：[1]谭浩强编著，《C程序设计》，清华大学出版社，1991年，§7.6 函数的递归调用.]]></content>
      <categories>
        <category>学科</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>数学</tag>
        <tag>高中</tag>
        <tag>探究</tag>
        <tag>汉诺塔</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从诗歌看民主斗士闻一多的爱国情怀]]></title>
    <url>%2F2015%2F10%2Ftalking-about-the-patriotism-of-WenYiduo-from-poetry%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;说到民主斗士，每个人都会不约而同地想起中国现代伟大的爱国主义者——闻一多。闻一多本名闻家骅，字有三，他既是一名坚定的民主斗士，也是新月派的代表诗人和学者。他一生为中华民族的革命事业做着贡献，最终在云南昆明被国民党特务暗杀。&emsp;&emsp;我第一次了解闻一多先生是通过课文《最后一次讲演》，它记述了闻一多在昆明最后一次为李公朴、为民主而战斗，当时这篇课文对我有了很深的触动，我非常欣赏闻一多在自身危难的情况下仍能临危不惧、伸张正义的英雄气概。如今，读了闻一多所作的《死水》与《澳门》，我对他有了全新的认识。&emsp;&emsp;伟大的爱国主义诗人闻一多于1928年出版了《死水》，揭示了中国当时社会的黑暗一面。&emsp;&emsp;这首诗全诗都在描绘一潭肮脏、恶臭的死水，“这是一沟绝望的死水，清风吹不起半点漪沦”，作者开篇就用了“绝望”二字，把革命的新鲜力量比作清风，可这对于这绝望的死水却熟视无睹。全文三次写道“这是一沟绝望的死水”并通过“破铜烂铁、残羹剩饭、绿酒、白沫”等反面、贬义的意象来表明中国当时政治、社会局面混乱、破败不堪并逐渐走向绝望。作者大胆地指出问题，批评、抨击了政坛对此视而不见、不管不顾，正面直截了当地指出政府官员玩忽职守、迂腐不作为的严峻问题，体现了闻一多在文学作品中体现的浓厚的政治色彩，以及它英勇无畏的爱国主义情怀，我从中看出了闻一多在最后一次讲演中体现出的无畏与坚毅。&emsp;&emsp;但是我想作者讽刺社会以丑为美的目的一定不是他真的绝望了，而是想以此来唤醒被禁锢的人民，隐晦曲折地表明他既愤慨又想让情况好转，这也体现了闻一多为国着想、坚定的爱国精神。&emsp;&emsp;《澳门》是闻一多留美期间创作的《七子之歌》其中的一篇，诗歌原文引言：邶有七子之母不安其室。七子自怨自艾，冀以回其母心。这交代了闻一多的写作目的是替离开祖国养育的这七块地孤独而无处诉苦的哀痛情感。诗歌中作者以澳门的视角歌颂、激励着全国人民，把中国比做母亲，把澳门比作中国的乳儿，更加亲切也更有感染力，从内心深处的灵魂呼唤着自己想要回归到母亲怀抱的强烈愿望，体现出了闻一多深深的爱国情怀。&emsp;&emsp;无论是对《死水》的痛恨，还是对《澳门》的呼唤，无不体现了民主斗士闻一多时刻为国着想、坚毅无所畏惧的伟大爱国精神。成为中国文学与政治交融的一道亮丽的风景线。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>爱国</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
        <tag>闻一多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铭记历史，开创未来——游冉庄、白洋淀有感]]></title>
    <url>%2F2015%2F09%2Ffeeling-after-visiting-RanZhuang-and-Baiyang-Lake%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2015年9月，我们隆重纪念中国人民抗日战争暨世界反法西斯战争胜利70周年，为的是让每一位公民都担起维护世界和平的重担。&emsp;&emsp;为加强爱国主义教育，我们于9月20日驱车三小时赴河北省境内的冉庄和白洋淀进行为期两天的抗战教育社会实践活动。&emsp;&emsp;我们抵达冉庄后首先参观了于1959年建馆开放的冉庄地道战纪念馆，在这里保存了许多抗日时期珍贵的革命文物、影像资料与文献，纪念馆通过科技手段复原了地道战的情景，使游客可以更加直观、清晰地了解地道战。参观过后，我们便亲身实践钻了一回地道，这里的地道一般宽0.7至0.8米，高约1至1.5米，上距地面2米多，并且地道四通八达以供当时的村民避难，不过目前只开放了部分地道。在地道中的空间十分狭小，只能通过一个人，就像陶渊明笔下的桃花源口“初极狭，才通人”，并且这里的高度也仅仅不到两米，通过时必须弯着腰，在中部的空气也比较稀薄，所以虽然只走了一小段，同学们就累得腰酸背痛、满头大汗，由此也能看出当时的抗日游击队在地道中穿梭是多么辛苦。&emsp;&emsp;用过午餐后，我们驱车前往白洋淀，历经近三个小时的车程，我们抵达并安排了食宿。在晚上的篝火晚会上，同学们尽情施展自己的才艺，用歌声表达着对革命先烈的深深敬意。&emsp;&emsp;次日上午，我们随队乘船至华北明珠白洋淀的文化苑内，游览了建于革命老区的抗日胜地嘎子村。&emsp;&emsp;嘎子村，顾名思义就是小兵张嘎所居住的一座水村，这里三面环水，村边景色宜人，芦苇青翠，水清鸟鸣，荷花飘香，水光天色。但是这里不仅风景秀美，还承载着一段不可磨灭的抗日记忆。&emsp;&emsp;我们在这里集体观看了小兵张嘎的系列情景剧，这部情景剧以诙谐幽默的喜剧形式展现了张嘎当时面对日寇毫不畏惧、足智多谋的英雄本色。&emsp;&emsp;欣赏了白洋淀的壮美风景过后，我们在嘎子饭铺用了此次“红色之旅”的最后一餐，随后便返回了学校。&emsp;&emsp;在纪念中国人民抗日战争胜利70周年之际，此次冉庄、白洋淀之旅使我们感受到了强烈的民族自豪感，也为我们努力学习、捍卫祖国和平提供了强大动力，这真是一次值得回味的游览。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>爱国</tag>
        <tag>抗战</tag>
        <tag>红色</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东临戴河有遗篇——从《浪淘沙•北戴河》看毛泽东的壮美英雄气概]]></title>
    <url>%2F2015%2F09%2Freview-MaoZedong-s-heroic-spirit%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;毛泽东作为著名的政治家、思想家和革命家，他不但在新中国的建立中体现了他豪迈的英雄气概，在文学创作方面毛泽东同样有所作为，如《沁园春·长沙》、《长征》、《忆秦娥·娄山关》，无不体现了毛泽东诗词大气磅礴的写作风格。&emsp;&emsp;在其众多作品中，毛泽东与1954年在秦皇岛所作的《浪淘沙·北戴河》一词给我的印象最为深刻。毛泽东诗词大多采用借景抒情的方式来衬托自己当时的情感，而《浪淘沙·北戴河》的出众之处就在于他不但把北戴河初秋时萧瑟的景色描写得惟妙惟肖，还巧妙地展现了毛泽东无尽的感慨和博大的胸怀。&emsp;&emsp;上阕第一句“大雨落幽燕，白浪滔天，秦皇岛外打鱼船”主要描写了北戴河上的波涛景象，此时是天气恶劣时的北戴河，“幽燕”、“滔天”体现了雨大浪高，写出了水的大气磅礴之势，与儒家的“柔弱之水”有巨大差异。儒家的水是柔弱的，而毛泽东的水是凶猛的，从这里也能看出毛泽东诗词中体现出其人的狂放之气。“一片汪洋都不见，知向谁边？”描写了波涛汹涌的大海上，一片汪洋的海面上除了隐约能见到的渔船别无他物，这完全不同于江南水乡小桥流水、小舟在平静的水面上穿梭的悠哉，而是险要、骇人的巨浪，体现了毛泽东当时雄壮的气魄与阔达的胸襟。&emsp;&emsp;而到了下阙又立刻穿越了时间和空间，越过千年忆往事，回到了曹操的《观沧海》，在这一首气势恢宏的作品中，曹操同是在萧瑟中抒发自己内心的雄心壮志与宏大抱负，仿佛星河中的无数繁星都由自己眼前的大水所吞吐。而此时站在北戴河前的毛泽东有着与曹操相同的胸怀与眼光，只不过“若出其中”的这其中由沧海换成了北戴河罢了。&emsp;&emsp;然而“萧瑟秋风今又是，换了人间”表明一切又都重新开始了，抒发了毛泽东对现世的感慨，本词也以此结尾，意味着深邃的历史已经过去，美好的新人间已经到来，毛泽东用壮美的景色写出了他壮美的英雄气概。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>毛泽东</tag>
        <tag>评析</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观“纪念中国人民抗日战争暨世界反法西斯战争胜利70周年活动”阅兵式有感]]></title>
    <url>%2F2015%2F09%2Fafter-watching-the-70th-anniversary-parade%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;1945年，中国结束了近十年的抗日战争，也宣告了世界反法西斯战争的最终胜利，中国以几千万人民牺牲的代价换取了世界的和平。&emsp;&emsp;2015年，时隔70年，我们隆重举行抗战胜利纪念活动，这不仅仅是纪念，更是对现世人民的警示。9月3日，是我国设立的抗日战争胜利纪念日，在这一天进行阅兵式，有着历史纪念意义，标志着维持了70年世界的宁静。&emsp;&emsp;2015年9月3日上午九时许，习主席在端门前隆重接见参与世界反法西斯战争的各国领导人或代表，并登上天安门。“将士们，听党指挥，能打胜仗，作风优良，不惧强敌，敢较量，为祖国决胜疆场”的歌声响彻整条长安街。上午十时，阅兵正式开始，鸣礼炮70响，不但象征了70年前的胜利，还表达了对抗日先烈的深深缅怀。与此同时，国旗护卫队穿过抗日英雄纪念碑，走到旗杆下，军乐团奏响了《义勇军进行曲》，五星红旗冉冉升起，飘扬在空中，那鲜艳的红色，是用烈士的鲜血染成的！&emsp;&emsp;习主席乘坐的轿车缓缓驶过每一个受阅方阵，看着将士们嘶声力竭地喊着“为人民服务！”，我深深感受到对祖国的自豪之情。分列式开始了，护旗方阵悬挂着中华人民共和国国旗和中国人民解放军军旗沿长安街飞过天安门城楼。伴随着《分列式进行曲》，一个个英模方队正步走过天安门，他们整齐划一的步伐、响彻天空的口号，无不体现了我国军人的良好素质与优秀作风。当抗日老兵们坐着车经过天安门，手敬军礼，眼含热泪地注视着主席时，我也不禁落下了眼泪。他们是抗日英雄，他们铸就了新中国，如果没有他们，与法西斯的斗争不可能在1945年结束。&emsp;&emsp;后勤保障方阵和白求恩医疗方阵也走过了天安门，他们无时不刻关爱着每一名军人，保障了军人的生活物资、武器装备与生命安全。他们是一支合格军队必备的后方支柱。&emsp;&emsp;紧随其后的是地面装备方阵，巨大彪悍的坦克、装甲车、突击车和反恐武警车辆整齐地驶过了观众席，这体现了我国强大的陆军实力与打击恐怖分子的能力。导弹方阵向世界人民展示了我国研发的导弹实力，近程、中程、远程导弹应有尽有，证明我军对全球的精确打击能力，震慑着想要破坏世界和平蠢蠢欲动的敌人。“核常兼备”导弹车，不但可以发射常规导弹，还有能力发射核导弹，这在极端情况下非常实用，也展示了我国军队武器研发团队的科技实力。&emsp;&emsp;最后亮相的是战斗机和直升机方阵，他们在空中还能飞的如此整齐让人惊叹，我感受到了我国空军部队的强大。空军飞行员驾驶者战机掠过五湖四海，捍卫着中华大地，带领中国军队飞向新的高度！&emsp;&emsp;铭记历史，缅怀先烈，珍爱和平，开创未来。让我们牢牢记住并践行这十六个字，让祖国强大，让世界和平！&emsp;&emsp;和平必胜！正义必胜！]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>爱国</tag>
        <tag>和平</tag>
        <tag>抗战</tag>
        <tag>红色</tag>
        <tag>观后感</tag>
      </tags>
  </entry>
</search>
